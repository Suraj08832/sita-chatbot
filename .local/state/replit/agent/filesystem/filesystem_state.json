{"file_contents":{"sitaBot/modules/helper_funcs/filters.py":{"content":"from sitaBot import DEV_USERS, DRAGONS, DEMONS\nfrom telegram import Message\nfrom telegram.ext import BaseFilter\n\n\nclass CustomFilters(object):\n    class _Supporters(BaseFilter):\n        def filter(self, message: Message):\n            return bool(message.from_user and message.from_user.id in DEMONS)\n        \n        def __call__(self, message: Message):\n            return self.filter(message)\n\n    support_filter = _Supporters()\n\n    class _Sudoers(BaseFilter):\n        def filter(self, message: Message):\n            return bool(message.from_user and message.from_user.id in DRAGONS)\n        \n        def __call__(self, message: Message):\n            return self.filter(message)\n\n    sudo_filter = _Sudoers()\n\n    class _Developers(BaseFilter):\n        def filter(self, message: Message):\n            return bool(message.from_user and message.from_user.id in DEV_USERS)\n        \n        def __call__(self, message: Message):\n            return self.filter(message)\n\n    dev_filter = _Developers()\n\n    class _MimeType(BaseFilter):\n        def __init__(self, mimetype):\n            self.mime_type = mimetype\n            self.name = \"CustomFilters.mime_type({})\".format(self.mime_type)\n\n        def filter(self, message: Message):\n            return bool(\n                message.document and message.document.mime_type == self.mime_type\n            )\n        \n        def __call__(self, message: Message):\n            return self.filter(message)\n\n    mime_type = _MimeType\n\n    class _HasText(BaseFilter):\n        def filter(self, message: Message):\n            return bool(\n                message.text\n                or message.sticker\n                or message.photo\n                or message.document\n                or message.video\n            )\n        \n        def __call__(self, message: Message):\n            return self.filter(message)\n\n    has_text = _HasText()\n","size_bytes":1879},"sitaBot/modules/helper_funcs/string_handling.py":{"content":"import re\nimport time\nfrom typing import Dict, List\n\nimport bleach\nimport markdown2\nimport emoji\n\nfrom telegram import MessageEntity\nfrom telegram.utils.helpers import escape_markdown\n\n# NOTE: the url \\ escape may cause double escapes\n# match * (bold) (don't escape if in url)\n# match _ (italics) (don't escape if in url)\n# match ` (code)\n# match []() (markdown link)\n# else, escape *, _, `, and [\nMATCH_MD = re.compile(\n    r\"\\*(.*?)\\*|\"\n    r\"_(.*?)_|\"\n    r\"`(.*?)`|\"\n    r\"(?<!\\\\)(\\[.*?\\])(\\(.*?\\))|\"\n    r\"(?P<esc>[*_`\\[])\"\n)\n\n# regex to find []() links -> hyperlinks/buttons\nLINK_REGEX = re.compile(r\"(?<!\\\\)\\[.+?\\]\\((.*?)\\)\")\nBTN_URL_REGEX = re.compile(r\"(\\[([^\\[]+?)\\]\\(buttonurl:(?:/{0,2})(.+?)(:same)?\\))\")\n\n\ndef _selective_escape(to_parse: str) -> str:\n    \"\"\"\n    Escape all invalid markdown\n\n    :param to_parse: text to escape\n    :return: valid markdown string\n    \"\"\"\n    offset = 0  # offset to be used as adding a \\ character causes the string to shift\n    for match in MATCH_MD.finditer(to_parse):\n        if match.group(\"esc\"):\n            ent_start = match.start()\n            to_parse = (\n                to_parse[: ent_start + offset] + \"\\\\\" + to_parse[ent_start + offset :]\n            )\n            offset += 1\n    return to_parse\n\n\n# This is a fun one.\ndef _calc_emoji_offset(to_calc) -> int:\n    # Get all emoji in text.\n    emoticons = emoji.get_emoji_regexp().finditer(to_calc)\n    # Check the utf16 length of the emoji to determine the offset it caused.\n    # Normal, 1 character emoji don't affect; hence sub 1.\n    # special, eg with two emoji characters (eg face, and skin col) will have length 2, so by subbing one we\n    # know we'll get one extra offset,\n    return sum(len(e.group(0).encode(\"utf-16-le\")) // 2 - 1 for e in emoticons)\n\n\ndef markdown_parser(\n    txt: str, entities: Dict[MessageEntity, str] = None, offset: int = 0\n) -> str:\n    \"\"\"\n    Parse a string, escaping all invalid markdown entities.\n\n    Escapes URL's so as to avoid URL mangling.\n    Re-adds any telegram code entities obtained from the entities object.\n\n    :param txt: text to parse\n    :param entities: dict of message entities in text\n    :param offset: message offset - command and notename length\n    :return: valid markdown string\n    \"\"\"\n    if not entities:\n        entities = {}\n    if not txt:\n        return \"\"\n\n    prev = 0\n    res = \"\"\n    # Loop over all message entities, and:\n    # reinsert code\n    # escape free-standing urls\n    for ent, ent_text in entities.items():\n        if ent.offset < -offset:\n            continue\n\n        start = ent.offset + offset  # start of entity\n        end = ent.offset + offset + ent.length - 1  # end of entity\n\n        # we only care about code, url, text links\n        if ent.type in (\"code\", \"url\", \"text_link\"):\n            # count emoji to switch counter\n            count = _calc_emoji_offset(txt[:start])\n            start -= count\n            end -= count\n\n            # URL handling -> do not escape if in [](), escape otherwise.\n            if ent.type == \"url\":\n                if any(\n                    match.start(1) <= start and end <= match.end(1)\n                    for match in LINK_REGEX.finditer(txt)\n                ):\n                    continue\n                # else, check the escapes between the prev and last and forcefully escape the url to avoid mangling\n                else:\n                    # TODO: investigate possible offset bug when lots of emoji are present\n                    res += _selective_escape(txt[prev:start] or \"\") + escape_markdown(\n                        ent_text\n                    )\n\n            # code handling\n            elif ent.type == \"code\":\n                res += _selective_escape(txt[prev:start]) + \"`\" + ent_text + \"`\"\n\n            # handle markdown/html links\n            elif ent.type == \"text_link\":\n                res += _selective_escape(txt[prev:start]) + \"[{}]({})\".format(\n                    ent_text, ent.url\n                )\n\n            end += 1\n\n        # anything else\n        else:\n            continue\n\n        prev = end\n\n    res += _selective_escape(txt[prev:])  # add the rest of the text\n    return res\n\n\ndef button_markdown_parser(\n    txt: str, entities: Dict[MessageEntity, str] = None, offset: int = 0\n) -> (str, List):\n    markdown_note = markdown_parser(txt, entities, offset)\n    prev = 0\n    note_data = \"\"\n    buttons = []\n    for match in BTN_URL_REGEX.finditer(markdown_note):\n        # Check if btnurl is escaped\n        n_escapes = 0\n        to_check = match.start(1) - 1\n        while to_check > 0 and markdown_note[to_check] == \"\\\\\":\n            n_escapes += 1\n            to_check -= 1\n\n        # if even, not escaped -> create button\n        if n_escapes % 2 == 0:\n            # create a thruple with button label, url, and newline status\n            buttons.append((match.group(2), match.group(3), bool(match.group(4))))\n            note_data += markdown_note[prev : match.start(1)]\n            prev = match.end(1)\n        # if odd, escaped -> move along\n        else:\n            note_data += markdown_note[prev:to_check]\n            prev = match.start(1) - 1\n    else:\n        note_data += markdown_note[prev:]\n\n    return note_data, buttons\n\n\ndef escape_invalid_curly_brackets(text: str, valids: List[str]) -> str:\n    new_text = \"\"\n    idx = 0\n    while idx < len(text):\n        if text[idx] == \"{\":\n            if idx + 1 < len(text) and text[idx + 1] == \"{\":\n                idx += 2\n                new_text += \"{{{{\"\n                continue\n            else:\n                success = False\n                for v in valids:\n                    if text[idx:].startswith(\"{\" + v + \"}\"):\n                        success = True\n                        break\n                if success:\n                    new_text += text[idx : idx + len(v) + 2]\n                    idx += len(v) + 2\n                    continue\n                else:\n                    new_text += \"{{\"\n\n        elif text[idx] == \"}\":\n            if idx + 1 < len(text) and text[idx + 1] == \"}\":\n                idx += 2\n                new_text += \"}}}}\"\n                continue\n            else:\n                new_text += \"}}\"\n\n        else:\n            new_text += text[idx]\n        idx += 1\n\n    return new_text\n\n\nSMART_OPEN = \"‚Äú\"\nSMART_CLOSE = \"‚Äù\"\nSTART_CHAR = (\"'\", '\"', SMART_OPEN)\n\n\ndef split_quotes(text: str) -> List:\n    if not any(text.startswith(char) for char in START_CHAR):\n        return text.split(None, 1)\n    counter = 1  # ignore first char -> is some kind of quote\n    while counter < len(text):\n        if text[counter] == \"\\\\\":\n            counter += 1\n        elif text[counter] == text[0] or (\n            text[0] == SMART_OPEN and text[counter] == SMART_CLOSE\n        ):\n            break\n        counter += 1\n    else:\n        return text.split(None, 1)\n\n    # 1 to avoid starting quote, and counter is exclusive so avoids ending\n    key = remove_escapes(text[1:counter].strip())\n    # index will be in range, or `else` would have been executed and returned\n    rest = text[counter + 1 :].strip()\n    if not key:\n        key = text[0] + text[0]\n    return list(filter(None, [key, rest]))\n\n\ndef remove_escapes(text: str) -> str:\n    res = \"\"\n    is_escaped = False\n    for counter in range(len(text)):\n        if is_escaped:\n            res += text[counter]\n            is_escaped = False\n        elif text[counter] == \"\\\\\":\n            is_escaped = True\n        else:\n            res += text[counter]\n    return res\n\n\ndef escape_chars(text: str, to_escape: List[str]) -> str:\n    to_escape.append(\"\\\\\")\n    new_text = \"\"\n    for x in text:\n        if x in to_escape:\n            new_text += \"\\\\\"\n        new_text += x\n    return new_text\n\n\ndef extract_time(message, time_val):\n    if any(time_val.endswith(unit) for unit in (\"m\", \"h\", \"d\")):\n        unit = time_val[-1]\n        time_num = time_val[:-1]  # type: str\n        if not time_num.isdigit():\n            message.reply_text(\"Invalid time amount specified.\")\n            return \"\"\n\n        if unit == \"m\":\n            bantime = int(time.time() + int(time_num) * 60)\n        elif unit == \"h\":\n            bantime = int(time.time() + int(time_num) * 60 * 60)\n        elif unit == \"d\":\n            bantime = int(time.time() + int(time_num) * 24 * 60 * 60)\n        else:\n            # how even...?\n            return \"\"\n        return bantime\n    else:\n        message.reply_text(\n            \"Invalid time type specified. Expected m,h, or d, got: {}\".format(\n                time_val[-1]\n            )\n        )\n        return \"\"\n\n\ndef markdown_to_html(text):\n    text = text.replace(\"*\", \"**\")\n    text = text.replace(\"`\", \"```\")\n    text = text.replace(\"~\", \"~~\")\n    _html = markdown2.markdown(text, extras=[\"strike\", \"underline\"])\n    return bleach.clean(\n        _html, tags=[\"strong\", \"em\", \"a\", \"code\", \"pre\", \"strike\", \"u\"], strip=True\n    )[:-1]\n","size_bytes":8897},"sitaBot/modules/helper_funcs/alternate.py":{"content":"from telegram.error import BadRequest\nfrom functools import wraps\nfrom telegram import ChatAction\n\n\ndef send_message(message, text, *args, **kwargs):\n    try:\n        return message.reply_text(text, *args, **kwargs)\n    except BadRequest as err:\n        if str(err) == \"Reply message not found\":\n            return message.reply_text(text, quote=False, *args, **kwargs)\n\n\ndef typing_action(func):\n    \"\"\"Sends typing action while processing func command.\"\"\"\n\n    @wraps(func)\n    def command_func(update, context, *args, **kwargs):\n        context.bot.send_chat_action(\n            chat_id=update.effective_chat.id, action=ChatAction.TYPING\n        )\n        return func(update, context, *args, **kwargs)\n\n    return command_func\n","size_bytes":730},"sitaBot/pyrogramee/errors.py":{"content":"import sys\nimport traceback\nfrom functools import wraps\nfrom sitaBot import pbot, SUPPORT_CHAT\n\ndef split_limits(text):\n    if len(text) < 2048:\n        return [text]\n\n    lines = text.splitlines(True)\n    small_msg = ''\n    result = []\n    for line in lines:\n        if len(small_msg) + len(line) < 2048:\n            small_msg += line\n        else:\n            result.append(small_msg)\n            small_msg = line\n    else:\n        result.append(small_msg)\n\n    return result\n\ndef capture_err(func):\n    @wraps(func)\n    async def capture(client, message, *args, **kwargs):\n        try:\n            return await func(client, message, *args, **kwargs)\n        except Exception as err:\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            errors = traceback.format_exception(\n                etype=exc_type, value=exc_obj, tb=exc_tb,\n            )\n            error_feedback = split_limits(\n                '**ERROR** | `{}` | `{}`\\n\\n```{}```\\n\\n```{}```\\n'.format(\n                    0 if not message.from_user else message.from_user.id,\n                    0 if not message.chat else message.chat.id,\n                    message.text or message.caption,\n                    ''.join(errors),\n                ),\n            )\n            for x in error_feedback:\n                await pbot.send_message(\n                    SUPPORT_CHAT,\n                    x\n                )\n            raise err\n    return capture\n","size_bytes":1435},"sitaBot/modules/__heroku.py":{"content":"import asyncio\nimport math\nimport os\n\nimport heroku3\nimport requests\n\nfrom sitaBot import telethn as borg, HEROKU_APP_NAME, HEROKU_API_KEY, OWNER_ID\nfrom sitaBot.events import register\n\nheroku_api = \"https://api.heroku.com\"\nHeroku = heroku3.from_key(HEROKU_API_KEY)\n\n\n@register(pattern=\"^/(set|see|del) var(?: |$)(.*)(?: |$)([\\s\\S]*)\")\nasync def variable(var):\n    if var.fwd_from:\n        return\n    if var.sender_id == OWNER_ID:\n        pass\n    else:\n        return\n    \"\"\"\n    Manage most of ConfigVars setting, set new var, get current var,\n    or delete var...\n    \"\"\"\n    if HEROKU_APP_NAME is not None:\n        app = Heroku.app(HEROKU_APP_NAME)\n    else:\n        return await var.reply(\"`[HEROKU]:\" \"\\nPlease setup your` **HEROKU_APP_NAME**\")\n    exe = var.pattern_match.group(1)\n    heroku_var = app.config()\n    if exe == \"see\":\n        k = await var.reply(\"`Getting information...`\")\n        await asyncio.sleep(1.5)\n        try:\n            variable = var.pattern_match.group(2).split()[0]\n            if variable in heroku_var:\n                return await k.edit(\n                    \"**ConfigVars**:\" f\"\\n\\n`{variable} = {heroku_var[variable]}`\\n\"\n                )\n            else:\n                return await k.edit(\n                    \"**ConfigVars**:\" f\"\\n\\n`Error:\\n-> {variable} don't exists`\"\n                )\n        except IndexError:\n            configs = prettyjson(heroku_var.to_dict(), indent=2)\n            with open(\"configs.json\", \"w\") as fp:\n                fp.write(configs)\n            with open(\"configs.json\", \"r\") as fp:\n                result = fp.read()\n                if len(result) >= 4096:\n                    await var.client.send_file(\n                        var.chat_id,\n                        \"configs.json\",\n                        reply_to=var.id,\n                        caption=\"`Output too large, sending it as a file`\",\n                    )\n                else:\n                    await k.edit(\n                        \"`[HEROKU]` ConfigVars:\\n\\n\"\n                        \"================================\"\n                        f\"\\n```{result}```\\n\"\n                        \"================================\"\n                    )\n            os.remove(\"configs.json\")\n            return\n    elif exe == \"set\":\n        s = await var.reply(\"`Setting information...weit ser`\")\n        variable = var.pattern_match.group(2)\n        if not variable:\n            return await s.edit(\">`.set var <ConfigVars-name> <value>`\")\n        value = var.pattern_match.group(3)\n        if not value:\n            variable = variable.split()[0]\n            try:\n                value = var.pattern_match.group(2).split()[1]\n            except IndexError:\n                return await s.edit(\">`/set var <ConfigVars-name> <value>`\")\n        await asyncio.sleep(1.5)\n        if variable in heroku_var:\n            await s.edit(\n                f\"**{variable}**  `successfully changed to`  ->  **{value}**\"\n            )\n        else:\n            await s.edit(\n                f\"**{variable}**  `successfully added with value`  ->  **{value}**\"\n            )\n        heroku_var[variable] = value\n    elif exe == \"del\":\n        m = await var.edit(\"`Getting information to deleting variable...`\")\n        try:\n            variable = var.pattern_match.group(2).split()[0]\n        except IndexError:\n            return await m.edit(\"`Please specify ConfigVars you want to delete`\")\n        await asyncio.sleep(1.5)\n        if variable in heroku_var:\n            await m.edit(f\"**{variable}**  `successfully deleted`\")\n            del heroku_var[variable]\n        else:\n            return await m.edit(f\"**{variable}**  `is not exists`\")\n\n\n@register(pattern=\"^/usage(?: |$)\")\nasync def dyno_usage(dyno):\n    if dyno.fwd_from:\n        return\n    if dyno.sender_id == OWNER_ID:\n        pass\n    else:\n        return\n    \"\"\"\n    Get your account Dyno Usage\n    \"\"\"\n    die = await dyno.reply(\"**Processing...**\")\n    useragent = (\n        \"Mozilla/5.0 (Linux; Android 10; SM-G975F) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n        \"Chrome/80.0.3987.149 Mobile Safari/537.36\"\n    )\n    user_id = Heroku.account().id\n    headers = {\n        \"User-Agent\": useragent,\n        \"Authorization\": f\"Bearer {HEROKU_API_KEY}\",\n        \"Accept\": \"application/vnd.heroku+json; version=3.account-quotas\",\n    }\n    path = \"/accounts/\" + user_id + \"/actions/get-quota\"\n    r = requests.get(heroku_api + path, headers=headers)\n    if r.status_code != 200:\n        return await die.edit(\n            \"`Error: something bad happened`\\n\\n\" f\">.`{r.reason}`\\n\"\n        )\n    result = r.json()\n    quota = result[\"account_quota\"]\n    quota_used = result[\"quota_used\"]\n\n    \"\"\" - Used - \"\"\"\n    remaining_quota = quota - quota_used\n    percentage = math.floor(remaining_quota / quota * 100)\n    minutes_remaining = remaining_quota / 60\n    hours = math.floor(minutes_remaining / 60)\n    minutes = math.floor(minutes_remaining % 60)\n\n    \"\"\" - Current - \"\"\"\n    App = result[\"apps\"]\n    try:\n        App[0][\"quota_used\"]\n    except IndexError:\n        AppQuotaUsed = 0\n        AppPercentage = 0\n    else:\n        AppQuotaUsed = App[0][\"quota_used\"] / 60\n        AppPercentage = math.floor(App[0][\"quota_used\"] * 100 / quota)\n    AppHours = math.floor(AppQuotaUsed / 60)\n    AppMinutes = math.floor(AppQuotaUsed % 60)\n\n    await asyncio.sleep(1.5)\n\n    return await die.edit(\n        \"**Dyno Usage**:\\n\\n\"\n        f\" -> `Dyno usage for`  **{HEROKU_APP_NAME}**:\\n\"\n        f\"     ‚Ä¢  `{AppHours}`**h**  `{AppMinutes}`**m**  \"\n        f\"**|**  [`{AppPercentage}`**%**]\"\n        \"\\n\\n\"\n        \" -> `Dyno hours quota remaining this month`:\\n\"\n        f\"     ‚Ä¢  `{hours}`**h**  `{minutes}`**m**  \"\n        f\"**|**  [`{percentage}`**%**]\"\n    )\n\n\n@register(pattern=\"^/logs$\")\nasync def _(dyno):\n    if dyno.fwd_from:\n        return\n    if dyno.sender_id == OWNER_ID:\n        pass\n    else:\n        return\n    try:\n        Heroku = heroku3.from_key(HEROKU_API_KEY)\n        app = Heroku.app(HEROKU_APP_NAME)\n    except:\n        return await dyno.reply(\n            \" Please make sure your Heroku API Key, Your App name are configured correctly in the heroku\"\n        )\n    v = await dyno.reply(\"Getting Logs....\")\n    with open(\"logs.txt\", \"w\") as log:\n        log.write(app.get_log())\n    await v.edit(\"Got the logs wait a sec\")\n    await dyno.client.send_file(\n        dyno.chat_id,\n        \"logs.txt\",\n        reply_to=dyno.id,\n        caption=\"SitaBot Logs.\",\n    )\n\n    await asyncio.sleep(5)\n    await v.delete()\n    return os.remove(\"logs.txt\")\n\n\ndef prettyjson(obj, indent=2, maxlinelength=80):\n    \"\"\"Renders JSON content with indentation and line splits/concatenations to fit maxlinelength.\n    Only dicts, lists and basic types are supported\"\"\"\n\n    items, _ = getsubitems(\n        obj,\n        itemkey=\"\",\n        islast=True,\n        maxlinelength=maxlinelength - indent,\n        indent=indent,\n    )\n    return indentitems(items, indent, level=0)\n","size_bytes":6981},"sitaBot/modules/admin.py":{"content":"import html\n\nfrom telegram import ParseMode, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, Filters, run_async\nfrom telegram.utils.helpers import mention_html\n\nfrom sitaBot import DRAGONS, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    can_pin,\n    can_promote,\n    connection_status,\n    user_admin,\n    ADMIN_CACHE,\n)\nfrom sitaBot.helper_extra.admin_rights import (\n    user_can_pin,\n    user_can_promote,\n    user_can_changeinfo,\n)\n\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_user,\n    extract_user_and_text,\n)\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.helper_funcs.alternate import send_message\nfrom sitaBot.modules.helper_funcs.alternate import typing_action\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_promote\n@user_admin\n@loggable\ndef promote(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    args = context.args\n\n    message = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n\n    promoter = chat.get_member(user.id)\n\n    if (\n        not (promoter.can_promote_members or promoter.status == \"creator\")\n        and user.id not in DRAGONS\n    ):\n        message.reply_text(\"You don't have the necessary rights to do that!\")\n        return\n\n    user_id = extract_user(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n\n    try:\n        user_member = chat.get_member(user_id)\n    except:\n        return\n\n    if user_member.status == \"administrator\" or user_member.status == \"creator\":\n        message.reply_text(\"How am I meant to promote someone that's already an admin?\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I can't promote myself! Get an admin to do it for me.\")\n        return\n\n    # set same perms as bot - bot can't assign higher perms than itself!\n    bot_member = chat.get_member(bot.id)\n\n    try:\n        bot.promoteChatMember(\n            chat.id,\n            user_id,\n            can_change_info=bot_member.can_change_info,\n            can_post_messages=bot_member.can_post_messages,\n            can_edit_messages=bot_member.can_edit_messages,\n            can_delete_messages=bot_member.can_delete_messages,\n            can_invite_users=bot_member.can_invite_users,\n            # can_promote_members=bot_member.can_promote_members,\n            can_restrict_members=bot_member.can_restrict_members,\n            can_pin_messages=bot_member.can_pin_messages,\n        )\n    except BadRequest as err:\n        if err.message == \"User_not_mutual_contact\":\n            message.reply_text(\"I can't promote someone who isn't in the group.\")\n        else:\n            message.reply_text(\"An error occured while promoting.\")\n        return\n\n    bot.sendMessage(\n        chat.id,\n        f\"Sucessfully promoted <b>{user_member.user.first_name or user_id}</b>!\",\n        parse_mode=ParseMode.HTML,\n    )\n\n    log_message = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"USER PROMOTED SUCCESSFULLY\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>User:</b> {mention_html(user_member.user.id, user_member.user.first_name)}\"\n    )\n\n    return log_message\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_promote\n@user_admin\n@loggable\ndef demote(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    args = context.args\n\n    chat = update.effective_chat\n    message = update.effective_message\n    user = update.effective_user\n\n    user_id = extract_user(message, args)\n\n    if user_can_promote(chat, user, context.bot.id) is False:\n        message.reply_text(\"You don't have enough rights to demote someone!\")\n        return \"\"\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n\n    try:\n        user_member = chat.get_member(user_id)\n    except:\n        return\n\n    if user_member.status == \"creator\":\n        message.reply_text(\"This person CREATED the chat, how would I demote them?\")\n        return\n\n    if not user_member.status == \"administrator\":\n        message.reply_text(\"Can't demote what wasn't promoted!\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I can't demote myself! Get an admin to do it for me.\")\n        return\n\n    try:\n        bot.promoteChatMember(\n            chat.id,\n            user_id,\n            can_change_info=False,\n            can_post_messages=False,\n            can_edit_messages=False,\n            can_delete_messages=False,\n            can_invite_users=False,\n            can_restrict_members=False,\n            can_pin_messages=False,\n            can_promote_members=False,\n        )\n\n        bot.sendMessage(\n            chat.id,\n            f\"Sucessfully demoted <b>{user_member.user.first_name or user_id}</b>!\",\n            parse_mode=ParseMode.HTML,\n        )\n\n        log_message = (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"USER DEMOTED SUCCESSFULLY\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n            f\"<b>User:</b> {mention_html(user_member.user.id, user_member.user.first_name)}\"\n        )\n\n        return log_message\n    except BadRequest:\n        message.reply_text(\n            \"Could not demote. I might not be admin, or the admin status was appointed by another\"\n            \" user, so I can't act upon them!\"\n        )\n        return\n\n\n@run_async\n@user_admin\ndef refresh_admin(update, _):\n    try:\n        ADMIN_CACHE.pop(update.effective_chat.id)\n    except KeyError:\n        pass\n\n    update.effective_message.reply_text(\"Admins cache refreshed!\")\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_promote\n@user_admin\ndef set_title(update: Update, context: CallbackContext):\n    bot = context.bot\n    args = context.args\n\n    chat = update.effective_chat\n    message = update.effective_message\n\n    user_id, title = extract_user_and_text(message, args)\n    try:\n        user_member = chat.get_member(user_id)\n    except:\n        return\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n\n    if user_member.status == \"creator\":\n        message.reply_text(\n            \"This person CREATED the chat, how can i set custom title for him?\"\n        )\n        return\n\n    if user_member.status != \"administrator\":\n        message.reply_text(\n            \"Can't set title for non-admins!\\nPromote them first to set custom title!\"\n        )\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\n            \"I can't set my own title myself! Get the one who made me admin to do it for me.\"\n        )\n        return\n\n    if not title:\n        message.reply_text(\"Setting blank title doesn't do anything!\")\n        return\n\n    if len(title) > 16:\n        message.reply_text(\n            \"The title length is longer than 16 characters.\\nTruncating it to 16 characters.\"\n        )\n\n    try:\n        bot.setChatAdministratorCustomTitle(chat.id, user_id, title)\n    except BadRequest:\n        message.reply_text(\"I can't set custom title for admins that I didn't promote!\")\n        return\n\n    bot.sendMessage(\n        chat.id,\n        f\"Sucessfully set title for <code>{user_member.user.first_name or user_id}</code> \"\n        f\"to <code>{html.escape(title[:16])}</code>!\",\n        parse_mode=ParseMode.HTML,\n    )\n\n\n@run_async\n@bot_admin\n@user_admin\n@typing_action\ndef setchatpic(update, context):\n    chat = update.effective_chat\n    msg = update.effective_message\n    user = update.effective_user\n\n    if user_can_changeinfo(chat, user, context.bot.id) is False:\n        msg.reply_text(\"You are missing right to change group info!\")\n        return\n\n    if msg.reply_to_message:\n        if msg.reply_to_message.photo:\n            pic_id = msg.reply_to_message.photo[-1].file_id\n        elif msg.reply_to_message.document:\n            pic_id = msg.reply_to_message.document.file_id\n        else:\n            msg.reply_text(\"You can only set some photo as chat pic!\")\n            return\n        dlmsg = msg.reply_text(\"Just a sec...\")\n        tpic = context.bot.get_file(pic_id)\n        tpic.download(\"gpic.png\")\n        try:\n            with open(\"gpic.png\", \"rb\") as chatp:\n                context.bot.set_chat_photo(int(chat.id), photo=chatp)\n                msg.reply_text(\"Successfully set new chatpic!\")\n        except BadRequest as excp:\n            msg.reply_text(f\"Error! {excp.message}\")\n        finally:\n            dlmsg.delete()\n            if os.path.isfile(\"gpic.png\"):\n                os.remove(\"gpic.png\")\n    else:\n        msg.reply_text(\"Reply to some photo or file to set new chat pic!\")\n\n\n@run_async\n@bot_admin\n@user_admin\n@typing_action\ndef rmchatpic(update, context):\n    chat = update.effective_chat\n    msg = update.effective_message\n    user = update.effective_user\n\n    if user_can_changeinfo(chat, user, context.bot.id) is False:\n        msg.reply_text(\"You don't have enough rights to delete group photo\")\n        return\n    try:\n        context.bot.delete_chat_photo(int(chat.id))\n        msg.reply_text(\"Successfully deleted chat's profile photo!\")\n    except BadRequest as excp:\n        msg.reply_text(f\"Error! {excp.message}.\")\n        return\n\n\n@run_async\n@bot_admin\n@user_admin\n@typing_action\ndef setchat_title(update, context):\n    chat = update.effective_chat\n    msg = update.effective_message\n    user = update.effective_user\n    args = context.args\n\n    if user_can_changeinfo(chat, user, context.bot.id) is False:\n        msg.reply_text(\"You don't have enough rights to change chat info!\")\n        return\n\n    title = \" \".join(args)\n    if not title:\n        msg.reply_text(\"Enter some text to set new title in your chat!\")\n        return\n\n    try:\n        context.bot.set_chat_title(int(chat.id), str(title))\n        msg.reply_text(\n            f\"Successfully set <b>{title}</b> as new chat title!\",\n            parse_mode=ParseMode.HTML,\n        )\n    except BadRequest as excp:\n        msg.reply_text(f\"Error! {excp.message}.\")\n        return\n\n\n@run_async\n@bot_admin\n@user_admin\n@typing_action\ndef set_sticker(update, context):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if user_can_changeinfo(chat, user, context.bot.id) is False:\n        return msg.reply_text(\"You're missing rights to change chat info!\")\n\n    if msg.reply_to_message:\n        if not msg.reply_to_message.sticker:\n            return msg.reply_text(\n                \"You need to reply to some sticker to set chat sticker set!\"\n            )\n        stkr = msg.reply_to_message.sticker.set_name\n        try:\n            context.bot.set_chat_sticker_set(chat.id, stkr)\n            msg.reply_text(\n                f\"Successfully set new group stickers in {chat.title}!\")\n        except BadRequest as excp:\n            if excp.message == \"Participants_too_few\":\n                return msg.reply_text(\n                    \"Sorry, due to telegram restrictions chat needs to have minimum 100 members before they can have group stickers!\"\n                )\n            msg.reply_text(f\"Error! {excp.message}.\")\n    else:\n        msg.reply_text(\n            \"You need to reply to some sticker to set chat sticker set!\")\n\n\n@run_async\n@bot_admin\n@user_admin\n@typing_action\ndef set_desc(update, context):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if user_can_changeinfo(chat, user, context.bot.id) is False:\n        return msg.reply_text(\"You're missing rights to change chat info!\")\n\n    tesc = msg.text.split(None, 1)\n    if len(tesc) >= 2:\n        desc = tesc[1]\n    else:\n        return msg.reply_text(\"Setting empty description won't do anything!\")\n    try:\n        if len(desc) > 255:\n            return msg.reply_text(\n                \"Description must needs to be under 255 characters!\")\n        context.bot.set_chat_description(chat.id, desc)\n        msg.reply_text(\n            f\"Successfully updated chat description in {chat.title}!\")\n    except BadRequest as excp:\n        msg.reply_text(f\"Error! {excp.message}.\")\n\n\ndef __chat_settings__(chat_id, user_id):\n    return \"You are *admin*: `{}`\".format(\n        dispatcher.bot.get_chat_member(chat_id, user_id).status\n        in (\"administrator\", \"creator\")\n    )\n\n\n@run_async\n@bot_admin\n@can_pin\n@user_admin\n@loggable\ndef pin(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    args = context.args\n\n    user = update.effective_user\n    chat = update.effective_chat\n\n    is_group = chat.type != \"private\" and chat.type != \"channel\"\n    prev_message = update.effective_message.reply_to_message\n\n    if user_can_pin(chat, user, context.bot.id) is False:\n        message.reply_text(\"You are missing rights to pin a message!\")\n        return \"\"\n\n    is_silent = True\n    if len(args) >= 1:\n        is_silent = not (\n            args[0].lower() == \"notify\"\n            or args[0].lower() == \"loud\"\n            or args[0].lower() == \"violent\"\n        )\n\n    if prev_message and is_group:\n        try:\n            bot.pinChatMessage(\n                chat.id, prev_message.message_id, disable_notification=is_silent\n            )\n        except BadRequest as excp:\n            if excp.message == \"Chat_not_modified\":\n                pass\n            else:\n                raise\n        log_message = (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"MESSAGE PINNED SUCCESSFULLY\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\"\n        )\n\n        return log_message\n\n\n@run_async\n@bot_admin\n@can_pin\n@user_admin\n@loggable\ndef unpin(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    chat = update.effective_chat\n    user = update.effective_user\n\n    try:\n        bot.unpinChatMessage(chat.id)\n    except BadRequest as excp:\n        if excp.message == \"Chat_not_modified\":\n            pass\n        else:\n            raise\n\n    log_message = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"MESSAGE UNPINNED SUCCESSFULLY\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\"\n    )\n\n    return log_message\n\n\n@run_async\n@bot_admin\n@user_admin\n@connection_status\ndef invite(update: Update, context: CallbackContext):\n    bot = context.bot\n    chat = update.effective_chat\n\n    if chat.username:\n        update.effective_message.reply_text(f\"https://t.me/{chat.username}\")\n    elif chat.type in [chat.SUPERGROUP, chat.CHANNEL]:\n        bot_member = chat.get_member(bot.id)\n        if bot_member.can_invite_users:\n            invitelink = bot.exportChatInviteLink(chat.id)\n            update.effective_message.reply_text(invitelink)\n        else:\n            update.effective_message.reply_text(\n                \"I don't have access to the invite link, try changing my permissions!\"\n            )\n    else:\n        update.effective_message.reply_text(\n            \"I can only give you invite links for supergroups and channels, sorry!\"\n        )\n\n\n@run_async\n@connection_status\ndef adminlist(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    args = context.args\n    bot = context.bot\n\n    if update.effective_message.chat.type == \"private\":\n        send_message(update.effective_message, \"This command only works in Groups.\")\n        return\n\n    chat = update.effective_chat\n    chat_id = update.effective_chat.id\n    chat_name = update.effective_message.chat.title\n\n    try:\n        msg = update.effective_message.reply_text(\n            \"Fetching group admins...\", parse_mode=ParseMode.HTML\n        )\n    except BadRequest:\n        msg = update.effective_message.reply_text(\n            \"Fetching group admins...\", quote=False, parse_mode=ParseMode.HTML\n        )\n\n    administrators = bot.getChatAdministrators(chat_id)\n    text = \"Admins in <b>{}</b>:\".format(html.escape(update.effective_chat.title))\n\n    bot_admin_list = []\n\n    for admin in administrators:\n        user = admin.user\n        status = admin.status\n        custom_title = admin.custom_title\n\n        if user.first_name == \"\":\n            name = \"‚ò† Deleted Account\"\n        else:\n            name = \"{}\".format(\n                mention_html(\n                    user.id, html.escape(user.first_name + \" \" + (user.last_name or \"\"))\n                )\n            )\n\n        if user.is_bot:\n            bot_admin_list.append(name)\n            administrators.remove(admin)\n            continue\n\n        # if user.username:\n        #    name = escape_markdown(\"@\" + user.username)\n        if status == \"creator\":\n            text += \"\\n üëë Creator:\"\n            text += \"\\n<code> ‚Ä¢ </code>{}\\n\".format(name)\n\n            if custom_title:\n                text += f\"<code> ‚îó‚îÅ {html.escape(custom_title)}</code>\\n\"\n\n    text += \"\\nüî± Admins:\"\n\n    custom_admin_list = {}\n    normal_admin_list = []\n\n    for admin in administrators:\n        user = admin.user\n        status = admin.status\n        custom_title = admin.custom_title\n\n        if user.first_name == \"\":\n            name = \"‚ò† Deleted Account\"\n        else:\n            name = \"{}\".format(\n                mention_html(\n                    user.id, html.escape(user.first_name + \" \" + (user.last_name or \"\"))\n                )\n            )\n        # if user.username:\n        #    name = escape_markdown(\"@\" + user.username)\n        if status == \"administrator\":\n            if custom_title:\n                try:\n                    custom_admin_list[custom_title].append(name)\n                except KeyError:\n                    custom_admin_list.update({custom_title: [name]})\n            else:\n                normal_admin_list.append(name)\n\n    for admin in normal_admin_list:\n        text += \"\\n<code> ‚Ä¢ </code>{}\".format(admin)\n\n    for admin_group in custom_admin_list.copy():\n        if len(custom_admin_list[admin_group]) == 1:\n            text += \"\\n<code> ‚Ä¢ </code>{} | <code>{}</code>\".format(\n                custom_admin_list[admin_group][0], html.escape(admin_group)\n            )\n            custom_admin_list.pop(admin_group)\n\n    text += \"\\n\"\n    for admin_group, value in custom_admin_list.items():\n        text += \"\\nüö® <code>{}</code>\".format(admin_group)\n        for admin in value:\n            text += \"\\n<code> ‚Ä¢ </code>{}\".format(admin)\n        text += \"\\n\"\n\n    text += \"\\nü§ñ Bots:\"\n    for each_bot in bot_admin_list:\n        text += \"\\n<code> ‚Ä¢ </code>{}\".format(each_bot)\n\n    try:\n        msg.edit_text(text, parse_mode=ParseMode.HTML)\n    except BadRequest:  # if original message is deleted\n        return\n\n\n__help__ = \"\"\"\n ‚ùç /admins*:* list of admins in the chat\n\n*Admins only:*\n ‚ùç /pin*:* silently pins the message replied to - add `'loud'` or `'notify'` to give notifs to users\n ‚ùç /unpin*:* unpins the currently pinned message\n ‚ùç /invitelink*:* gets invitelink\n ‚ùç /promote*:* promotes the user\n ‚ùç /demote*:* demotes the user\n ‚ùç /title <title here>*:* sets a custom title for an admin that the bot promoted\n ‚ùç /setgtitle <newtitle>*:* Sets new chat title in your group.\n ‚ùç /setgpic*:* As a reply to file or photo to set group profile pic!\n ‚ùç /delgpic*:* Same as above but to remove group profile pic.\n ‚ùç /setsticker*:* As a reply to some sticker to set it as group sticker set!\n ‚ùç /setdescription <description>*:* Sets new chat description in group.\n ‚ùç /admincache*:* force refresh the admins list\n ‚ùç /antispam <on/off/yes/no>*:* Will toggle our antispam tech or return your current settings.\n ‚ùç /del*:* deletes the message you replied to\n ‚ùç /purge*:* deletes all messages between this and the replied to message.\n ‚ùç /purge <integer X>*:* deletes the replied message, and X messages following it if replied to a message.\n ‚ùç /zombies: counts the number of deleted account in your group\n ‚ùç /zombies clean: Remove deleted accounts from group..\n\n*Note:* Night Mode chats get Automatically closed at 12 am(IST)\nand Automatically openned at 6 am(IST) To Prevent Night Spams.\n\n‚ö†Ô∏è `Read from top`\n\"\"\"\n\nADMINLIST_HANDLER = DisableAbleCommandHandler(\"admins\", adminlist)\n\nPIN_HANDLER = CommandHandler(\"pin\", pin, filters=Filters.group)\nUNPIN_HANDLER = CommandHandler(\"unpin\", unpin, filters=Filters.group)\n\nINVITE_HANDLER = DisableAbleCommandHandler(\"invitelink\", invite)\n\nPROMOTE_HANDLER = DisableAbleCommandHandler(\"promote\", promote)\nDEMOTE_HANDLER = DisableAbleCommandHandler(\"demote\", demote)\n\nSET_TITLE_HANDLER = CommandHandler(\"title\", set_title)\nADMIN_REFRESH_HANDLER = CommandHandler(\n    \"admincache\", refresh_admin, filters=Filters.group\n)\n\nCHAT_PIC_HANDLER = CommandHandler(\"setgpic\", setchatpic, filters=Filters.group)\nDEL_CHAT_PIC_HANDLER = CommandHandler(\n    \"delgpic\", rmchatpic, filters=Filters.group)\nSETCHAT_TITLE_HANDLER = CommandHandler(\n    \"setgtitle\", setchat_title, filters=Filters.group\n)\nSETSTICKET_HANDLER = CommandHandler(\n    \"setsticker\", set_sticker, filters=Filters.group)\nSETDESC_HANDLER = CommandHandler(\n    \"setdescription\",\n    set_desc,\n    filters=Filters.group)\n\ndispatcher.add_handler(ADMINLIST_HANDLER)\ndispatcher.add_handler(PIN_HANDLER)\ndispatcher.add_handler(UNPIN_HANDLER)\ndispatcher.add_handler(INVITE_HANDLER)\ndispatcher.add_handler(PROMOTE_HANDLER)\ndispatcher.add_handler(DEMOTE_HANDLER)\ndispatcher.add_handler(SET_TITLE_HANDLER)\ndispatcher.add_handler(ADMIN_REFRESH_HANDLER)\ndispatcher.add_handler(CHAT_PIC_HANDLER)\ndispatcher.add_handler(DEL_CHAT_PIC_HANDLER)\ndispatcher.add_handler(SETCHAT_TITLE_HANDLER)\ndispatcher.add_handler(SETSTICKET_HANDLER)\ndispatcher.add_handler(SETDESC_HANDLER)\n\n__mod_name__ = \"Admin\"\n__command_list__ = [\n    \"adminlist\",\n    \"admins\",\n    \"invitelink\",\n    \"promote\",\n    \"demote\",\n    \"admincache\",\n]\n__handlers__ = [\n    ADMINLIST_HANDLER,\n    PIN_HANDLER,\n    UNPIN_HANDLER,\n    INVITE_HANDLER,\n    PROMOTE_HANDLER,\n    DEMOTE_HANDLER,\n    SET_TITLE_HANDLER,\n    ADMIN_REFRESH_HANDLER,\n]\n","size_bytes":22265},"sitaBot/modules/sql/afk_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, BigInteger, UnicodeText\n\n\nclass AFK(BASE):\n    __tablename__ = \"afk_users\"\n\n    user_id = Column(BigInteger, primary_key=True)\n    is_afk = Column(Boolean)\n    reason = Column(UnicodeText)\n\n    def __init__(self, user_id, reason=\"\", is_afk=True):\n        self.user_id = user_id\n        self.reason = reason\n        self.is_afk = is_afk\n\n    def __repr__(self):\n        return \"afk_status for {}\".format(self.user_id)\n\n\nAFK.__table__.create(checkfirst=True)\nINSERTION_LOCK = threading.RLock()\n\nAFK_USERS = {}\n\n\ndef is_afk(user_id):\n    return user_id in AFK_USERS\n\n\ndef check_afk_status(user_id):\n    try:\n        return SESSION.query(AFK).get(user_id)\n    finally:\n        SESSION.close()\n\n\ndef set_afk(user_id, reason=\"\"):\n    with INSERTION_LOCK:\n        curr = SESSION.query(AFK).get(user_id)\n        if not curr:\n            curr = AFK(user_id, reason, True)\n        else:\n            curr.is_afk = True\n\n        AFK_USERS[user_id] = reason\n\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef rm_afk(user_id):\n    with INSERTION_LOCK:\n        curr = SESSION.query(AFK).get(user_id)\n        if curr:\n            if user_id in AFK_USERS:  # sanity check\n                del AFK_USERS[user_id]\n\n            SESSION.delete(curr)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef toggle_afk(user_id, reason=\"\"):\n    with INSERTION_LOCK:\n        curr = SESSION.query(AFK).get(user_id)\n        if not curr:\n            curr = AFK(user_id, reason, True)\n        elif curr.is_afk:\n            curr.is_afk = False\n        elif not curr.is_afk:\n            curr.is_afk = True\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef __load_afk_users():\n    global AFK_USERS\n    try:\n        all_afk = SESSION.query(AFK).all()\n        AFK_USERS = {user.user_id: user.reason for user in all_afk if user.is_afk}\n    finally:\n        SESSION.close()\n\n\n__load_afk_users()\n","size_bytes":2034},"sitaBot/modules/sql/connection_sql.py":{"content":"import threading\nimport time\nfrom typing import Union\n\nfrom sqlalchemy import Column, String, Boolean, UnicodeText, Integer, BigInteger\n\nfrom sitaBot.modules.sql import SESSION, BASE\n\n\nclass ChatAccessConnectionSettings(BASE):\n    __tablename__ = \"access_connection\"\n    chat_id = Column(String(14), primary_key=True)\n    allow_connect_to_chat = Column(Boolean, default=True)\n\n    def __init__(self, chat_id, allow_connect_to_chat):\n        self.chat_id = str(chat_id)\n        self.allow_connect_to_chat = str(allow_connect_to_chat)\n\n    def __repr__(self):\n        return \"<Chat access settings ({}) is {}>\".format(\n            self.chat_id, self.allow_connect_to_chat\n        )\n\n\nclass Connection(BASE):\n    __tablename__ = \"connection\"\n    user_id = Column(BigInteger, primary_key=True)\n    chat_id = Column(String(14))\n\n    def __init__(self, user_id, chat_id):\n        self.user_id = user_id\n        self.chat_id = str(chat_id)  # Ensure String\n\n\nclass ConnectionHistory(BASE):\n    __tablename__ = \"connection_history\"\n    user_id = Column(BigInteger, primary_key=True)\n    chat_id = Column(String(14), primary_key=True)\n    chat_name = Column(UnicodeText)\n    conn_time = Column(Integer)\n\n    def __init__(self, user_id, chat_id, chat_name, conn_time):\n        self.user_id = user_id\n        self.chat_id = str(chat_id)\n        self.chat_name = str(chat_name)\n        self.conn_time = int(conn_time)\n\n    def __repr__(self):\n        return \"<connection user {} history {}>\".format(self.user_id, self.chat_id)\n\n\nChatAccessConnectionSettings.__table__.create(checkfirst=True)\nConnection.__table__.create(checkfirst=True)\nConnectionHistory.__table__.create(checkfirst=True)\n\nCHAT_ACCESS_LOCK = threading.RLock()\nCONNECTION_INSERTION_LOCK = threading.RLock()\nCONNECTION_HISTORY_LOCK = threading.RLock()\n\nHISTORY_CONNECT = {}\n\n\ndef allow_connect_to_chat(chat_id: Union[str, int]) -> bool:\n    try:\n        chat_setting = SESSION.query(ChatAccessConnectionSettings).get(str(chat_id))\n        if chat_setting:\n            return chat_setting.allow_connect_to_chat\n        return False\n    finally:\n        SESSION.close()\n\n\ndef set_allow_connect_to_chat(chat_id: Union[int, str], setting: bool):\n    with CHAT_ACCESS_LOCK:\n        chat_setting = SESSION.query(ChatAccessConnectionSettings).get(str(chat_id))\n        if not chat_setting:\n            chat_setting = ChatAccessConnectionSettings(chat_id, setting)\n\n        chat_setting.allow_connect_to_chat = setting\n        SESSION.add(chat_setting)\n        SESSION.commit()\n\n\ndef connect(user_id, chat_id):\n    with CONNECTION_INSERTION_LOCK:\n        prev = SESSION.query(Connection).get((int(user_id)))\n        if prev:\n            SESSION.delete(prev)\n        connect_to_chat = Connection(int(user_id), chat_id)\n        SESSION.add(connect_to_chat)\n        SESSION.commit()\n        return True\n\n\ndef get_connected_chat(user_id):\n    try:\n        return SESSION.query(Connection).get((int(user_id)))\n    finally:\n        SESSION.close()\n\n\ndef curr_connection(chat_id):\n    try:\n        return SESSION.query(Connection).get((str(chat_id)))\n    finally:\n        SESSION.close()\n\n\ndef disconnect(user_id):\n    with CONNECTION_INSERTION_LOCK:\n        disconnect = SESSION.query(Connection).get((int(user_id)))\n        if disconnect:\n            SESSION.delete(disconnect)\n            SESSION.commit()\n            return True\n        else:\n            SESSION.close()\n            return False\n\n\ndef add_history_conn(user_id, chat_id, chat_name):\n    global HISTORY_CONNECT\n    with CONNECTION_HISTORY_LOCK:\n        conn_time = int(time.time())\n        if HISTORY_CONNECT.get(int(user_id)):\n            counting = (\n                SESSION.query(ConnectionHistory.user_id)\n                .filter(ConnectionHistory.user_id == str(user_id))\n                .count()\n            )\n            getchat_id = {}\n            for x in HISTORY_CONNECT[int(user_id)]:\n                getchat_id[HISTORY_CONNECT[int(user_id)][x][\"chat_id\"]] = x\n            if chat_id in getchat_id:\n                todeltime = getchat_id[str(chat_id)]\n                delold = SESSION.query(ConnectionHistory).get(\n                    (int(user_id), str(chat_id))\n                )\n                if delold:\n                    SESSION.delete(delold)\n                    HISTORY_CONNECT[int(user_id)].pop(todeltime)\n            elif counting >= 5:\n                todel = list(HISTORY_CONNECT[int(user_id)])\n                todel.reverse()\n                todel = todel[4:]\n                for x in todel:\n                    chat_old = HISTORY_CONNECT[int(user_id)][x][\"chat_id\"]\n                    delold = SESSION.query(ConnectionHistory).get(\n                        (int(user_id), str(chat_old))\n                    )\n                    if delold:\n                        SESSION.delete(delold)\n                        HISTORY_CONNECT[int(user_id)].pop(x)\n        else:\n            HISTORY_CONNECT[int(user_id)] = {}\n        delold = SESSION.query(ConnectionHistory).get((int(user_id), str(chat_id)))\n        if delold:\n            SESSION.delete(delold)\n        history = ConnectionHistory(int(user_id), str(chat_id), chat_name, conn_time)\n        SESSION.add(history)\n        SESSION.commit()\n        HISTORY_CONNECT[int(user_id)][conn_time] = {\n            \"chat_name\": chat_name,\n            \"chat_id\": str(chat_id),\n        }\n\n\ndef get_history_conn(user_id):\n    if not HISTORY_CONNECT.get(int(user_id)):\n        HISTORY_CONNECT[int(user_id)] = {}\n    return HISTORY_CONNECT[int(user_id)]\n\n\ndef clear_history_conn(user_id):\n    global HISTORY_CONNECT\n    todel = list(HISTORY_CONNECT[int(user_id)])\n    for x in todel:\n        chat_old = HISTORY_CONNECT[int(user_id)][x][\"chat_id\"]\n        delold = SESSION.query(ConnectionHistory).get((int(user_id), str(chat_old)))\n        if delold:\n            SESSION.delete(delold)\n            HISTORY_CONNECT[int(user_id)].pop(x)\n    SESSION.commit()\n    return True\n\n\ndef __load_user_history():\n    global HISTORY_CONNECT\n    try:\n        qall = SESSION.query(ConnectionHistory).all()\n        HISTORY_CONNECT = {}\n        for x in qall:\n            check = HISTORY_CONNECT.get(x.user_id)\n            if check is None:\n                HISTORY_CONNECT[x.user_id] = {}\n            HISTORY_CONNECT[x.user_id][x.conn_time] = {\n                \"chat_name\": x.chat_name,\n                \"chat_id\": x.chat_id,\n            }\n    finally:\n        SESSION.close()\n\n\n__load_user_history()\n","size_bytes":6449},"sitaBot/mongo.py":{"content":"import asyncio\nimport sys\n\nfrom motor import motor_asyncio\nfrom sitaBot import MONGO_DB_URI, LOGGER\nfrom pymongo import MongoClient\nfrom pymongo.errors import ServerSelectionTimeoutError\n\n# Extract database name from URI or default to destinymusic\nMONGO_DB = \"destinymusic\"\nif MONGO_DB_URI and \"/\" in MONGO_DB_URI.split(\"?\")[0]:\n    try:\n        db_part = MONGO_DB_URI.split(\"/\")[-1].split(\"?\")[0]\n        if db_part:\n            MONGO_DB = db_part\n    except Exception:\n        pass\n\n# Only initialize if MONGO_DB_URI is provided\nif MONGO_DB_URI:\n    client = MongoClient(MONGO_DB_URI)[MONGO_DB]\n    motor = motor_asyncio.AsyncIOMotorClient(MONGO_DB_URI)\n    db = motor[MONGO_DB]\n    try:\n        asyncio.get_event_loop().run_until_complete(motor.server_info())\n    except ServerSelectionTimeoutError:\n        LOGGER.critical(\"Can't connect to mongodb! Exiting...\")\n        sys.exit(1)\nelse:\n    # Fallback if MongoDB is not configured\n    client = None\n    motor = None\n    db = None","size_bytes":985},"sitaBot/modules/__core.py":{"content":"from sitaBot import telethn as tbot\nfrom sitaBot.events import register\nimport os\nimport asyncio\nimport os\nimport time\nfrom datetime import datetime\nfrom sitaBot import OWNER_ID, DEV_USERS\nfrom sitaBot import TEMP_DOWNLOAD_DIRECTORY as path\nfrom sitaBot import TEMP_DOWNLOAD_DIRECTORY\nfrom datetime import datetime\nwater = './sitaBot/resources/yone.jpg'\nclient = tbot\n\n@register(pattern=r\"^/send ?(.*)\")\nasync def Prof(event):\n    if event.sender_id == OWNER_ID or event.sender_id == DEV_USERS:\n        pass\n    else:\n        return\n    thumb = water\n    message_id = event.message.id\n    input_str = event.pattern_match.group(1)\n    the_plugin_file = \"./sitaBot/modules/{}.py\".format(input_str)\n    if os.path.exists(the_plugin_file):\n     message_id = event.message.id\n     await event.client.send_file(\n             event.chat_id,\n             the_plugin_file,\n             force_document=True,\n             allow_cache=False,\n             thumb=thumb,\n             reply_to=message_id,\n         )\n    else:\n        await event.reply(\"No File Found!\")\n\n\n","size_bytes":1057},"sitaBot/modules/tagall.py":{"content":"# Copyright (C) 2020-2021 by DevsExpo@Github, < https://github.com/DevsExpo >.\n#\n# This file is part of < https://github.com/DevsExpo/FridayUserBot > project,\n# and is released under the \"GNU v3.0 License Agreement\".\n# Please see < https://github.com/DevsExpo/blob/master/LICENSE >\n#\n# All rights reserved.\n\nimport asyncio\nimport random\nfrom pyrogram import filters\nfrom pyrogram.enums import ChatType, ChatMemberStatus\nfrom pyrogram.errors import UserNotParticipant\n\nfrom sitaBot import pbot\nfrom sitaBot.utils.pyro_logger import send_event_log\n\n\n# Runtime state: keep track of chats currently tagging to allow stop\n_active_tag_chats = []  # list of chat_ids\n\nEMOJI = [\n    \"ü¶ãü¶ãü¶ãü¶ãü¶ã\",\n    \"üßöüå∏üßãüç¨ü´ñ\",\n    \"ü•Äüå∑üåπüå∫üíê\",\n    \"üå∏üåøüíÆüå±üåµ\",\n    \"‚ù§Ô∏èüíöüíôüíúüñ§\",\n    \"üíìüíïüíûüíóüíñ\",\n    \"üå∏üíêüå∫üåπü¶ã\",\n    \"üçîü¶™üçõüç≤ü•ó\",\n    \"üçéüçìüçíüçëüå∂Ô∏è\",\n    \"üßãü•§üßãü•õüç∑\",\n    \"üç¨üç≠üßÅüéÇüç°\",\n    \"üç®üßâüç∫‚òïüçª\",\n    \"ü•™ü•ßüç¶üç•üçö\",\n    \"ü´ñ‚òïüçπüç∑ü•õ\",\n    \"‚òïüßÉüç©üç¶üçô\",\n    \"üçÅüåæüíÆüçÇüåø\",\n    \"üå®Ô∏èüå•Ô∏è‚õàÔ∏èüå©Ô∏èüåßÔ∏è\",\n    \"üå∑üèµÔ∏èüå∏üå∫üíê\",\n    \"üíÆüåºüåªüçÄüçÅ\",\n    \"üßüü¶∏ü¶πüßôüë∏\",\n    \"üßÖüç†ü•ïüåΩü•¶\",\n    \"üê∑üêπüê≠üê®üêª‚Äç‚ùÑÔ∏è\",\n    \"ü¶ãüêáüêÄüêàüêà‚Äç‚¨õ\",\n    \"üåºüå≥üå≤üå¥üåµ\",\n    \"ü•©üçãüçêüçàüçá\",\n    \"üç¥üçΩÔ∏èüî™üç∂ü•É\",\n    \"üïåüè∞üè©‚õ©Ô∏èüè©\",\n    \"üéâüéäüéàüéÇüéÄ\",\n    \"ü™¥üåµüå¥üå≥üå≤\",\n    \"üéÑüéãüéçüéëüéé\",\n    \"ü¶Öü¶úüïäÔ∏èü¶§ü¶¢\",\n    \"ü¶§ü¶©ü¶öü¶Éü¶Ü\",\n    \"üê¨ü¶≠ü¶àüêãüê≥\",\n    \"üêîüêüüê†üê°ü¶ê\",\n    \"ü¶©ü¶Äü¶ëüêôü¶™\",\n    \"üê¶ü¶Çüï∑Ô∏èüï∏Ô∏èüêö\",\n    \"ü•™üç∞ü•ßüç®üç®\",\n    \"ü•¨üçâüßÅüßá\",\n]\n\nTAG_LINES = [\n    \" **  ú·¥á è  ô·¥Ä ô è ·¥ã·¥Ä ú·¥Ä  ú·¥è ü§ó** \",\n    \" ** ·¥è è·¥á s·¥è …¢ è·¥á ·¥ã è·¥Ä ·¥è…¥ ü…™…¥·¥á ·¥Ä·¥Ä·¥è üòä** \",\n    \" ** ·¥†·¥Ñ ·¥Ñ ú·¥Ä ü·¥è  ô·¥Ä·¥õ·¥á…¥ ·¥ã·¥Ä Ä·¥õ·¥á  ú·¥Ä…™…¥ ·¥ã·¥ú·¥Ñ ú ·¥ã·¥ú·¥Ñ ú üòÉ** \",\n    \" ** ·¥ã ú·¥Ä…¥·¥Ä ·¥ã ú·¥Ä  ü…™ è·¥á ·¥ä…™..?? ü•≤** \",\n    \" ** …¢ ú·¥Ä Ä ·¥ç·¥á s·¥Ä ô ·¥ã·¥Ä…™s·¥á  ú·¥Ä…™…¥ ·¥ä…™ ü•∫** \",\n    \" ** ·¥ò·¥õ·¥Ä  ú·¥Ä…™  ô·¥è ú·¥è·¥õ ·¥ç…™ss ·¥ã·¥Ä Ä  Ä ú…™ ·¥õ ú…™ ·¥Ä·¥Ä·¥ò·¥ã·¥è ü§≠** \",\n    \" ** ·¥è è·¥á  ú·¥Ä ü ·¥Ñ ú·¥Ä ü ·¥ã·¥ás·¥Ä  ú·¥Ä…™..?? ü§®** \",\n    \" ** ·¥ç·¥á Ä…™  ô ú…™ s·¥á·¥õ·¥õ…™…¥…¢ ·¥ã·¥Ä Ä ô·¥Ä ·¥Ö·¥è…¢·¥á..?? üôÇ** \",\n    \" ** ·¥Ä·¥Ä·¥ò·¥ã·¥Ä …¥·¥Ä·¥ç·¥á ·¥ã è·¥Ä  ú·¥Ä…™..?? ü•≤** \",\n    \" ** …¥·¥Äs·¥õ·¥Ä  ú·¥ú·¥Ä ·¥Ä·¥Ä·¥ò·¥ã·¥Ä..?? üòã** \",\n    \" ** ·¥ç·¥á Ä·¥á ·¥ã·¥è ·¥Ä·¥ò…¥·¥á …¢ Ä·¥è·¥ú·¥ò ·¥ç·¥á ·¥ã…™·¥Ö…¥·¥Ä·¥ò ·¥ã Ä  ü·¥è üòç** \",\n    \" ** ·¥Ä·¥Ä·¥ò·¥ã…™ ·¥ò·¥Ä Ä·¥õ…¥·¥á Ä ·¥Ä·¥Ä·¥ò·¥ã·¥è ·¥Ö ú·¥ú…¥·¥Ö  Ä ú·¥á  ú·¥Ä…™…¥ ·¥ä ü·¥Ö…™ ·¥è…¥ ü…™…¥·¥á ·¥Ä è…™·¥Ä·¥á üòÖ** \",\n    \" ** ·¥ç·¥á Ä·¥á s·¥á ·¥Ö·¥ès·¥õ…™ ·¥ã Ä·¥è…¢·¥á..?? ü§î** \",\n    \" ** ·¥á·¥Ö ú·¥Ä Ä ·¥Ö·¥á·¥ã ú·¥è ·¥ã è·¥Ä  ú·¥Ä…™ @about_brahix ...üòò** \",\n    \" **  ô·¥Ä ô·¥ú  è·¥á ·¥Ö·¥á·¥ã ú·¥è ·¥Ä ü·¥ò ú·¥Ä ·¥ã·¥Ä ·¥Ä·¥Ö·¥Ö·¥Ä @Oye_Careless... üòé** \",\n    \" ** s·¥è…¥·¥á ·¥Ñ ú·¥Ä ü …¢ è·¥á ·¥ã è·¥Ä üôÑ** \",\n    \" ** ·¥á·¥ã s·¥è…¥…¢ ·¥ò ü·¥Ä è ·¥ã Ä·¥è …¥·¥Ä ·¥ò üss üòï** \",\n    \" ** ·¥Ä·¥Ä·¥ò ·¥ã·¥Ä ú·¥Ä s·¥á  ú·¥è..?? üôÉ** \",\n    \" **  ú·¥á ü ü·¥è ·¥ä…™ …¥·¥Ä·¥ç·¥Äs·¥õ·¥á üòõ** \",\n    \" **  ú·¥á ü ü·¥è  ô·¥Ä ô è ·¥ã·¥ã Ä ú..? ü§î** \",\n    \" ** ·¥Ö·¥è  è·¥è·¥ú ·¥ã…¥·¥è·¥° ·¥° ú·¥è …™s ·¥ç è ·¥è·¥°…¥·¥á Ä.? ‚ò∫Ô∏è** \",\n    \" ** ·¥Ñ ú ü·¥è ·¥ã·¥ú·¥Ñ ú …¢·¥Ä·¥ç·¥á ·¥ã ú·¥á ü·¥õ·¥á  ú·¥Ä…™…¥.ü§ó** \",\n    \" ** ·¥Ä·¥ú Ä  ô·¥Ä·¥õ·¥Ä·¥è ·¥ã·¥Ä…™s·¥á  ú·¥è  ô·¥Ä ô è üòá** \",\n    \" ** ·¥õ·¥ú·¥ç ú·¥Ä Ä…™ ·¥ç·¥ú·¥ç·¥ç è ·¥ã è·¥Ä ·¥ã·¥Ä Ä  Ä·¥Ä ú…™  ú·¥Ä…™ ü§≠** \",\n    \" ** ·¥ç·¥á Ä·¥á s·¥á  ô·¥Ä·¥õ …¥·¥è…™ ·¥ã Ä·¥è…¢·¥á ü•∫** \",\n    \" ** ·¥è è·¥á ·¥ò·¥Ä…¢·¥Ä ü ·¥è…¥ ü…™…¥·¥á ·¥Ä·¥Ä ·¥ä·¥Ä üò∂** \",\n    \" ** ·¥Ä·¥Ä·¥ä  ú·¥è ü…™·¥Ö·¥Ä è  ú·¥Ä…™ ·¥ã è·¥Ä s·¥Ñ ú·¥è·¥è ü ·¥ç·¥á..?? ü§î** \",\n    \" ** ·¥è è·¥á …¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üòú** \",\n    \" ** s·¥ú…¥·¥è ·¥á·¥ã ·¥ã·¥Ä·¥ç  ú·¥Ä…™ ·¥õ·¥ú·¥çs·¥á üôÇ** \",\n    \" ** ·¥ã·¥è…™ s·¥è…¥…¢ ·¥ò ü·¥Ä è ·¥ã Ä·¥è …¥·¥Ä üò™** \",\n    \" ** …¥…™·¥Ñ·¥á ·¥õ·¥è ·¥ç·¥á·¥á·¥õ ·¥ú ú ‚ò∫** \",\n    \" ** ·¥ç·¥á Ä·¥Ä  ô·¥Ä ô·¥ú …¥·¥á ·¥õ ú·¥Ä…¥·¥Ä ·¥ã ú·¥Ä è·¥Ä ·¥ã è·¥Ä..? üôä** \",\n    \" ** s·¥õ·¥ú·¥Ö è ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á  ú·¥ú·¥Ä?? üò∫** \",\n    \" **  ô·¥è ü·¥è …¥·¥Ä ·¥ã·¥ú·¥Ñ ú  è Ä Ä ü•≤** \",\n    \" ** s·¥è…¥·¥Ä ü…™ ·¥ã·¥è…¥  ú·¥Ä…™...?? üòÖ** \",\n    \" ** ·¥õ·¥ú·¥ç ú·¥Ä Ä…™ ·¥á·¥ã ·¥ò…™·¥Ñ ·¥ç…™ ü·¥á…¢…™..? üòÖ** \",\n    \" ** ·¥ç·¥ú·¥ç·¥ç è ·¥Ä·¥Ä …¢ è…™ ·¥ã è·¥Ä üòÜ** \",\n    \" ** ·¥è Ä  ô·¥Ä·¥õ·¥Ä·¥è  ô ú·¥Ä ô ú…™ ·¥ã·¥Ä…™s…™  ú·¥Ä…™ üòâ** \",\n    \" ** …™  ü·¥è·¥†·¥á  è·¥è·¥ú üíö** \",\n    \" ** ·¥Ö·¥è  è·¥è·¥ú  ü·¥è·¥†·¥á ·¥ç·¥á..? üëÄ** \",\n    \" **  Ä·¥Ä·¥ã ú…™ ·¥ã·¥Ä ô  ô·¥Ä…¥·¥Ö  Ä·¥Ä ú…™  ú·¥è..?? üôâ** \",\n    \" ** ·¥á·¥ã s·¥è…¥…¢ s·¥ú…¥·¥Ä·¥ú..? üòπ** \",\n    \" ** ·¥è…¥ ü…™…¥·¥á ·¥Ä·¥Ä ·¥ä·¥Ä  Ä·¥á s·¥è…¥…¢ s·¥ú…¥·¥Ä  Ä·¥Ä ú…™  ú·¥ú üòª** \",\n    \" ** …™…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç ·¥Ñ ú·¥Ä ü·¥Ä·¥õ·¥á  ú·¥è..?? üôÉ** \",\n    \" ** ·¥° ú·¥Ä·¥õs·¥Ä·¥ò·¥ò …¥·¥ú·¥ç ô·¥á Ä ·¥Ö·¥è…¢·¥á ·¥Ä·¥ò…¥·¥Ä ·¥õ·¥ú·¥ç..? üòï** \",\n    \" ** ·¥õ·¥ú·¥ç ú·¥á ·¥ã·¥è…¥ s·¥Ä ·¥ç·¥ús…™·¥Ñ s·¥ú…¥…¥·¥Ä ·¥ò·¥Äs·¥Ä…¥·¥Ö  ú·¥Ä…™..? üôÉ** \",\n    \" ** s·¥Ä Ä·¥Ä ·¥ã·¥Ä·¥ç ·¥ã ú·¥Ä·¥õ·¥Ä·¥ç  ú·¥è …¢ è·¥Ä ·¥Ä·¥Ä·¥ò·¥ã·¥Ä..? üôÉ** \",\n    \" ** ·¥ã·¥Ä ú·¥Ä s·¥á  ú·¥è ·¥Ä·¥Ä·¥ò üòä** \",\n    \" ** s·¥ú…¥·¥è …¥·¥Ä üßê** \",\n    \" ** ·¥ç·¥á Ä·¥Ä ·¥á·¥ã ·¥ã·¥Ä·¥Ä·¥ç ·¥ã·¥Ä Ä ·¥Ö·¥è…¢·¥á..? ‚ô•Ô∏è** \",\n    \" **  ô è ·¥õ·¥Ä·¥õ·¥Ä ·¥ç·¥Ä·¥õ  ô·¥Ä·¥Ä·¥õ ·¥ã·¥Ä Ä…¥·¥Ä ·¥Ä·¥Ä·¥ä ·¥ã·¥á  ô·¥Ä·¥Ö üò†** \",\n    \" ** ·¥ç·¥è·¥ç ·¥Ö·¥Ä·¥Ö ·¥ã·¥Ä…™s·¥á  ú·¥Ä…™…¥..? ‚ù§** \",\n    \" ** ·¥ã è·¥Ä  ú·¥ú·¥Ä..? ü§î** \",\n    \" **  ô·¥è ú·¥è·¥õ  è·¥Ä·¥Ä·¥Ö ·¥Ä·¥Ä  Ä ú…™  ú·¥Ä…™ üòí** \",\n    \" **  ô ú·¥ú ü …¢ è·¥á ·¥ç·¥ú·¥ä ú·¥á üòè** \",\n    \" ** ·¥ä·¥ú·¥õ ú …¥ ú…™  ô·¥è ü…¥·¥Ä ·¥Ñ ú·¥Ä ú…™ è·¥á ü§ê** \",\n    \" ** ·¥ã ú·¥Ä  ü·¥è  ô ú·¥Ä·¥° ·¥ç·¥Ä·¥õ ·¥ã Ä·¥è  ô·¥Ä·¥Ä·¥õ üòí** \",\n    \" ** ·¥ã è·¥Ä  ú·¥ú·¥Ä üòÆ** \",\n    \" **  ú…™…™  ú·¥è…™  ú·¥á ü ü·¥è üëÄ** \",\n    \" ** ·¥Ä·¥Ä·¥ò·¥ã·¥á ·¥ä·¥Ä…™s·¥Ä ·¥Ö·¥ès·¥õ  ú·¥è s·¥Ä·¥õ ú ·¥ç·¥á “ì…™ Ä …¢·¥ú·¥ç ·¥ã…™s  ô·¥Ä·¥Ä·¥õ ·¥ã·¥Ä üôà** \",\n    \" ** ·¥Ä·¥Ä·¥ä ·¥ç·¥á s·¥Ä·¥Ö  ú·¥è·¥è…¥ ‚òπÔ∏è** \",\n    \" ** ·¥ç·¥ús·¥ä ús·¥á  ô ú…™  ô·¥Ä·¥Ä·¥õ ·¥ã·¥Ä Ä  ü·¥è …¥·¥Ä ü•∫** \",\n    \" ** ·¥ã è·¥Ä ·¥ã·¥Ä Ä  Ä·¥Ä ú·¥á  ú·¥è üëÄ** \",\n    \" ** ·¥ã è·¥Ä  ú·¥Ä ü ·¥Ñ ú·¥Ä ü  ú·¥Ä…™ üôÇ** \",\n    \" ** ·¥ã·¥Ä ú·¥Ä s·¥á  ú·¥è ·¥Ä·¥Ä·¥ò..?ü§î** \",\n    \" ** ·¥Ñ ú·¥Ä·¥õ·¥õ…™…¥…¢ ·¥ã·¥Ä Ä  ü·¥è …¥·¥Ä..ü•∫** \",\n    \" ** ·¥ç·¥á ·¥ç·¥Äs·¥è·¥è·¥ç  ú·¥ú …¥·¥Ä ü•∫** \",\n    \" ** ·¥ã·¥Ä ü ·¥ç·¥Ä·¥ä·¥Ä ·¥Ä è·¥Ä ·¥õ ú·¥Ä …¥·¥Ä üòÖ** \",\n    \" ** …¢ Ä·¥è·¥ú·¥ò ·¥ç·¥á  ô·¥Ä·¥Ä·¥õ ·¥ã è·¥ú …¥·¥Ä ú…™ ·¥ã·¥Ä Ä·¥õ·¥á  ú·¥è üòï** \",\n    \" ** ·¥Ä·¥Ä·¥ò  Ä·¥á ü·¥Ä·¥õ…™·¥è…¥s ú…™·¥ò ·¥ç·¥á  ú·¥è..? üëÄ** \",\n    \" ** ·¥ã…™·¥õ…¥·¥Ä ·¥Ñ ú·¥ú·¥ò  Ä·¥Ä ú·¥õ·¥á  ú·¥è  è Ä Ä üòº** \",\n    \" ** ·¥Ä·¥Ä·¥ò·¥ã·¥è …¢·¥Ä…¥·¥Ä …¢·¥Ä…¥·¥á ·¥Ä·¥Ä·¥õ·¥Ä  ú·¥Ä…™..? üò∏** \",\n    \" ** …¢ ú·¥ú·¥ç…¥·¥á ·¥Ñ ú·¥Ä ü·¥è…¢·¥á..?? üôà** \",\n    \" ** ·¥ã ú·¥ús  Ä·¥Ä ú·¥Ä ·¥ã·¥Ä Ä·¥è ü§û** \",\n    \" **  ú·¥Ä·¥ç ·¥Ö·¥ès·¥õ  ô·¥Ä…¥ s·¥Ä·¥ã·¥õ·¥á  ú·¥Ä…™...? ü•∞** \",\n    \" ** ·¥ã·¥ú·¥Ñ ú  ô·¥è ü ·¥ã è·¥ú …¥ ú…™  Ä·¥Ä ú·¥á  ú·¥è.. ü•∫** \",\n    \" ** ·¥ã·¥ú·¥Ñ ú ·¥ç·¥á·¥ç ô·¥á Äs ·¥Ä·¥Ö·¥Ö ·¥ã·¥Ä Ä ·¥Ö·¥è ü•≤** \",\n    \" ** s…™…¥…¢ ü·¥á  ú·¥è  è·¥Ä ·¥ç…™…¥…¢ ü·¥á üòâ** \",\n    \" ** ·¥Ä·¥Ä·¥è ·¥ò·¥Ä Ä·¥õ è ·¥ã·¥Ä Ä·¥õ·¥á  ú·¥Ä…™…¥ ü•≥** \",\n    \" **  ô…™·¥è ·¥ç·¥á  ü…™…¥·¥ã  ú·¥Ä…™ ·¥ä·¥è…™…¥ ·¥ã·¥Ä Ä  ü·¥è üßê** \",\n    \" ** ·¥ç·¥ú·¥ä ú·¥á  ô ú·¥ú ü …¢ è·¥á ·¥ã è·¥Ä ü•∫** \",\n    \" **  è·¥Ä ú·¥Ä ·¥Ä·¥Ä ·¥ä·¥Ä·¥è @ALPHA_SAYS ·¥ç·¥Äs·¥õ…™ ·¥ã·¥Ä Ä·¥á…¥…¢·¥á ü§≠** \",\n    \" ** ·¥õ Ä·¥ú·¥õ ú ·¥Ä…¥·¥Ö ·¥Ö·¥Ä Ä·¥á ·¥ã ú·¥á ü·¥è…¢·¥á..? üòä** \",\n    \" ** ·¥Ä·¥Ä·¥ä ·¥ç·¥ú·¥ç·¥ç è …¥·¥á ·¥Ö·¥Ä·¥õ·¥Ä  è Ä Ä ü•∫** \",\n    \" ** ·¥ä·¥è…™…¥ ·¥ã·¥Ä Ä  ü·¥è @brahix_support ü§ó** \",\n    \" ** ·¥á·¥ã ·¥Ö…™ ü  ú·¥Ä…™ ·¥á·¥ã ·¥Ö…™ ü  ú…™ ·¥õ·¥è  ú·¥Ä…™ üòó** \",\n    \" ** ·¥õ·¥ú·¥ç ú·¥Ä Ä·¥á ·¥Ö·¥ès·¥õ ·¥ã·¥Ä ú·¥Ä …¢ è·¥á ü•∫** \",\n    \" ** ·¥ç è ·¥Ñ·¥ú·¥õ·¥á ·¥è·¥°…¥·¥á Ä @PurviBots ü•∞** \",\n    \" ** ·¥ã·¥Ä ú·¥Ä ·¥ã ú·¥è è·¥á  ú·¥è ·¥ä·¥Ä·¥Ä…¥ üòú** \",\n    \" ** …¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ ·¥ä…™  ô ú·¥ú·¥õ  Ä·¥Ä·¥õ  ú·¥è …¢ è…™ ü•∞** \",\n]\n\n\nasync def _is_admin(client, chat_id: int, user_id: int) -> bool:\n    try:\n        member = await client.get_chat_member(chat_id, user_id)\n    except UserNotParticipant:\n        return False\n    return member.status in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER)\n\n\n@pbot.on_message(filters.command([\"rtag\", \"tagall\"], prefixes=[\"/\", \"@\", \"#\"]))\nasync def rtag_command(client, message):\n    chat = message.chat\n    if chat.type == ChatType.PRIVATE:\n        return await message.reply(\"‚¨§ ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥è…¥ ü è “ì·¥è Ä …¢ Ä·¥è·¥ú·¥òs.\")\n\n    if not await _is_admin(client, chat.id, message.from_user.id):\n        return await message.reply(\"‚¨§  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥, ·¥è…¥ ü è ·¥Ä·¥Ö·¥ç…™…¥s ·¥Ñ·¥Ä…¥ ·¥õ·¥Ä…¢.\")\n\n    if chat.id in _active_tag_chats:\n        return await message.reply(\"‚¨§ ·¥Ä ·¥õ·¥Ä…¢ s·¥áss…™·¥è…¥ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è  Ä·¥ú…¥…¥…™…¥…¢.\")\n\n    # Determine mode: reply-based or simple text line\n    mode_reply = bool(message.reply_to_message)\n    source_msg = message.reply_to_message if mode_reply else None\n\n    _active_tag_chats.append(chat.id)\n    await send_event_log(\n        f\"<b>‚ùñ Tag Session Started</b>\\n\\n\"\n        f\"<b>‚Ä¢ Chat:</b> {chat.title or chat.id} (<code>{chat.id}</code>)\\n\"\n        f\"<b>‚Ä¢ By:</b> {message.from_user.mention} (<code>{message.from_user.id}</code>)\\n\"\n        f\"<b>‚Ä¢ Mode:</b> {'reply' if mode_reply else 'text'}\"\n    )\n\n    try:\n        async for member in client.get_chat_members(chat.id):\n            if chat.id not in _active_tag_chats:\n                break\n            if member.user.is_bot:\n                continue\n\n            if mode_reply:\n                # Reply mode: reply to source message with emoji mention\n                await source_msg.reply(f\"[{random.choice(EMOJI)}](tg://user?id={member.user.id})\")\n            else:\n                # Text mode: send message with mention and tag line\n                mention = f\"[{member.user.first_name}](tg://user?id={member.user.id}) \"\n                text = f\"{mention} {random.choice(TAG_LINES)}\"\n                await client.send_message(chat.id, text)\n            \n            await asyncio.sleep(4)\n    finally:\n        if chat.id in _active_tag_chats:\n            _active_tag_chats.remove(chat.id)\n        await send_event_log(\n            f\"<b>‚ùñ Tag Session Ended</b>\\n\\n\"\n            f\"<b>‚Ä¢ Chat:</b> {chat.title or chat.id} (<code>{chat.id}</code>)\\n\"\n            f\"<b>‚Ä¢ By:</b> {message.from_user.mention} (<code>{message.from_user.id}</code>)\"\n        )\n\n\n@pbot.on_message(filters.command([\"vctag\"], prefixes=[\"/\", \"@\", \"#\"]))\nasync def vctag_command(client, message):\n    chat = message.chat\n    if chat.type == ChatType.PRIVATE:\n        return await message.reply(\"‚¨§ ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥è…¥ ü è “ì·¥è Ä …¢ Ä·¥è·¥ú·¥òs.\")\n    if not await _is_admin(client, chat.id, message.from_user.id):\n        return await message.reply(\"‚¨§  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥, ·¥è…¥ ü è ·¥Ä·¥Ö·¥ç…™…¥s ·¥Ñ·¥Ä…¥ ·¥õ·¥Ä…¢.\")\n    if chat.id in _active_tag_chats:\n        return await message.reply(\"‚¨§ ·¥Ä ·¥õ·¥Ä…¢ s·¥áss…™·¥è…¥ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è  Ä·¥ú…¥…¥…™…¥…¢.\")\n\n    _active_tag_chats.append(chat.id)\n    \n    try:\n        async for member in client.get_chat_members(chat.id):\n            if chat.id not in _active_tag_chats:\n                break\n            if member.user.is_bot:\n                continue\n            \n            mention = f\"[{member.user.first_name}](tg://user?id={member.user.id}) \"\n            text = f\"{mention} {random.choice(EMOJI)}\"\n            await client.send_message(chat.id, text)\n            await asyncio.sleep(4)\n    finally:\n        if chat.id in _active_tag_chats:\n            _active_tag_chats.remove(chat.id)\n\n\n@pbot.on_message(filters.command([\"rstop\", \"tagstop\", \"vcstop\", \"tagoff\"]))\nasync def stop_tagging(client, message):\n    chat = message.chat\n    if chat.id not in _active_tag_chats:\n        return await message.reply(\"‚¨§ …¥·¥è ·¥Ä·¥Ñ·¥õ…™·¥†·¥á ·¥õ·¥Ä…¢ s·¥áss…™·¥è…¥.\")\n    if not await _is_admin(client, chat.id, message.from_user.id):\n        return await message.reply(\"‚¨§ ·¥è…¥ ü è ·¥Ä·¥Ö·¥ç…™…¥s ·¥Ñ·¥Ä…¥ s·¥õ·¥è·¥ò ·¥õ·¥Ä…¢…¢…™…¥…¢.\")\n    try:\n        _active_tag_chats.remove(chat.id)\n    except ValueError:\n        pass\n    await send_event_log(\n        f\"<b>‚ùñ Tag Session Stopped</b>\\n\\n\"\n        f\"<b>‚Ä¢ Chat:</b> {chat.title or chat.id} (<code>{chat.id}</code>)\\n\"\n        f\"<b>‚Ä¢ By:</b> {message.from_user.mention} (<code>{message.from_user.id}</code>)\"\n    )\n    return await message.reply(\"‚ô•Ô∏é ·¥õ·¥Ä…¢ s·¥õ·¥è·¥ò·¥ò·¥á·¥Ö.\")\n\n\n__mod_name__ = \"Tagall\"\n__help__ = \"\"\"\n- /tagall or /rtag: Mention all members (reply to a message to tag with emojis)\n- /vctag: Mention all with VC-style lines\n- /rstop: Stop an ongoing tag session (aliases: /tagstop, /vcstop, /tagoff)\n\"\"\"","size_bytes":13004},"sitaBot/modules/__zip.py":{"content":"import os\nimport time\nimport zipfile\n\nfrom telethon import types\nfrom telethon.tl import functions\n\nfrom sitaBot import TEMP_DOWNLOAD_DIRECTORY\nfrom sitaBot import telethn as client\nfrom sitaBot.events import register\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n\n        return isinstance(\n            (\n                await client(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerChat):\n\n        ui = await client.get_peer_id(user)\n        ps = (\n            await client(functions.messages.GetFullChatRequest(chat.chat_id))\n        ).full_chat.participants.participants\n        return isinstance(\n            next((p for p in ps if p.user_id == ui), None),\n            (types.ChatParticipantAdmin, types.ChatParticipantCreator),\n        )\n    return None\n\n\n@register(pattern=\"^/zip\")\nasync def _(event):\n    if event.fwd_from:\n        return\n\n    if not event.is_reply:\n        await event.reply(\"Reply to a file to compress it.\")\n        return\n    if event.is_group:\n        if not (await is_register_admin(event.input_chat, event.message.sender_id)):\n            await event.reply(\n                \"Hey, You are not admin. You can't use this command, But you can use in my pm üôÇ\"\n            )\n            return\n\n    mone = await event.reply(\"‚è≥Ô∏è Please wait...\")\n    if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):\n        os.makedirs(TEMP_DOWNLOAD_DIRECTORY)\n    if event.reply_to_msg_id:\n        reply_message = await event.get_reply_message()\n        try:\n            time.time()\n            downloaded_file_name = await event.client.download_media(\n                reply_message, TEMP_DOWNLOAD_DIRECTORY\n            )\n            directory_name = downloaded_file_name\n        except Exception as e:  # pylint:disable=C0103,W0703\n            await mone.reply(str(e))\n    zipfile.ZipFile(directory_name + \".zip\", \"w\", zipfile.ZIP_DEFLATED).write(\n        directory_name\n    )\n    await event.client.send_file(\n        event.chat_id,\n        directory_name + \".zip\",\n        force_document=True,\n        allow_cache=False,\n        reply_to=event.message.id,\n    )\n\n\ndef zipdir(path, ziph):\n    # ziph is zipfile handle\n    for root, dirs, files in os.walk(path):\n        for file in files:\n            ziph.write(os.path.join(root, file))\n            os.remove(os.path.join(root, file))\n\n\nfrom datetime import datetime\n\nfrom hachoir.metadata import extractMetadata\nfrom hachoir.parser import createParser\nfrom telethon.tl.types import DocumentAttributeVideo\n\nextracted = TEMP_DOWNLOAD_DIRECTORY + \"extracted/\"\nthumb_image_path = TEMP_DOWNLOAD_DIRECTORY + \"/thumb_image.jpg\"\nif not os.path.isdir(extracted):\n    os.makedirs(extracted)\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n\n        return isinstance(\n            (\n                await client(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerChat):\n\n        ui = await client.get_peer_id(user)\n        ps = (\n            await client(functions.messages.GetFullChatRequest(chat.chat_id))\n        ).full_chat.participants.participants\n        return isinstance(\n            next((p for p in ps if p.user_id == ui), None),\n            (types.ChatParticipantAdmin, types.ChatParticipantCreator),\n        )\n    return None\n\n\n@register(pattern=\"^/unzip\")\nasync def _(event):\n    if event.fwd_from:\n        return\n\n    if not event.is_reply:\n        await event.reply(\"Reply to a zip file.\")\n        return\n    if event.is_group:\n        if not (await is_register_admin(event.input_chat, event.message.sender_id)):\n            await event.reply(\n                \"Hey, You are not admin. You can't use this command, But you can use in my pm üôÇ\"\n            )\n            return\n\n    mone = await event.reply(\"Processing...\")\n    if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):\n        os.makedirs(TEMP_DOWNLOAD_DIRECTORY)\n    if event.reply_to_msg_id:\n        start = datetime.now()\n        reply_message = await event.get_reply_message()\n        try:\n            time.time()\n            downloaded_file_name = await client.download_media(\n                reply_message, TEMP_DOWNLOAD_DIRECTORY\n            )\n        except Exception as e:\n            await mone.reply(str(e))\n        else:\n            end = datetime.now()\n            (end - start).seconds\n\n        with zipfile.ZipFile(downloaded_file_name, \"r\") as zip_ref:\n            zip_ref.extractall(extracted)\n        filename = sorted(get_lst_of_files(extracted, []))\n        await event.reply(\"Unzipping now üòå\")\n        for single_file in filename:\n            if os.path.exists(single_file):\n                caption_rts = os.path.basename(single_file)\n                force_document = True\n                supports_streaming = False\n                document_attributes = []\n                if single_file.endswith((\".mp4\", \".mp3\", \".flac\", \".webm\")):\n                    metadata = extractMetadata(createParser(single_file))\n                    duration = 0\n                    width = 0\n                    height = 0\n                    if metadata.has(\"duration\"):\n                        duration = metadata.get(\"duration\").seconds\n                    if os.path.exists(thumb_image_path):\n                        metadata = extractMetadata(createParser(thumb_image_path))\n                        if metadata.has(\"width\"):\n                            width = metadata.get(\"width\")\n                        if metadata.has(\"height\"):\n                            height = metadata.get(\"height\")\n                    document_attributes = [\n                        DocumentAttributeVideo(\n                            duration=duration,\n                            w=width,\n                            h=height,\n                            round_message=False,\n                            supports_streaming=True,\n                        )\n                    ]\n                try:\n                    await client.send_file(\n                        event.chat_id,\n                        single_file,\n                        force_document=force_document,\n                        supports_streaming=supports_streaming,\n                        allow_cache=False,\n                        reply_to=event.message.id,\n                        attributes=document_attributes,\n                    )\n                except Exception as e:\n                    await client.send_message(\n                        event.chat_id,\n                        \"{} caused `{}`\".format(caption_rts, str(e)),\n                        reply_to=event.message.id,\n                    )\n                    continue\n                os.remove(single_file)\n        os.remove(downloaded_file_name)\n\n\ndef get_lst_of_files(input_directory, output_lst):\n    filesinfolder = os.listdir(input_directory)\n    for file_name in filesinfolder:\n        current_file_name = os.path.join(input_directory, file_name)\n        if os.path.isdir(current_file_name):\n            return get_lst_of_files(current_file_name, output_lst)\n        output_lst.append(current_file_name)\n    return output_lst\n","size_bytes":7436},"sitaBot/modules/muting.py":{"content":"import html\nfrom typing import Optional\n\nfrom sitaBot import LOGGER, TIGERS, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    can_restrict,\n    connection_status,\n    is_user_admin,\n    user_admin,\n)\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_user,\n    extract_user_and_text,\n)\nfrom sitaBot.modules.helper_funcs.string_handling import extract_time\nfrom sitaBot.modules.log_channel import loggable\nfrom telegram import Bot, Chat, ChatPermissions, ParseMode, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\nfrom telegram.utils.helpers import mention_html\n\n\ndef check_user(user_id: int, bot: Bot, chat: Chat) -> Optional[str]:\n    if not user_id:\n        reply = \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        return reply\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            reply = \"I can't seem to find this user\"\n            return reply\n        else:\n            raise\n\n    if user_id == bot.id:\n        reply = \"I'm not gonna MUTE myself, How high are you?\"\n        return reply\n\n    if is_user_admin(chat, user_id, member) or user_id in TIGERS:\n        reply = \"Can't. Find someone else to mute but not this one.\"\n        return reply\n\n    return None\n\n\n@run_async\n@connection_status\n@bot_admin\n@user_admin\n@loggable\ndef mute(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    args = context.args\n\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n\n    user_id, reason = extract_user_and_text(message, args)\n    reply = check_user(user_id, bot, chat)\n\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    member = chat.get_member(user_id)\n\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#MUTE\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, member.user.first_name)}\"\n    )\n\n    if reason:\n        log += f\"\\n<b>Reason:</b> {reason}\"\n\n    if member.can_send_messages is None or member.can_send_messages:\n        chat_permissions = ChatPermissions(can_send_messages=False)\n        bot.restrict_chat_member(chat.id, user_id, chat_permissions)\n        bot.sendMessage(\n            chat.id,\n            f\"Muted <b>{html.escape(member.user.first_name)}</b> with no expiration date!\",\n            parse_mode=ParseMode.HTML,\n        )\n        return log\n\n    else:\n        message.reply_text(\"This user is already muted!\")\n\n    return \"\"\n\n\n@run_async\n@connection_status\n@bot_admin\n@user_admin\n@loggable\ndef unmute(update: Update, context: CallbackContext) -> str:\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n\n    user_id = extract_user(message, args)\n    if not user_id:\n        message.reply_text(\n            \"You'll need to either give me a username to unmute, or reply to someone to be unmuted.\"\n        )\n        return \"\"\n\n    member = chat.get_member(int(user_id))\n\n    if member.status != \"kicked\" and member.status != \"left\":\n        if (\n            member.can_send_messages\n            and member.can_send_media_messages\n            and member.can_send_other_messages\n            and member.can_add_web_page_previews\n        ):\n            message.reply_text(\"This user already has the right to speak.\")\n        else:\n            chat_permissions = ChatPermissions(\n                can_send_messages=True,\n                can_invite_users=True,\n                can_pin_messages=True,\n                can_send_polls=True,\n                can_change_info=True,\n                can_send_media_messages=True,\n                can_send_other_messages=True,\n                can_add_web_page_previews=True,\n            )\n            try:\n                bot.restrict_chat_member(chat.id, int(user_id), chat_permissions)\n            except BadRequest:\n                pass\n            bot.sendMessage(\n                chat.id,\n                f\"I shall allow <b>{html.escape(member.user.first_name)}</b> to text!\",\n                parse_mode=ParseMode.HTML,\n            )\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"#UNMUTE\\n\"\n                f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"<b>User:</b> {mention_html(member.user.id, member.user.first_name)}\"\n            )\n    else:\n        message.reply_text(\n            \"This user isn't even in the chat, unmuting them won't make them talk more than they \"\n            \"already do!\"\n        )\n\n    return \"\"\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@user_admin\n@loggable\ndef temp_mute(update: Update, context: CallbackContext) -> str:\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n\n    user_id, reason = extract_user_and_text(message, args)\n    reply = check_user(user_id, bot, chat)\n\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    member = chat.get_member(user_id)\n\n    if not reason:\n        message.reply_text(\"You haven't specified a time to mute this user for!\")\n        return \"\"\n\n    split_reason = reason.split(None, 1)\n\n    time_val = split_reason[0].lower()\n    if len(split_reason) > 1:\n        reason = split_reason[1]\n    else:\n        reason = \"\"\n\n    mutetime = extract_time(message, time_val)\n\n    if not mutetime:\n        return \"\"\n\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#TEMP MUTED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, member.user.first_name)}\\n\"\n        f\"<b>Time:</b> {time_val}\"\n    )\n    if reason:\n        log += f\"\\n<b>Reason:</b> {reason}\"\n\n    try:\n        if member.can_send_messages is None or member.can_send_messages:\n            chat_permissions = ChatPermissions(can_send_messages=False)\n            bot.restrict_chat_member(\n                chat.id, user_id, chat_permissions, until_date=mutetime\n            )\n            bot.sendMessage(\n                chat.id,\n                f\"Muted <b>{html.escape(member.user.first_name)}</b> for {time_val}!\",\n                parse_mode=ParseMode.HTML,\n            )\n            return log\n        else:\n            message.reply_text(\"This user is already muted.\")\n\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(f\"Muted for {time_val}!\", quote=False)\n            return log\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR muting user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't mute that user.\")\n\n    return \"\"\n\n\n# __help__ = \"\"\"\n# *Admins only:*\n#  ‚ùç /mute <userhandle>*:* silences a user. Can also be used as a reply, muting the replied to user.\n#  ‚ùç /tmute <userhandle> x(m/h/d)*:* mutes a user for x time. (via handle, or reply). `m` = `minutes`, `h` = `hours`, `d` = `days`.\n#  ‚ùç /unmute <userhandle>*:* unmutes a user. Can also be used as a reply, muting the replied to user.\n# \"\"\"\n\nMUTE_HANDLER = CommandHandler(\"mute\", mute)\nUNMUTE_HANDLER = CommandHandler(\"unmute\", unmute)\nTEMPMUTE_HANDLER = CommandHandler([\"tmute\", \"tempmute\"], temp_mute)\n\ndispatcher.add_handler(MUTE_HANDLER)\ndispatcher.add_handler(UNMUTE_HANDLER)\ndispatcher.add_handler(TEMPMUTE_HANDLER)\n\n__mod_name__ = \"Muting\"\n__handlers__ = [MUTE_HANDLER, UNMUTE_HANDLER, TEMPMUTE_HANDLER]\n","size_bytes":7891},"sitaBot/modules/cust_filters.py":{"content":"import re\nimport random\nfrom html import escape\n\nimport telegram\nfrom telegram import ParseMode, InlineKeyboardMarkup, Message, InlineKeyboardButton\nfrom telegram.error import BadRequest\nfrom telegram.ext import (\n    CommandHandler,\n    MessageHandler,\n    DispatcherHandlerStop,\n    CallbackQueryHandler,\n    run_async,\n    Filters,\n)\nfrom telegram.utils.helpers import mention_html, escape_markdown\n\nfrom sitaBot import dispatcher, LOGGER, DRAGONS\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.handlers import MessageHandlerChecker\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.helper_funcs.extraction import extract_text\nfrom sitaBot.modules.helper_funcs.filters import CustomFilters\nfrom sitaBot.modules.helper_funcs.misc import build_keyboard_parser\nfrom sitaBot.modules.helper_funcs.msg_types import get_filter_type\nfrom sitaBot.modules.helper_funcs.string_handling import (\n    split_quotes,\n    button_markdown_parser,\n    escape_invalid_curly_brackets,\n    markdown_to_html,\n)\nfrom sitaBot.modules.sql import cust_filters_sql as sql\n\nfrom sitaBot.modules.connection import connected\n\nfrom sitaBot.modules.helper_funcs.alternate import send_message, typing_action\n\nHANDLER_GROUP = 10\n\nENUM_FUNC_MAP = {\n    sql.Types.TEXT.value: dispatcher.bot.send_message,\n    sql.Types.BUTTON_TEXT.value: dispatcher.bot.send_message,\n    sql.Types.STICKER.value: dispatcher.bot.send_sticker,\n    sql.Types.DOCUMENT.value: dispatcher.bot.send_document,\n    sql.Types.PHOTO.value: dispatcher.bot.send_photo,\n    sql.Types.AUDIO.value: dispatcher.bot.send_audio,\n    sql.Types.VOICE.value: dispatcher.bot.send_voice,\n    sql.Types.VIDEO.value: dispatcher.bot.send_video,\n    # sql.Types.VIDEO_NOTE.value: dispatcher.bot.send_video_note\n}\n\n\n@run_async\n@typing_action\ndef list_handlers(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=False)\n    if not conn is False:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n        filter_list = \"*Filter in {}:*\\n\"\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            chat_name = \"Local filters\"\n            filter_list = \"*local filters:*\\n\"\n        else:\n            chat_name = chat.title\n            filter_list = \"*Filters in {}*:\\n\"\n\n    all_handlers = sql.get_chat_triggers(chat_id)\n\n    if not all_handlers:\n        send_message(\n            update.effective_message, \"No filters saved in {}!\".format(chat_name)\n        )\n        return\n\n    for keyword in all_handlers:\n        entry = \" ‚Ä¢ `{}`\\n\".format(escape_markdown(keyword))\n        if len(entry) + len(filter_list) > telegram.MAX_MESSAGE_LENGTH:\n            send_message(\n                update.effective_message,\n                filter_list.format(chat_name),\n                parse_mode=telegram.ParseMode.MARKDOWN,\n            )\n            filter_list = entry\n        else:\n            filter_list += entry\n\n    send_message(\n        update.effective_message,\n        filter_list.format(chat_name),\n        parse_mode=telegram.ParseMode.MARKDOWN,\n    )\n\n\n# NOT ASYNC BECAUSE DISPATCHER HANDLER RAISED\n@user_admin\n@typing_action\ndef filters(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n    args = msg.text.split(\n        None, 1\n    )  # use python's maxsplit to separate Cmd, keyword, and reply_text\n\n    conn = connected(context.bot, update, chat, user.id)\n    if not conn is False:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            chat_name = \"local filters\"\n        else:\n            chat_name = chat.title\n\n    if not msg.reply_to_message and len(args) < 2:\n        send_message(\n            update.effective_message,\n            \"Please provide keyboard keyword for this filter to reply with!\",\n        )\n        return\n\n    if msg.reply_to_message:\n        if len(args) < 2:\n            send_message(\n                update.effective_message,\n                \"Please provide keyword for this filter to reply with!\",\n            )\n            return\n        else:\n            keyword = args[1]\n    else:\n        extracted = split_quotes(args[1])\n        if len(extracted) < 1:\n            return\n        # set trigger -> lower, so as to avoid adding duplicate filters with different cases\n        keyword = extracted[0].lower()\n\n    # Add the filter\n    # Note: perhaps handlers can be removed somehow using sql.get_chat_filters\n    for handler in dispatcher.handlers.get(HANDLER_GROUP, []):\n        if handler.filters == (keyword, chat_id):\n            dispatcher.remove_handler(handler, HANDLER_GROUP)\n\n    text, file_type, file_id = get_filter_type(msg)\n    if not msg.reply_to_message and len(extracted) >= 2:\n        offset = len(extracted[1]) - len(\n            msg.text\n        )  # set correct offset relative to command + notename\n        text, buttons = button_markdown_parser(\n            extracted[1], entities=msg.parse_entities(), offset=offset\n        )\n        text = text.strip()\n        if not text:\n            send_message(\n                update.effective_message,\n                \"There is no note message - You can't JUST have buttons, you need a message to go with it!\",\n            )\n            return\n\n    elif msg.reply_to_message and len(args) >= 2:\n        if msg.reply_to_message.text:\n            text_to_parsing = msg.reply_to_message.text\n        elif msg.reply_to_message.caption:\n            text_to_parsing = msg.reply_to_message.caption\n        else:\n            text_to_parsing = \"\"\n        offset = len(\n            text_to_parsing\n        )  # set correct offset relative to command + notename\n        text, buttons = button_markdown_parser(\n            text_to_parsing, entities=msg.parse_entities(), offset=offset\n        )\n        text = text.strip()\n\n    elif not text and not file_type:\n        send_message(\n            update.effective_message,\n            \"Please provide keyword for this filter reply with!\",\n        )\n        return\n\n    elif msg.reply_to_message:\n        if msg.reply_to_message.text:\n            text_to_parsing = msg.reply_to_message.text\n        elif msg.reply_to_message.caption:\n            text_to_parsing = msg.reply_to_message.caption\n        else:\n            text_to_parsing = \"\"\n        offset = len(\n            text_to_parsing\n        )  # set correct offset relative to command + notename\n        text, buttons = button_markdown_parser(\n            text_to_parsing, entities=msg.parse_entities(), offset=offset\n        )\n        text = text.strip()\n        if (msg.reply_to_message.text or msg.reply_to_message.caption) and not text:\n            send_message(\n                update.effective_message,\n                \"There is no note message - You can't JUST have buttons, you need a message to go with it!\",\n            )\n            return\n\n    else:\n        send_message(update.effective_message, \"Invalid filter!\")\n        return\n\n    add = addnew_filter(update, chat_id, keyword, text, file_type, file_id, buttons)\n    # This is an old method\n    # sql.add_filter(chat_id, keyword, content, is_sticker, is_document, is_image, is_audio, is_voice, is_video, buttons)\n\n    if add is True:\n        send_message(\n            update.effective_message,\n            \"Saved filter '{}' in *{}*!\".format(keyword, chat_name),\n            parse_mode=telegram.ParseMode.MARKDOWN,\n        )\n    raise DispatcherHandlerStop\n\n\n# NOT ASYNC BECAUSE DISPATCHER HANDLER RAISED\n@user_admin\n@typing_action\ndef stop_filter(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n    args = update.effective_message.text.split(None, 1)\n\n    conn = connected(context.bot, update, chat, user.id)\n    if not conn is False:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            chat_name = \"Local filters\"\n        else:\n            chat_name = chat.title\n\n    if len(args) < 2:\n        send_message(update.effective_message, \"What should i stop?\")\n        return\n\n    chat_filters = sql.get_chat_triggers(chat_id)\n\n    if not chat_filters:\n        send_message(update.effective_message, \"No filters active here!\")\n        return\n\n    for keyword in chat_filters:\n        if keyword == args[1]:\n            sql.remove_filter(chat_id, args[1])\n            send_message(\n                update.effective_message,\n                \"Okay, I'll stop replying to that filter in *{}*.\".format(chat_name),\n                parse_mode=telegram.ParseMode.MARKDOWN,\n            )\n            raise DispatcherHandlerStop\n\n    send_message(\n        update.effective_message,\n        \"That's not a filter - Click: /filters to get currently active filters.\",\n    )\n\n\n@run_async\ndef reply_filter(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    message = update.effective_message  # type: Optional[Message]\n\n    if not update.effective_user or update.effective_user.id == 777000:\n        return\n    to_match = extract_text(message)\n    if not to_match:\n        return\n\n    chat_filters = sql.get_chat_triggers(chat.id)\n    for keyword in chat_filters:\n        pattern = r\"( |^|[^\\w])\" + re.escape(keyword) + r\"( |$|[^\\w])\"\n        if re.search(pattern, to_match, flags=re.IGNORECASE):\n            if MessageHandlerChecker.check_user(update.effective_user.id):\n                return\n            filt = sql.get_filter(chat.id, keyword)\n            if filt.reply == \"there is should be a new reply\":\n                buttons = sql.get_buttons(chat.id, filt.keyword)\n                keyb = build_keyboard_parser(context.bot, chat.id, buttons)\n                keyboard = InlineKeyboardMarkup(keyb)\n\n                VALID_WELCOME_FORMATTERS = [\n                    \"first\",\n                    \"last\",\n                    \"fullname\",\n                    \"username\",\n                    \"id\",\n                    \"chatname\",\n                    \"mention\",\n                ]\n                if filt.reply_text:\n                    if \"%%%\" in filt.reply_text:\n                        split = filt.reply_text.split(\"%%%\")\n                        if all(split):\n                            text = random.choice(split)\n                        else:\n                            text = filt.reply_text\n                    else:\n                        text = filt.reply_text\n                    if text.startswith(\"~!\") and text.endswith(\"!~\"):\n                        sticker_id = text.replace(\"~!\", \"\").replace(\"!~\", \"\")\n                        try:\n                            context.bot.send_sticker(\n                                chat.id,\n                                sticker_id,\n                                reply_to_message_id=message.message_id,\n                            )\n                            return\n                        except BadRequest as excp:\n                            if (\n                                excp.message\n                                == \"Wrong remote file identifier specified: wrong padding in the string\"\n                            ):\n                                context.bot.send_message(\n                                    chat.id,\n                                    \"Message couldn't be sent, Is the sticker id valid?\",\n                                )\n                                return\n                            else:\n                                LOGGER.exception(\"Error in filters: \" + excp.message)\n                                return\n                    valid_format = escape_invalid_curly_brackets(\n                        text, VALID_WELCOME_FORMATTERS\n                    )\n                    if valid_format:\n                        filtext = valid_format.format(\n                            first=escape(message.from_user.first_name),\n                            last=escape(\n                                message.from_user.last_name\n                                or message.from_user.first_name\n                            ),\n                            fullname=\" \".join(\n                                [\n                                    escape(message.from_user.first_name),\n                                    escape(message.from_user.last_name),\n                                ]\n                                if message.from_user.last_name\n                                else [escape(message.from_user.first_name)]\n                            ),\n                            username=\"@\" + escape(message.from_user.username)\n                            if message.from_user.username\n                            else mention_html(\n                                message.from_user.id, message.from_user.first_name\n                            ),\n                            mention=mention_html(\n                                message.from_user.id, message.from_user.first_name\n                            ),\n                            chatname=escape(message.chat.title)\n                            if message.chat.type != \"private\"\n                            else escape(message.from_user.first_name),\n                            id=message.from_user.id,\n                        )\n                    else:\n                        filtext = \"\"\n                else:\n                    filtext = \"\"\n\n                if filt.file_type in (sql.Types.BUTTON_TEXT, sql.Types.TEXT):\n                    try:\n                        context.bot.send_message(\n                            chat.id,\n                            markdown_to_html(filtext),\n                            reply_to_message_id=message.message_id,\n                            parse_mode=ParseMode.HTML,\n                            disable_web_page_preview=True,\n                            reply_markup=keyboard,\n                        )\n                    except BadRequest as excp:\n                        error_catch = get_exception(excp, filt, chat)\n                        if error_catch == \"noreply\":\n                            try:\n                                context.bot.send_message(\n                                    chat.id,\n                                    markdown_to_html(filtext),\n                                    parse_mode=ParseMode.HTML,\n                                    disable_web_page_preview=True,\n                                    reply_markup=keyboard,\n                                )\n                            except BadRequest as excp:\n                                LOGGER.exception(\"Error in filters: \" + excp.message)\n                                send_message(\n                                    update.effective_message,\n                                    get_exception(excp, filt, chat),\n                                )\n                        else:\n                            try:\n                                send_message(\n                                    update.effective_message,\n                                    get_exception(excp, filt, chat),\n                                )\n                            except BadRequest as excp:\n                                LOGGER.exception(\n                                    \"Failed to send message: \" + excp.message\n                                )\n                                pass\n                else:\n                    try:\n                        ENUM_FUNC_MAP[filt.file_type](\n                            chat.id,\n                            filt.file_id,\n                            caption=markdown_to_html(filtext),\n                            reply_to_message_id=message.message_id,\n                            parse_mode=ParseMode.HTML,\n                            disable_web_page_preview=True,\n                            reply_markup=keyboard,\n                        )\n                    except BadRequest:\n                        send_message(\n                            message,\n                            \"I don't have the permission to send the content of the filter.\",\n                        )\n                break\n            else:\n                if filt.is_sticker:\n                    message.reply_sticker(filt.reply)\n                elif filt.is_document:\n                    message.reply_document(filt.reply)\n                elif filt.is_image:\n                    message.reply_photo(filt.reply)\n                elif filt.is_audio:\n                    message.reply_audio(filt.reply)\n                elif filt.is_voice:\n                    message.reply_voice(filt.reply)\n                elif filt.is_video:\n                    message.reply_video(filt.reply)\n                elif filt.has_markdown:\n                    buttons = sql.get_buttons(chat.id, filt.keyword)\n                    keyb = build_keyboard_parser(context.bot, chat.id, buttons)\n                    keyboard = InlineKeyboardMarkup(keyb)\n\n                    try:\n                        send_message(\n                            update.effective_message,\n                            filt.reply,\n                            parse_mode=ParseMode.MARKDOWN,\n                            disable_web_page_preview=True,\n                            reply_markup=keyboard,\n                        )\n                    except BadRequest as excp:\n                        if excp.message == \"Unsupported url protocol\":\n                            try:\n                                send_message(\n                                    update.effective_message,\n                                    \"You seem to be trying to use an unsupported url protocol. \"\n                                    \"Telegram doesn't support buttons for some protocols, such as tg://. Please try \"\n                                    \"again...\",\n                                )\n                            except BadRequest as excp:\n                                LOGGER.exception(\"Error in filters: \" + excp.message)\n                                pass\n                        elif excp.message == \"Reply message not found\":\n                            try:\n                                context.bot.send_message(\n                                    chat.id,\n                                    filt.reply,\n                                    parse_mode=ParseMode.MARKDOWN,\n                                    disable_web_page_preview=True,\n                                    reply_markup=keyboard,\n                                )\n                            except BadRequest as excp:\n                                LOGGER.exception(\"Error in filters: \" + excp.message)\n                                pass\n                        else:\n                            try:\n                                send_message(\n                                    update.effective_message,\n                                    \"This message couldn't be sent as it's incorrectly formatted.\",\n                                )\n                            except BadRequest as excp:\n                                LOGGER.exception(\"Error in filters: \" + excp.message)\n                                pass\n                            LOGGER.warning(\n                                \"Message %s could not be parsed\", str(filt.reply)\n                            )\n                            LOGGER.exception(\n                                \"Could not parse filter %s in chat %s\",\n                                str(filt.keyword),\n                                str(chat.id),\n                            )\n\n                else:\n                    # LEGACY - all new filters will have has_markdown set to True.\n                    try:\n                        send_message(update.effective_message, filt.reply)\n                    except BadRequest as excp:\n                        LOGGER.exception(\"Error in filters: \" + excp.message)\n                        pass\n                break\n\n\n@run_async\ndef rmall_filters(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n    member = chat.get_member(user.id)\n    if member.status != \"creator\" and user.id not in DRAGONS:\n        update.effective_message.reply_text(\n            \"Only the chat owner can clear all notes at once.\"\n        )\n    else:\n        buttons = InlineKeyboardMarkup(\n            [\n                [\n                    InlineKeyboardButton(\n                        text=\"Stop all filters\", callback_data=\"filters_rmall\"\n                    )\n                ],\n                [InlineKeyboardButton(text=\"Cancel\", callback_data=\"filters_cancel\")],\n            ]\n        )\n        update.effective_message.reply_text(\n            f\"Are you sure you would like to stop ALL filters in {chat.title}? This action cannot be undone.\",\n            reply_markup=buttons,\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n\n@run_async\ndef rmall_callback(update, context):\n    query = update.callback_query\n    chat = update.effective_chat\n    msg = update.effective_message\n    member = chat.get_member(query.from_user.id)\n    if query.data == \"filters_rmall\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            allfilters = sql.get_chat_triggers(chat.id)\n            if not allfilters:\n                msg.edit_text(\"No filters in this chat, nothing to stop!\")\n                return\n\n            count = 0\n            filterlist = []\n            for x in allfilters:\n                count += 1\n                filterlist.append(x)\n\n            for i in filterlist:\n                sql.remove_filter(chat.id, i)\n\n            msg.edit_text(f\"Cleaned {count} filters in {chat.title}\")\n\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n    elif query.data == \"filters_cancel\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            msg.edit_text(\"Clearing of all filters has been cancelled.\")\n            return\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n\n\n# NOT ASYNC NOT A HANDLER\ndef get_exception(excp, filt, chat):\n    if excp.message == \"Unsupported url protocol\":\n        return \"You seem to be trying to use the URL protocol which is not supported. Telegram does not support key for multiple protocols, such as tg: //. Please try again!\"\n    elif excp.message == \"Reply message not found\":\n        return \"noreply\"\n    else:\n        LOGGER.warning(\"Message %s could not be parsed\", str(filt.reply))\n        LOGGER.exception(\n            \"Could not parse filter %s in chat %s\", str(filt.keyword), str(chat.id)\n        )\n        return \"This data could not be sent because it is incorrectly formatted.\"\n\n\n# NOT ASYNC NOT A HANDLER\ndef addnew_filter(update, chat_id, keyword, text, file_type, file_id, buttons):\n    msg = update.effective_message\n    totalfilt = sql.get_chat_triggers(chat_id)\n    if len(totalfilt) >= 150:  # Idk why i made this like function....\n        msg.reply_text(\"This group has reached its max filters limit of 150.\")\n        return False\n    else:\n        sql.new_add_filter(chat_id, keyword, text, file_type, file_id, buttons)\n        return True\n\n\ndef __stats__():\n    return \"‚Ä¢ {} filters, across {} chats.\".format(sql.num_filters(), sql.num_chats())\n\n\ndef __import_data__(chat_id, data):\n    # set chat filters\n    filters = data.get(\"filters\", {})\n    for trigger in filters:\n        sql.add_to_blacklist(chat_id, trigger)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    cust_filters = sql.get_chat_triggers(chat_id)\n    return \"There are `{}` custom filters here.\".format(len(cust_filters))\n\n\n__help__ = \"\"\"\n ‚ùç /filters*:* List all active filters saved in the chat.\n\n*Admin only:*\n ‚ùç /filter <keyword> <reply message>*:* Add a filter to this chat. The bot will now reply that message whenever 'keyword'\\\nis mentioned. If you reply to a sticker with a keyword, the bot will reply with that sticker. NOTE: all filter \\\nkeywords are in lowercase. If you want your keyword to be a sentence, use quotes. eg: /filter \"hey there\" How you \\\ndoin?\n Separate diff replies by `%%%` to get random replies\n *Example:* \n `/filter \"filtername\"\n Reply 1\n %%%\n Reply 2\n %%%\n Reply 3`\n ‚ùç /stop <filter keyword>*:* Stop that filter.\n\n*Chat creator only:*\n ‚ùç /removeallfilters*:* Remove all chat filters at once.\n\n*Note*: Filters also support markdown formatters like: {first}, {last} etc.. and buttons.\nCheck ‚ùç /markdownhelp to know more!\n\n\"\"\"\n\n__mod_name__ = \"Filters\"\n\nFILTER_HANDLER = CommandHandler(\"filter\", filters)\nSTOP_HANDLER = CommandHandler(\"stop\", stop_filter)\nRMALLFILTER_HANDLER = CommandHandler(\n    \"removeallfilters\", rmall_filters, filters=Filters.group\n)\nRMALLFILTER_CALLBACK = CallbackQueryHandler(rmall_callback, pattern=r\"filters_.*\")\nLIST_HANDLER = DisableAbleCommandHandler(\"filters\", list_handlers, admin_ok=True)\nCUST_FILTER_HANDLER = MessageHandler(\n    CustomFilters.has_text & ~Filters.update.edited_message, reply_filter\n)\n\ndispatcher.add_handler(FILTER_HANDLER)\ndispatcher.add_handler(STOP_HANDLER)\ndispatcher.add_handler(LIST_HANDLER)\ndispatcher.add_handler(CUST_FILTER_HANDLER, HANDLER_GROUP)\ndispatcher.add_handler(RMALLFILTER_HANDLER)\ndispatcher.add_handler(RMALLFILTER_CALLBACK)\n\n__handlers__ = [\n    FILTER_HANDLER,\n    STOP_HANDLER,\n    LIST_HANDLER,\n    (CUST_FILTER_HANDLER, HANDLER_GROUP, RMALLFILTER_HANDLER),\n]\n","size_bytes":25923},"sitaBot/modules/truth_and_dare_string.py":{"content":"TRUTH = (\n    \"Have you ghosted someone?\"\n    \"Have you ever walked in on your parents doing 'it'?\",\n    \"Who was the last person you liked the most? Why?\",\n    \"Have you ever been suspended from school?\",\n    \"If you had to choose between going naked or having your thoughts appear in thought bubbles above your head for everyone to read, which would you choose?\",\n    \"What‚Äôs the one thing you‚Äôre afraid to lose?\",\n    \"Do you like someone as of the moment?\",\n    \"One thing about your best friend you are jealous of?\",\n    \"Would you cheat on your boyfriend for a rich guy?\",\n    \"What is your biggest turn on?\",\n    \"When‚Äôs the last time you lied to your parents and why?\",\n    \"Describe your ideal partner.\",\n    \"What‚Äôs the scariest thing you‚Äôve ever done?\",\n    \"Have you ever picked your nose and eaten it?\",\n    \"When‚Äôs the last time you lied to your parents and why?\",\n    \"Have you ever lied about your age to participate in a contest?\",\n    \"Have you ever been caught checking someone out?\",\n  \n)\n\nDARE = (\n    \"Show the most embarrassing photo on your phone\"\n    \"Show the last five people you texted and what the messages said\",\n    \"Let the rest of the group DM someone from your Instagram account\",\n    \"Eat a raw piece of garlic\",\n    \"Do 100 squats\",\n    \"Keep three ice cubes in your mouth until they melt\",\n    \"Say something dirty to the person on your leftYou've got company!\",\n    \"Give a foot massage to the person on your right\",\n    \"Put 10 different available liquids into a cup and drink it\",\n    \"*Yell out the first word that comes to your mind\",\n    \"Give a lap dance to someone of your choice\",\n    \"Remove four items of clothing\",\n    \"Like the first 15 posts on your Facebook newsfeed\",\n    \"Eat a spoonful of mustard\",\n    \"Keep your eyes closed until it's your go again\",\n    \"Send a sext to the last person in your phonebook\",\n    \"Show off your orgasm face\",\n    \"Seductively eat a banana\",\n    \"Empty out your wallet/purse and show everyone what's inside\",\n    \"Do your best sexy crawl\",\n    \"Pretend to be the person to your right for 10 minutes\",\n    \"Eat a snack without using your hands\",\n    \"Say two honest things about everyone else in the group\",\n    \"Twerk for a minute\",\n    \"Try and make the group laugh as quickly as possible\",\n    \"Try to put your whole fist in your mouth\",\n    \"Tell everyone an embarrassing story about yourself\",\n    \"Try to lick your elbow\",\n    \"Post the oldest selfie on your phone on Instagram Stories\",\n    \"Tell the saddest story you know\",\n    \"Howl like a wolf for two minutes\",\n    \"Dance without music for two minutes\",\n    \"Pole dance with an imaginary pole\",\n    \"Let someone else tickle you and try not to laugh\",\n    \"Put as many snacks into your mouth at once as you can\",\n    \"Send your most recent selfie.\",\n    \"Send your ugliest selfie.\",\n    \"Send a screenshot of your facebook search history\",\n    \"Send a screenshot of your gallery.\",\n    \"Send a screenshot of your messenger inbox\",\n    \"Tell something very intimate.\",\n    \"Send a screenshot of your twitter inbox\",\n    \"Send a screenshot of your homescreen.\",\n    \"Send a cover of your favorite song. üé§\",\n    \"Do a lyric prank on someone and send proof.\",\n    \"Confess to your current crush. ‚ù§Ô∏è\",\n    \"Declare who is your true love.\",\n    \"Send a screenshot of your gallery.\",\n    \"Set your crush‚Äôs picture as your dp.\",\n    \"Suggest me more dares.\",\n)\n","size_bytes":3421},"sitaBot/modules/__tools.py":{"content":"__mod_name__ = \"Tools\"\n\n__help__ = \"\"\"\n*Fake Info*\n ‚ùç /fakegen*:* Generates Fake Information\n ‚ùç /picgen*:* Generate a fake pic \n\n*Date-time-Weather*\n ‚ùç /time <country code>*:* Gives information about a timezone.\n ‚ùç /weather <city>*:* Get weather info in a particular place.\n ‚ùç /wttr <city>*:* Advanced weather module, usage same as /weather\n ‚ùç /wttr moon*:* Get the current status of moon\n \n*Quotly*\n- /q : reply any message with this command to create a sticker.\n\n*Converts*\n ‚ùç /encrypt*:* Encrypts The Given Text\n ‚ùç /decrypt*:* Decrypts Previously Ecrypted Text\n ‚ùç /zip*:* reply to a telegram file to compress it in .zip format\n ‚ùç /unzip*:* reply to a telegram file to decompress it from the .zip format\n\"\"\"\n","size_bytes":730},"sitaBot/helper_extra/aichat.py":{"content":"from sitaBot.mongo import client as db_x\n\nlydia = db_x[\"CAHTBOT\"]\n\n\ndef add_chat(chat_id):\n    stark = lydia.find_one({\"chat_id\": chat_id})\n    if stark:\n        return False\n    else:\n        lydia.insert_one({\"chat_id\": chat_id})\n        return True\n\n\ndef remove_chat(chat_id):\n    stark = lydia.find_one({\"chat_id\": chat_id})\n    if not stark:\n        return False\n    else:\n        lydia.delete_one({\"chat_id\": chat_id})\n        return True\n\n\ndef get_all_chats():\n    r = list(lydia.find())\n    if r:\n        return r\n    else:\n        return False\n\n\ndef get_session(chat_id):\n    stark = lydia.find_one({\"chat_id\": chat_id})\n    if not stark:\n        return False\n    else:\n        return stark","size_bytes":699},"sitaBot/modules/dbcleanup.py":{"content":"from time import sleep\n\nimport sitaBot.modules.sql.global_bans_sql as gban_sql\nimport sitaBot.modules.sql.users_sql as user_sql\nfrom sitaBot import DEV_USERS, OWNER_ID, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update\nfrom telegram.error import BadRequest, Unauthorized\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    run_async,\n)\n\n\ndef get_invalid_chats(update: Update, context: CallbackContext, remove: bool = False):\n    bot = context.bot\n    chat_id = update.effective_chat.id\n    chats = user_sql.get_all_chats()\n    kicked_chats, progress = 0, 0\n    chat_list = []\n    progress_message = None\n\n    for chat in chats:\n\n        if ((100 * chats.index(chat)) / len(chats)) > progress:\n            progress_bar = f\"{progress}% completed in getting invalid chats.\"\n            if progress_message:\n                try:\n                    bot.editMessageText(\n                        progress_bar, chat_id, progress_message.message_id\n                    )\n                except:\n                    pass\n            else:\n                progress_message = bot.sendMessage(chat_id, progress_bar)\n            progress += 5\n\n        cid = chat.chat_id\n        sleep(0.1)\n        try:\n            bot.get_chat(cid, timeout=60)\n        except (BadRequest, Unauthorized):\n            kicked_chats += 1\n            chat_list.append(cid)\n        except:\n            pass\n\n    try:\n        progress_message.delete()\n    except:\n        pass\n\n    if not remove:\n        return kicked_chats\n    else:\n        for muted_chat in chat_list:\n            sleep(0.1)\n            user_sql.rem_chat(muted_chat)\n        return kicked_chats\n\n\ndef get_invalid_gban(update: Update, context: CallbackContext, remove: bool = False):\n    bot = context.bot\n    banned = gban_sql.get_gban_list()\n    ungbanned_users = 0\n    ungban_list = []\n\n    for user in banned:\n        user_id = user[\"user_id\"]\n        sleep(0.1)\n        try:\n            bot.get_chat(user_id)\n        except BadRequest:\n            ungbanned_users += 1\n            ungban_list.append(user_id)\n        except:\n            pass\n\n    if not remove:\n        return ungbanned_users\n    else:\n        for user_id in ungban_list:\n            sleep(0.1)\n            gban_sql.ungban_user(user_id)\n        return ungbanned_users\n\n\n@run_async\n@dev_plus\ndef dbcleanup(update: Update, context: CallbackContext):\n    msg = update.effective_message\n\n    msg.reply_text(\"Getting invalid chat count ...\")\n    invalid_chat_count = get_invalid_chats(update, context)\n\n    msg.reply_text(\"Getting invalid gbanned count ...\")\n    invalid_gban_count = get_invalid_gban(update, context)\n\n    reply = f\"Total invalid chats - {invalid_chat_count}\\n\"\n    reply += f\"Total invalid gbanned users - {invalid_gban_count}\"\n\n    buttons = [[InlineKeyboardButton(\"Cleanup DB\", callback_data=\"db_cleanup\")]]\n\n    update.effective_message.reply_text(\n        reply, reply_markup=InlineKeyboardMarkup(buttons)\n    )\n\n\n@run_async\ndef callback_button(update: Update, context: CallbackContext):\n    bot = context.bot\n    query = update.callback_query\n    message = query.message\n    chat_id = update.effective_chat.id\n    query_type = query.data\n\n    admin_list = [OWNER_ID] + DEV_USERS\n\n    bot.answer_callback_query(query.id)\n\n    if query_type == \"db_leave_chat\":\n        if query.from_user.id in admin_list:\n            bot.editMessageText(\"Leaving chats ...\", chat_id, message.message_id)\n            chat_count = get_muted_chats(update, context, True)\n            bot.sendMessage(chat_id, f\"Left {chat_count} chats.\")\n        else:\n            query.answer(\"You are not allowed to use this.\")\n    elif query_type == \"db_cleanup\":\n        if query.from_user.id in admin_list:\n            bot.editMessageText(\"Cleaning up DB ...\", chat_id, message.message_id)\n            invalid_chat_count = get_invalid_chats(update, context, True)\n            invalid_gban_count = get_invalid_gban(update, context, True)\n            reply = \"Cleaned up {} chats and {} gbanned users from db.\".format(\n                invalid_chat_count, invalid_gban_count\n            )\n            bot.sendMessage(chat_id, reply)\n        else:\n            query.answer(\"You are not allowed to use this.\")\n\n\nDB_CLEANUP_HANDLER = CommandHandler(\"dbcleanup\", dbcleanup)\nBUTTON_HANDLER = CallbackQueryHandler(callback_button, pattern=\"db_.*\")\n\ndispatcher.add_handler(DB_CLEANUP_HANDLER)\ndispatcher.add_handler(BUTTON_HANDLER)\n\n__mod_name__ = \"DB Cleanup\"\n__handlers__ = [DB_CLEANUP_HANDLER, BUTTON_HANDLER]\n","size_bytes":4633},"sitaBot/modules/sql_extended/forceSubscribe_sql.py":{"content":"from sqlalchemy import Column, String, Numeric, Boolean\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass forceSubscribe(BASE):\n    __tablename__ = \"forceSubscribe\"\n    chat_id = Column(Numeric, primary_key=True)\n    channel = Column(String)\n\n    def __init__(self, chat_id, channel):\n        self.chat_id = chat_id\n        self.channel = channel\n\n\nforceSubscribe.__table__.create(checkfirst=True)\n\n\ndef fs_settings(chat_id):\n    try:\n        return SESSION.query(forceSubscribe).filter(forceSubscribe.chat_id == chat_id).one()\n    except:\n        return None\n    finally:\n        SESSION.close()\n\n\ndef add_channel(chat_id, channel):\n    adder = SESSION.query(forceSubscribe).get(chat_id)\n    if adder:\n        adder.channel = channel\n    else:\n        adder = forceSubscribe(\n            chat_id,\n            channel\n        )\n    SESSION.add(adder)\n    SESSION.commit()\n\ndef disapprove(chat_id):\n    rem = SESSION.query(forceSubscribe).get(chat_id)\n    if rem:\n        SESSION.delete(rem)\n        SESSION.commit()","size_bytes":1019},"sitaBot/modules/__telegraph.py":{"content":"from sitaBot.events import register\nfrom sitaBot import telethn as tbot\nTMP_DOWNLOAD_DIRECTORY = \"./\"\nfrom telethon import events\nimport os\nfrom PIL import Image\nfrom datetime import datetime\nfrom telegraph import Telegraph, upload_file, exceptions\nSammy = \"Sita\"\ntelegraph = Telegraph()\nr = telegraph.create_account(short_name=Sammy)\nauth_url = r[\"auth_url\"]\n\n\n@register(pattern=\"^/t(m|xt) ?(.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    optional_title = event.pattern_match.group(2)\n    if event.reply_to_msg_id:\n        start = datetime.now()\n        r_message = await event.get_reply_message()\n        input_str = event.pattern_match.group(1)\n        if input_str == \"m\":\n            downloaded_file_name = await tbot.download_media(\n                r_message,\n                TMP_DOWNLOAD_DIRECTORY\n            )\n            end = datetime.now()\n            ms = (end - start).seconds\n            h = await event.reply(\"Downloaded to {} in {} seconds.\".format(downloaded_file_name, ms))\n            if downloaded_file_name.endswith((\".webp\")):\n                resize_image(downloaded_file_name)\n            try:\n                start = datetime.now()\n                media_urls = upload_file(downloaded_file_name)\n            except exceptions.TelegraphException as exc:\n                await h.edit(\"ERROR: \" + str(exc))\n                os.remove(downloaded_file_name)\n            else:\n                end = datetime.now()\n                ms_two = (end - start).seconds\n                os.remove(downloaded_file_name)\n                await h.edit(\"Uploaded to https://telegra.ph{})\".format(media_urls[0]), link_preview=True)\n        elif input_str == \"xt\":\n            user_object = await tbot.get_entity(r_message.sender_id)\n            title_of_page = user_object.first_name # + \" \" + user_object.last_name\n            # apparently, all Users do not have last_name field\n            if optional_title:\n                title_of_page = optional_title\n            page_content = r_message.message\n            if r_message.media:\n                if page_content != \"\":\n                    title_of_page = page_content\n                downloaded_file_name = await tbot.download_media(\n                    r_message,\n                    TMP_DOWNLOAD_DIRECTORY\n                )\n                m_list = None\n                with open(downloaded_file_name, \"rb\") as fd:\n                    m_list = fd.readlines()\n                for m in m_list:\n                    page_content += m.decode(\"UTF-8\") + \"\\n\"\n                os.remove(downloaded_file_name)\n            page_content = page_content.replace(\"\\n\", \"<br>\")\n            response = telegraph.create_page(\n                title_of_page,\n                html_content=page_content\n            )\n            end = datetime.now()\n            ms = (end - start).seconds\n            await event.reply(\"Pasted to https://telegra.ph/{} in {} seconds.\".format(response[\"path\"], ms), link_preview=True)\n    else:\n        await event.reply(\"Reply to a message to get a permanent telegra.ph link.\")\n\n\ndef resize_image(image):\n    im = Image.open(image)\n    im.save(image, \"PNG\")\n\n\n__help__ = \"\"\"\nI can upload files to Telegraph\n ‚ùç /tm :Get Telegraph Link Of Replied Media\n ‚ùç /txt :Get Telegraph Link of Replied Text\n\"\"\"\n\n__mod_name__ = \"Tgraph\"\n","size_bytes":3319},"sitaBot/utils/pyro_logger.py":{"content":"from pyrogram.enums import ParseMode\n\nfrom sitaBot import EVENT_LOGS, pbot\n\n\nasync def send_event_log(text: str) -> None:\n    \"\"\"Send a log message to EVENT_LOGS (if configured).\n\n    - Uses Pyrogram client so it works for pyrogram-powered features.\n    - Silently ignores failures or missing configuration.\n    \"\"\"\n    try:\n        if not EVENT_LOGS:\n            return\n        await pbot.send_message(\n            chat_id=str(EVENT_LOGS),\n            text=text,\n            parse_mode=ParseMode.HTML,\n            disable_web_page_preview=True,\n        )\n    except Exception:\n        # best-effort logging; ignore errors\n        pass\n\n\n","size_bytes":638},"sitaBot/modules/sql/global_bans_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, BigInteger, String, UnicodeText\n\n\nclass GloballyBannedUsers(BASE):\n    __tablename__ = \"gbans\"\n    user_id = Column(BigInteger, primary_key=True)\n    name = Column(UnicodeText, nullable=False)\n    reason = Column(UnicodeText)\n\n    def __init__(self, user_id, name, reason=None):\n        self.user_id = user_id\n        self.name = name\n        self.reason = reason\n\n    def __repr__(self):\n        return \"<GBanned User {} ({})>\".format(self.name, self.user_id)\n\n    def to_dict(self):\n        return {\"user_id\": self.user_id, \"name\": self.name, \"reason\": self.reason}\n\n\nclass GbanSettings(BASE):\n    __tablename__ = \"gban_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    setting = Column(Boolean, default=True, nullable=False)\n\n    def __init__(self, chat_id, enabled):\n        self.chat_id = str(chat_id)\n        self.setting = enabled\n\n    def __repr__(self):\n        return \"<Gban setting {} ({})>\".format(self.chat_id, self.setting)\n\n\nGloballyBannedUsers.__table__.create(checkfirst=True)\nGbanSettings.__table__.create(checkfirst=True)\n\nGBANNED_USERS_LOCK = threading.RLock()\nGBAN_SETTING_LOCK = threading.RLock()\nGBANNED_LIST = set()\nGBANSTAT_LIST = set()\n\n\ndef gban_user(user_id, name, reason=None):\n    with GBANNED_USERS_LOCK:\n        user = SESSION.query(GloballyBannedUsers).get(user_id)\n        if not user:\n            user = GloballyBannedUsers(user_id, name, reason)\n        else:\n            user.name = name\n            user.reason = reason\n\n        SESSION.merge(user)\n        SESSION.commit()\n        __load_gbanned_userid_list()\n\n\ndef update_gban_reason(user_id, name, reason=None):\n    with GBANNED_USERS_LOCK:\n        user = SESSION.query(GloballyBannedUsers).get(user_id)\n        if not user:\n            return None\n        old_reason = user.reason\n        user.name = name\n        user.reason = reason\n\n        SESSION.merge(user)\n        SESSION.commit()\n        return old_reason\n\n\ndef ungban_user(user_id):\n    with GBANNED_USERS_LOCK:\n        user = SESSION.query(GloballyBannedUsers).get(user_id)\n        if user:\n            SESSION.delete(user)\n\n        SESSION.commit()\n        __load_gbanned_userid_list()\n\n\ndef is_user_gbanned(user_id):\n    return user_id in GBANNED_LIST\n\n\ndef get_gbanned_user(user_id):\n    try:\n        return SESSION.query(GloballyBannedUsers).get(user_id)\n    finally:\n        SESSION.close()\n\n\ndef get_gban_list():\n    try:\n        return [x.to_dict() for x in SESSION.query(GloballyBannedUsers).all()]\n    finally:\n        SESSION.close()\n\n\ndef enable_gbans(chat_id):\n    with GBAN_SETTING_LOCK:\n        chat = SESSION.query(GbanSettings).get(str(chat_id))\n        if not chat:\n            chat = GbanSettings(chat_id, True)\n\n        chat.setting = True\n        SESSION.add(chat)\n        SESSION.commit()\n        if str(chat_id) in GBANSTAT_LIST:\n            GBANSTAT_LIST.remove(str(chat_id))\n\n\ndef disable_gbans(chat_id):\n    with GBAN_SETTING_LOCK:\n        chat = SESSION.query(GbanSettings).get(str(chat_id))\n        if not chat:\n            chat = GbanSettings(chat_id, False)\n\n        chat.setting = False\n        SESSION.add(chat)\n        SESSION.commit()\n        GBANSTAT_LIST.add(str(chat_id))\n\n\ndef does_chat_gban(chat_id):\n    return str(chat_id) not in GBANSTAT_LIST\n\n\ndef num_gbanned_users():\n    return len(GBANNED_LIST)\n\n\ndef __load_gbanned_userid_list():\n    global GBANNED_LIST\n    try:\n        GBANNED_LIST = {x.user_id for x in SESSION.query(GloballyBannedUsers).all()}\n    finally:\n        SESSION.close()\n\n\ndef __load_gban_stat_list():\n    global GBANSTAT_LIST\n    try:\n        GBANSTAT_LIST = {\n            x.chat_id for x in SESSION.query(GbanSettings).all() if not x.setting\n        }\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with GBAN_SETTING_LOCK:\n        chat = SESSION.query(GbanSettings).get(str(old_chat_id))\n        if chat:\n            chat.chat_id = new_chat_id\n            SESSION.add(chat)\n\n        SESSION.commit()\n\n\n# Create in memory userid to avoid disk access\n__load_gbanned_userid_list()\n__load_gban_stat_list()\n","size_bytes":4185},"sitaBot/modules/quotly.py":{"content":"from io import BytesIO\nfrom typing import List\n\nfrom pyrogram import filters\nfrom pyrogram.types import Message\n\nfrom sitaBot import pbot\n\nimport aiohttp\n\n\nAPI_ENDPOINT = \"https://bot.lyo.su/quote/generate.png\"\n\n\nasync def _text_or_caption(msg: Message) -> str:\n    if msg.text:\n        return msg.text\n    if msg.caption:\n        return msg.caption\n    return \"\"\n\n\nasync def _entities(msg: Message) -> List[dict]:\n    result: List[dict] = []\n    source = msg.entities or msg.caption_entities or []\n    for ent in source:\n        try:\n            etype = ent.type.name.lower()\n        except Exception:\n            etype = str(ent.type).lower()\n        result.append({\"type\": etype, \"offset\": ent.offset, \"length\": ent.length})\n    return result\n\n\nasync def _sender_id(msg: Message) -> int:\n    if msg.from_user:\n        return msg.from_user.id\n    if msg.sender_chat:\n        return msg.sender_chat.id\n    return 1\n\n\nasync def _sender_name(msg: Message) -> str:\n    if msg.from_user:\n        if msg.from_user.last_name:\n            return f\"{msg.from_user.first_name} {msg.from_user.last_name}\"\n        return msg.from_user.first_name\n    if msg.sender_chat:\n        return msg.sender_chat.title or \"\"\n    return \"\"\n\n\nasync def _sender_username(msg: Message) -> str:\n    if msg.from_user and msg.from_user.username:\n        return msg.from_user.username\n    if msg.sender_chat and msg.sender_chat.username:\n        return msg.sender_chat.username\n    return \"\"\n\n\nasync def _sender_photo(msg: Message):\n    u = msg.from_user\n    if u and u.photo:\n        return {\n            \"small_file_id\": u.photo.small_file_id,\n            \"small_photo_unique_id\": u.photo.small_photo_unique_id,\n            \"big_file_id\": u.photo.big_file_id,\n            \"big_photo_unique_id\": u.photo.big_photo_unique_id,\n        }\n    c = msg.sender_chat\n    if c and c.photo:\n        return {\n            \"small_file_id\": c.photo.small_file_id,\n            \"small_photo_unique_id\": c.photo.small_photo_unique_id,\n            \"big_file_id\": c.photo.big_file_id,\n            \"big_photo_unique_id\": c.photo.big_photo_unique_id,\n        }\n    return \"\"\n\n\nasync def _to_quotly_payload(messages: List[Message], include_reply: bool) -> dict:\n    if not isinstance(messages, list):\n        messages = [messages]\n    payload = {\n        \"type\": \"quote\",\n        \"format\": \"png\",\n        \"backgroundColor\": \"#1b1429\",\n        \"messages\": [],\n    }\n    for m in messages:\n        item = {\n            \"entities\": await _entities(m),\n            \"chatId\": await _sender_id(m),\n            \"text\": await _text_or_caption(m),\n            \"avatar\": True,\n            \"from\": {\n                \"id\": await _sender_id(m),\n                \"name\": await _sender_name(m),\n                \"username\": await _sender_username(m),\n                \"type\": m.chat.type.name.lower(),\n                \"photo\": await _sender_photo(m),\n            },\n            \"replyMessage\": {},\n        }\n        if include_reply and m.reply_to_message:\n            rm = m.reply_to_message\n            item[\"replyMessage\"] = {\n                \"name\": await _sender_name(rm),\n                \"text\": await _text_or_caption(rm),\n                \"chatId\": await _sender_id(rm),\n            }\n        payload[\"messages\"].append(item)\n    return payload\n\n\n@pbot.on_message(filters.command(\"q\") & filters.reply)\nasync def quotly_cmd(_, m: Message):\n    args = m.text.split()[1:]\n    include_reply = any(a.lower() == \"r\" for a in args)\n\n    # count between 1 and 10\n    count = 1\n    for a in args:\n        if a.isdigit():\n            try:\n                count = max(1, min(10, int(a)))\n            except Exception:\n                pass\n\n    processing = await m.reply_text(\"‚ö°\")\n    try:\n        if count == 1:\n            msgs = [m.reply_to_message]\n        else:\n            ids = list(range(m.reply_to_message.id, m.reply_to_message.id + count))\n            fetched = await _.get_messages(chat_id=m.chat.id, message_ids=ids, replies=-1)\n            msgs = [x for x in fetched if (not x.empty and not x.media)]\n\n        payload = await _to_quotly_payload(msgs, include_reply)\n        async with aiohttp.ClientSession() as session:\n            async with session.post(API_ENDPOINT, json=payload) as resp:\n                if resp.status != 200:\n                    txt = await resp.text()\n                    await processing.edit_text(f\"ERROR: {resp.status} {txt}\")\n                    return\n                data = await resp.read()\n        sticker = BytesIO(data)\n        sticker.name = \"quote.webp\"\n        await m.reply_sticker(sticker)\n    finally:\n        try:\n            await processing.delete()\n        except Exception:\n            pass\n\n\n__mod_name__ = \"Quotly\"\n__help__ = \"\"\"\n- /q [r] [1-10]: Reply to a message to create a quote sticker. Use r to include replied preview.\n\"\"\"\n\n\n","size_bytes":4824},"sitaBot/modules/modules.py":{"content":"import importlib\nimport collections\n\nfrom sitaBot import dispatcher, telethn\nfrom sitaBot.__main__ import (\n    CHAT_SETTINGS,\n    DATA_EXPORT,\n    DATA_IMPORT,\n    HELPABLE,\n    IMPORTED,\n    MIGRATEABLE,\n    STATS,\n    USER_INFO,\n    USER_SETTINGS,\n)\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus, sudo_plus\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\n\n@run_async\n@dev_plus\ndef load(update: Update, context: CallbackContext):\n    message = update.effective_message\n    text = message.text.split(\" \", 1)[1]\n    load_messasge = message.reply_text(\n        f\"Attempting to load module : <b>{text}</b>\", parse_mode=ParseMode.HTML\n    )\n\n    try:\n        imported_module = importlib.import_module(\"sitaBot.modules.\" + text)\n    except:\n        load_messasge.edit_text(\"Does that module even exist?\")\n        return\n\n    if not hasattr(imported_module, \"__mod_name__\"):\n        imported_module.__mod_name__ = imported_module.__name__\n\n    if imported_module.__mod_name__.lower() not in IMPORTED:\n        IMPORTED[imported_module.__mod_name__.lower()] = imported_module\n    else:\n        load_messasge.edit_text(\"Module already loaded.\")\n        return\n    if \"__handlers__\" in dir(imported_module):\n        handlers = imported_module.__handlers__\n        for handler in handlers:\n            if not isinstance(handler, tuple):\n                dispatcher.add_handler(handler)\n            else:\n                if isinstance(handler[0], collections.Callable):\n                    callback, telethon_event = handler\n                    telethn.add_event_handler(callback, telethon_event)\n                else:\n                    handler_name, priority = handler\n                    dispatcher.add_handler(handler_name, priority)\n    else:\n        IMPORTED.pop(imported_module.__mod_name__.lower())\n        load_messasge.edit_text(\"The module cannot be loaded.\")\n        return\n\n    if hasattr(imported_module, \"__help__\") and imported_module.__help__:\n        HELPABLE[imported_module.__mod_name__.lower()] = imported_module\n\n    # Chats to migrate on chat_migrated events\n    if hasattr(imported_module, \"__migrate__\"):\n        MIGRATEABLE.append(imported_module)\n\n    if hasattr(imported_module, \"__stats__\"):\n        STATS.append(imported_module)\n\n    if hasattr(imported_module, \"__user_info__\"):\n        USER_INFO.append(imported_module)\n\n    if hasattr(imported_module, \"__import_data__\"):\n        DATA_IMPORT.append(imported_module)\n\n    if hasattr(imported_module, \"__export_data__\"):\n        DATA_EXPORT.append(imported_module)\n\n    if hasattr(imported_module, \"__chat_settings__\"):\n        CHAT_SETTINGS[imported_module.__mod_name__.lower()] = imported_module\n\n    if hasattr(imported_module, \"__user_settings__\"):\n        USER_SETTINGS[imported_module.__mod_name__.lower()] = imported_module\n\n    load_messasge.edit_text(\n        \"Successfully loaded module : <b>{}</b>\".format(text), parse_mode=ParseMode.HTML\n    )\n\n\n@run_async\n@dev_plus\ndef unload(update: Update, context: CallbackContext):\n    message = update.effective_message\n    text = message.text.split(\" \", 1)[1]\n    unload_messasge = message.reply_text(\n        f\"Attempting to unload module : <b>{text}</b>\", parse_mode=ParseMode.HTML\n    )\n\n    try:\n        imported_module = importlib.import_module(\"sitaBot.modules.\" + text)\n    except:\n        unload_messasge.edit_text(\"Does that module even exist?\")\n        return\n\n    if not hasattr(imported_module, \"__mod_name__\"):\n        imported_module.__mod_name__ = imported_module.__name__\n    if imported_module.__mod_name__.lower() in IMPORTED:\n        IMPORTED.pop(imported_module.__mod_name__.lower())\n    else:\n        unload_messasge.edit_text(\"Can't unload something that isn't loaded.\")\n        return\n    if \"__handlers__\" in dir(imported_module):\n        handlers = imported_module.__handlers__\n        for handler in handlers:\n            if isinstance(handler, bool):\n                unload_messasge.edit_text(\"This module can't be unloaded!\")\n                return\n            elif not isinstance(handler, tuple):\n                dispatcher.remove_handler(handler)\n            else:\n                if isinstance(handler[0], collections.Callable):\n                    callback, telethon_event = handler\n                    telethn.remove_event_handler(callback, telethon_event)\n                else:\n                    handler_name, priority = handler\n                    dispatcher.remove_handler(handler_name, priority)\n    else:\n        unload_messasge.edit_text(\"The module cannot be unloaded.\")\n        return\n\n    if hasattr(imported_module, \"__help__\") and imported_module.__help__:\n        HELPABLE.pop(imported_module.__mod_name__.lower())\n\n    # Chats to migrate on chat_migrated events\n    if hasattr(imported_module, \"__migrate__\"):\n        MIGRATEABLE.remove(imported_module)\n\n    if hasattr(imported_module, \"__stats__\"):\n        STATS.remove(imported_module)\n\n    if hasattr(imported_module, \"__user_info__\"):\n        USER_INFO.remove(imported_module)\n\n    if hasattr(imported_module, \"__import_data__\"):\n        DATA_IMPORT.remove(imported_module)\n\n    if hasattr(imported_module, \"__export_data__\"):\n        DATA_EXPORT.remove(imported_module)\n\n    if hasattr(imported_module, \"__chat_settings__\"):\n        CHAT_SETTINGS.pop(imported_module.__mod_name__.lower())\n\n    if hasattr(imported_module, \"__user_settings__\"):\n        USER_SETTINGS.pop(imported_module.__mod_name__.lower())\n\n    unload_messasge.edit_text(\n        f\"Successfully unloaded module : <b>{text}</b>\", parse_mode=ParseMode.HTML\n    )\n\n\n@run_async\n@sudo_plus\ndef listmodules(update: Update, context: CallbackContext):\n    message = update.effective_message\n    module_list = []\n\n    for helpable_module in HELPABLE:\n        helpable_module_info = IMPORTED[helpable_module]\n        file_info = IMPORTED[helpable_module_info.__mod_name__.lower()]\n        file_name = file_info.__name__.rsplit(\"sitaBot.modules.\", 1)[1]\n        mod_name = file_info.__mod_name__\n        module_list.append(f\"- <code>{mod_name} ({file_name})</code>\\n\")\n    module_list = \"Following modules are loaded : \\n\\n\" + \"\".join(module_list)\n    message.reply_text(module_list, parse_mode=ParseMode.HTML)\n\n\nLOAD_HANDLER = CommandHandler(\"load\", load)\nUNLOAD_HANDLER = CommandHandler(\"unload\", unload)\nLISTMODULES_HANDLER = CommandHandler(\"listmodules\", listmodules)\n\ndispatcher.add_handler(LOAD_HANDLER)\ndispatcher.add_handler(UNLOAD_HANDLER)\ndispatcher.add_handler(LISTMODULES_HANDLER)\n\n__mod_name__ = \"Modules\"\n","size_bytes":6579},"sitaBot/modules/sql/blacklist_sql.py":{"content":"import threading\n\nfrom sqlalchemy import func, distinct, Column, String, UnicodeText, Integer\n\nfrom sitaBot.modules.sql import SESSION, BASE\n\n\nclass BlackListFilters(BASE):\n    __tablename__ = \"blacklist\"\n    chat_id = Column(String(14), primary_key=True)\n    trigger = Column(UnicodeText, primary_key=True, nullable=False)\n\n    def __init__(self, chat_id, trigger):\n        self.chat_id = str(chat_id)  # ensure string\n        self.trigger = trigger\n\n    def __repr__(self):\n        return \"<Blacklist filter '%s' for %s>\" % (self.trigger, self.chat_id)\n\n    def __eq__(self, other):\n        return bool(\n            isinstance(other, BlackListFilters)\n            and self.chat_id == other.chat_id\n            and self.trigger == other.trigger\n        )\n\n\nclass BlacklistSettings(BASE):\n    __tablename__ = \"blacklist_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    blacklist_type = Column(Integer, default=1)\n    value = Column(UnicodeText, default=\"0\")\n\n    def __init__(self, chat_id, blacklist_type=1, value=\"0\"):\n        self.chat_id = str(chat_id)\n        self.blacklist_type = blacklist_type\n        self.value = value\n\n    def __repr__(self):\n        return \"<{} will executing {} for blacklist trigger.>\".format(\n            self.chat_id, self.blacklist_type\n        )\n\n\nBlackListFilters.__table__.create(checkfirst=True)\nBlacklistSettings.__table__.create(checkfirst=True)\n\nBLACKLIST_FILTER_INSERTION_LOCK = threading.RLock()\nBLACKLIST_SETTINGS_INSERTION_LOCK = threading.RLock()\n\nCHAT_BLACKLISTS = {}\nCHAT_SETTINGS_BLACKLISTS = {}\n\n\ndef add_to_blacklist(chat_id, trigger):\n    with BLACKLIST_FILTER_INSERTION_LOCK:\n        blacklist_filt = BlackListFilters(str(chat_id), trigger)\n\n        SESSION.merge(blacklist_filt)  # merge to avoid duplicate key issues\n        SESSION.commit()\n        global CHAT_BLACKLISTS\n        if CHAT_BLACKLISTS.get(str(chat_id), set()) == set():\n            CHAT_BLACKLISTS[str(chat_id)] = {trigger}\n        else:\n            CHAT_BLACKLISTS.get(str(chat_id), set()).add(trigger)\n\n\ndef rm_from_blacklist(chat_id, trigger):\n    with BLACKLIST_FILTER_INSERTION_LOCK:\n        blacklist_filt = SESSION.query(BlackListFilters).get((str(chat_id), trigger))\n        if blacklist_filt:\n            if trigger in CHAT_BLACKLISTS.get(str(chat_id), set()):  # sanity check\n                CHAT_BLACKLISTS.get(str(chat_id), set()).remove(trigger)\n\n            SESSION.delete(blacklist_filt)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef get_chat_blacklist(chat_id):\n    return CHAT_BLACKLISTS.get(str(chat_id), set())\n\n\ndef num_blacklist_filters():\n    try:\n        return SESSION.query(BlackListFilters).count()\n    finally:\n        SESSION.close()\n\n\ndef num_blacklist_chat_filters(chat_id):\n    try:\n        return (\n            SESSION.query(BlackListFilters.chat_id)\n            .filter(BlackListFilters.chat_id == str(chat_id))\n            .count()\n        )\n    finally:\n        SESSION.close()\n\n\ndef num_blacklist_filter_chats():\n    try:\n        return SESSION.query(func.count(distinct(BlackListFilters.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef set_blacklist_strength(chat_id, blacklist_type, value):\n    # for blacklist_type\n    # 0 = nothing\n    # 1 = delete\n    # 2 = warn\n    # 3 = mute\n    # 4 = kick\n    # 5 = ban\n    # 6 = tban\n    # 7 = tmute\n    with BLACKLIST_SETTINGS_INSERTION_LOCK:\n        global CHAT_SETTINGS_BLACKLISTS\n        curr_setting = SESSION.query(BlacklistSettings).get(str(chat_id))\n        if not curr_setting:\n            curr_setting = BlacklistSettings(\n                chat_id, blacklist_type=int(blacklist_type), value=value\n            )\n\n        curr_setting.blacklist_type = int(blacklist_type)\n        curr_setting.value = str(value)\n        CHAT_SETTINGS_BLACKLISTS[str(chat_id)] = {\n            \"blacklist_type\": int(blacklist_type),\n            \"value\": value,\n        }\n\n        SESSION.add(curr_setting)\n        SESSION.commit()\n\n\ndef get_blacklist_setting(chat_id):\n    try:\n        setting = CHAT_SETTINGS_BLACKLISTS.get(str(chat_id))\n        if setting:\n            return setting[\"blacklist_type\"], setting[\"value\"]\n        else:\n            return 1, \"0\"\n\n    finally:\n        SESSION.close()\n\n\ndef __load_chat_blacklists():\n    global CHAT_BLACKLISTS\n    try:\n        chats = SESSION.query(BlackListFilters.chat_id).distinct().all()\n        for (chat_id,) in chats:  # remove tuple by ( ,)\n            CHAT_BLACKLISTS[chat_id] = []\n\n        all_filters = SESSION.query(BlackListFilters).all()\n        for x in all_filters:\n            CHAT_BLACKLISTS[x.chat_id] += [x.trigger]\n\n        CHAT_BLACKLISTS = {x: set(y) for x, y in CHAT_BLACKLISTS.items()}\n\n    finally:\n        SESSION.close()\n\n\ndef __load_chat_settings_blacklists():\n    global CHAT_SETTINGS_BLACKLISTS\n    try:\n        chats_settings = SESSION.query(BlacklistSettings).all()\n        for x in chats_settings:  # remove tuple by ( ,)\n            CHAT_SETTINGS_BLACKLISTS[x.chat_id] = {\n                \"blacklist_type\": x.blacklist_type,\n                \"value\": x.value,\n            }\n\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with BLACKLIST_FILTER_INSERTION_LOCK:\n        chat_filters = (\n            SESSION.query(BlackListFilters)\n            .filter(BlackListFilters.chat_id == str(old_chat_id))\n            .all()\n        )\n        for filt in chat_filters:\n            filt.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n\n__load_chat_blacklists()\n__load_chat_settings_blacklists()\n","size_bytes":5587},"sitaBot/modules/sql/notes_sql.py":{"content":"# Note: chat_id's are stored as strings because the int is too large to be stored in a PSQL database.\nimport threading\n\nfrom sitaBot.modules.helper_funcs.msg_types import Types\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, String, UnicodeText, distinct, func\n\n\nclass Notes(BASE):\n    __tablename__ = \"notes\"\n    chat_id = Column(String(14), primary_key=True)\n    name = Column(UnicodeText, primary_key=True)\n    value = Column(UnicodeText, nullable=False)\n    file = Column(UnicodeText)\n    is_reply = Column(Boolean, default=False)\n    has_buttons = Column(Boolean, default=False)\n    msgtype = Column(Integer, default=Types.BUTTON_TEXT.value)\n\n    def __init__(self, chat_id, name, value, msgtype, file=None):\n        self.chat_id = str(chat_id)  # ensure string\n        self.name = name\n        self.value = value\n        self.msgtype = msgtype\n        self.file = file\n\n    def __repr__(self):\n        return \"<Note %s>\" % self.name\n\n\nclass Buttons(BASE):\n    __tablename__ = \"note_urls\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(String(14), primary_key=True)\n    note_name = Column(UnicodeText, primary_key=True)\n    name = Column(UnicodeText, nullable=False)\n    url = Column(UnicodeText, nullable=False)\n    same_line = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, note_name, name, url, same_line=False):\n        self.chat_id = str(chat_id)\n        self.note_name = note_name\n        self.name = name\n        self.url = url\n        self.same_line = same_line\n\n\nNotes.__table__.create(checkfirst=True)\nButtons.__table__.create(checkfirst=True)\n\nNOTES_INSERTION_LOCK = threading.RLock()\nBUTTONS_INSERTION_LOCK = threading.RLock()\n\n\ndef add_note_to_db(chat_id, note_name, note_data, msgtype, buttons=None, file=None):\n    if not buttons:\n        buttons = []\n\n    with NOTES_INSERTION_LOCK:\n        prev = SESSION.query(Notes).get((str(chat_id), note_name))\n        if prev:\n            with BUTTONS_INSERTION_LOCK:\n                prev_buttons = (\n                    SESSION.query(Buttons)\n                    .filter(\n                        Buttons.chat_id == str(chat_id), Buttons.note_name == note_name\n                    )\n                    .all()\n                )\n                for btn in prev_buttons:\n                    SESSION.delete(btn)\n            SESSION.delete(prev)\n        note = Notes(\n            str(chat_id), note_name, note_data or \"\", msgtype=msgtype.value, file=file\n        )\n        SESSION.add(note)\n        SESSION.commit()\n\n    for b_name, url, same_line in buttons:\n        add_note_button_to_db(chat_id, note_name, b_name, url, same_line)\n\n\ndef get_note(chat_id, note_name):\n    try:\n        return (\n            SESSION.query(Notes)\n            .filter(func.lower(Notes.name) == note_name, Notes.chat_id == str(chat_id))\n            .first()\n        )\n    finally:\n        SESSION.close()\n\n\ndef rm_note(chat_id, note_name):\n    with NOTES_INSERTION_LOCK:\n        note = (\n            SESSION.query(Notes)\n            .filter(func.lower(Notes.name) == note_name, Notes.chat_id == str(chat_id))\n            .first()\n        )\n        if note:\n            with BUTTONS_INSERTION_LOCK:\n                buttons = (\n                    SESSION.query(Buttons)\n                    .filter(\n                        Buttons.chat_id == str(chat_id), Buttons.note_name == note_name\n                    )\n                    .all()\n                )\n                for btn in buttons:\n                    SESSION.delete(btn)\n\n            SESSION.delete(note)\n            SESSION.commit()\n            return True\n\n        else:\n            SESSION.close()\n            return False\n\n\ndef get_all_chat_notes(chat_id):\n    try:\n        return (\n            SESSION.query(Notes)\n            .filter(Notes.chat_id == str(chat_id))\n            .order_by(Notes.name.asc())\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef add_note_button_to_db(chat_id, note_name, b_name, url, same_line):\n    with BUTTONS_INSERTION_LOCK:\n        button = Buttons(chat_id, note_name, b_name, url, same_line)\n        SESSION.add(button)\n        SESSION.commit()\n\n\ndef get_buttons(chat_id, note_name):\n    try:\n        return (\n            SESSION.query(Buttons)\n            .filter(Buttons.chat_id == str(chat_id), Buttons.note_name == note_name)\n            .order_by(Buttons.id)\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef num_notes():\n    try:\n        return SESSION.query(Notes).count()\n    finally:\n        SESSION.close()\n\n\ndef num_chats():\n    try:\n        return SESSION.query(func.count(distinct(Notes.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with NOTES_INSERTION_LOCK:\n        chat_notes = (\n            SESSION.query(Notes).filter(Notes.chat_id == str(old_chat_id)).all()\n        )\n        for note in chat_notes:\n            note.chat_id = str(new_chat_id)\n\n        with BUTTONS_INSERTION_LOCK:\n            chat_buttons = (\n                SESSION.query(Buttons).filter(Buttons.chat_id == str(old_chat_id)).all()\n            )\n            for btn in chat_buttons:\n                btn.chat_id = str(new_chat_id)\n\n        SESSION.commit()\n","size_bytes":5282},"sitaBot/modules/reactions.py":{"content":"import random\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import Update\nfrom telegram.ext import CallbackContext, run_async\n\nreactions = [\n    \"( Õ°¬∞ Õú ñ Õ°¬∞)\",\n    \"( . ‚Ä¢ÃÅ _ ñ ‚Ä¢ÃÄ .)\",\n    \"( ‡≤† Õú ñ ‡≤†)\",\n    \"( Õ° Õú ñ Õ° )\",\n    \"( ò Õú ñ  ò)\",\n    \"„Éæ(¬¥„Äá`)Ôæâ‚ô™‚ô™‚ô™\",\n    \"„ÉΩ(o¬¥‚àÄ`)Ôæâ‚ô™‚ô¨\",\n    \"‚ô™‚ô¨((d‚åíœâ‚åíb))‚ô¨‚ô™\",\n    \"‚îî(ÔºæÔºæ)‚îê\",\n    \"(Ôø£‚ñΩÔø£)/‚ô´‚Ä¢*¬®*‚Ä¢.¬∏¬∏‚ô™\",\n    \"„Éæ(‚åê‚ñ†_‚ñ†)„Éé‚ô™\",\n    \"‰πÅ( ‚Ä¢ œâ ‚Ä¢‰πÅ)\",\n    \"‚ô¨‚ô´‚ô™‚óñ(‚óè o ‚óè)‚óó‚ô™‚ô´‚ô¨\",\n    \"(„Å£Àò⁄°ÀòœÇ)\",\n    \"( Àò‚ñΩÀò)„Å£‚ô®\",\n    \"(„ÄÄ„Éªœâ„Éª)‚äÉ-[‰∫å‰∫å]\",\n    \"(*¬¥„Éº`)Êó¶ Êó¶(Ôø£œâÔø£*)\",\n    \"( Ôø£‚ñΩÔø£)[] [](‚âß‚ñΩ‚â¶ )\",\n    \"(*Ôø£‚ñΩÔø£)Êó¶ ‰∏î(¬¥‚àÄ`*)\",\n    \"(„Éé Àò_Àò)„Éé„ÄÄŒ∂|||Œ∂„ÄÄŒ∂|||Œ∂„ÄÄŒ∂|||Œ∂\",\n    \"(„Éé¬∞‚àÄ¬∞)„Éé‚åíÔΩ•*:.ÔΩ°. .ÔΩ°.:*ÔΩ•„ÇúÔæüÔΩ•*‚òÜ\",\n    \"(‚äÉÔΩ°‚Ä¢ÃÅ‚Äø‚Ä¢ÃÄÔΩ°)‚äÉ‚îÅ‚úø‚úø‚úø‚úø‚úø‚úø\",\n    \"(‚à©` Ôæõ ¬¥)‚äÉ‚îÅÁÇéÁÇéÁÇéÁÇéÁÇé\",\n    \"( „Éª‚àÄ„Éª)„Éª„Éª„Éª--------‚òÜ\",\n    \"( -œâ-)ÔºèÂç†~~~~~\",\n    \"‚óã‚àû‚àû‚àû‚àû„ÉΩ(^„Éº^ )\",\n    \"(*ÔºæÔºæ)/~~~~~~~~~~‚óé\",\n    \"((( Ôø£‚ñ°)_Ôºè\",\n    \"(ÔæíÔø£‚ñΩÔø£)Ô∏ª‚î≥‚ïê‰∏Ä\",\n    \"„ÉΩ( ÔΩ•‚àÄÔΩ•)Ôæâ_Œ∏ÂΩ°‚òÜŒ£(„Éé `–î¬¥)„Éé\",\n    \"(*`0¬¥)Œ∏‚òÜ(„É°¬∞Áöø¬∞)Ôæâ\",\n    \"(; -_-)‚Äï‚Äï‚Äï‚Äï‚Äï‚ÄïC<‚Äï_-)\",\n    \"„ÉΩ(>_<„ÉΩ) ‚Äï‚äÇ|=0„Éò(^‚Äø^ )\",\n    \"(“Ç` Ôæõ ¬¥)Ô∏ª„Éá‚ïê‰∏Ä Ôºº(¬∫ ‚ñ° ¬∫ l|l)/\",\n    \"/( .‚ñ°.)Ôºº Ô∏µ‚ï∞(¬∞Áõä¬∞)‚ïØÔ∏µ /(.‚ñ°. /)\",\n    \"(`‚åí*)O-(`‚åí¬¥Q)\",\n    \"(„Å£‚Ä¢Ôπè‚Ä¢)„Å£ ‚ú¥==‚â°ÎààŸ©(`Áöø¬¥“Ç)‡∏á\",\n    \"„Éæ(„Éªœâ„Éª)„É°(„Éªœâ„Éª)„Éé\",\n    \"(*^œâ^)ÂÖ´(‚åí‚ñΩ‚åí)ÂÖ´(-‚Äø‚Äø- )„ÉΩ\",\n    \"„ÉΩ( ‚åíœâ‚åí)‰∫∫(=^‚Ä•^= )Ôæâ\",\n    \"ÔΩ°*:‚òÜ(„Éªœâ„Éª‰∫∫„Éªœâ„Éª)ÔΩ°:„Çú‚òÜÔΩ°\",\n    \"(¬∞(¬∞œâ(¬∞œâ¬∞(‚òÜœâ‚òÜ)¬∞œâ¬∞)œâ¬∞)¬∞)\",\n    \"(„Å£Àò‚ñΩÀò)(Àò‚ñΩÀò)Àò‚ñΩÀòœÇ)\",\n    \"(*ÔºæœâÔºæ)‰∫∫(ÔºæœâÔºæ*)\",\n    \"Ôºº(‚ñΩÔø£ \\ (Ôø£‚ñΩÔø£) / Ôø£‚ñΩ)Ôºè\",\n    \"(Ôø£ŒòÔø£)\",\n    \"Ôºº( Àã Œò ¬¥ )Ôºè\",\n    \"( ¬¥(00)Àã )\",\n    \"Ôºº(Ôø£(oo)Ôø£)Ôºè\",\n    \"Ôºè(‚âß x ‚â¶)Ôºº\",\n    \"Ôºè(=ÔΩ• x ÔΩ•=)Ôºº\",\n    \"(=^ÔΩ•œâÔΩ•^=)\",\n    \"(= ; ÔΩ™ ; =)\",\n    \"(=‚åí‚Äø‚Äø‚åí=)\",\n    \"(Ôºæ‚Ä¢ œâ ‚Ä¢Ôºæ)\",\n    \"‡¨≤(‚ìõ œâ ‚ìõ)‡¨≤\",\n    \"‡¨≤(‚ìõ œâ ‚ìõ)‡¨≤\",\n    \"(^‚óî·¥•‚óî^)\",\n    \"[(ÔºçÔºç)]..zzZ\",\n    \"(Ôø£oÔø£) zzZZzzZZ\",\n    \"(Ôºø Ôºø*) Z z z\",\n    \"‚òÜÔæê(o*ÔΩ•œâÔΩ•)Ôæâ\",\n    \"Œµ=Œµ=Œµ=Œµ=‚îå(;Ôø£‚ñΩÔø£)‚îò\",\n    \"Œµ===(„Å£‚âßœâ‚â¶)„Å£\",\n    \"__œÜ(ÔºéÔºé)\",\n    \"„Éæ( `„Éº¬¥)„Ç∑œÜ__\",\n    \"( ^‚ñΩ^)œà__\",\n    \"|ÔΩ•œâÔΩ•)\",\n    \"|–¥ÔΩ•)\",\n    \"‚î¨‚î¥‚î¨‚î¥‚î§ÔΩ•œâÔΩ•)Ôæâ\",\n    \"|ÔΩ•–¥ÔΩ•)Ôæâ\",\n    \"(*Ôø£iiÔø£)\",\n    \"(Ôºæ„ÄÉÔºæ)\",\n    \"m(_ _)m\",\n    \"‰∫∫(_ _*)\",\n    \"(„Ç∑. .)„Ç∑\",\n    \"(^_~)\",\n    \"(>œâ^)\",\n    \"(^_<)„Äú‚òÜ\",\n    \"(^_<)\",\n    \"(„Å•Ôø£ ¬≥Ôø£)„Å•\",\n    \"(‚äÉÔΩ°‚Ä¢ÃÅ‚Äø‚Ä¢ÃÄÔΩ°)‚äÉ\",\n    \"‚äÇ(¬¥‚Ä¢ œâ ‚Ä¢`‚äÇ)\",\n    \"(*„Éªœâ„Éª)Ôæâ\",\n    \"(^-^*)/\",\n    \"„Éæ(*'‚ñΩ'*)\",\n    \"(^Ôºê^)„Éé\",\n    \"(*¬∞ÔΩ∞¬∞)Ôæâ\",\n    \"(Ôø£œâÔø£)/\",\n    \"(‚âß‚ñΩ‚â¶)/\",\n    \"w(¬∞ÔΩè¬∞)w\",\n    \"(‚äô_‚äô)\",\n    \"(¬∞„É≠¬∞) !\",\n    \"‚àë(O_O;)\",\n    \"(Ôø¢_Ôø¢)\",\n    \"(¬¨_¬¨ )\",\n    \"(‚Üº_‚Üº)\",\n    \"(Ôø£œâÔø£;)\",\n    \"‚îê('ÔΩû`;)‚îå\",\n    \"(„Éª_„Éª;)\",\n    \"(Ôº†_Ôº†)\",\n    \"(‚Ä¢‡∏¥_‚Ä¢‡∏¥)?\",\n    \"„ÉΩ(„Éº_„Éº )„Éé\",\n    \"‚îê(Ôø£„ÉòÔø£)‚îå\",\n    \"‚îê(Ôø£ÔΩûÔø£)‚îå\",\n    \"‚îê( ¬¥ –¥ ` )‚îå\",\n    \"‚ïÆ(Ô∏∂‚ñΩÔ∏∂)‚ï≠\",\n    \"·ïï( ·êõ )·ïó\",\n    \"(„Ééœâ„ÉΩ)\",\n    \"(‚Ä≥„É≠„Çõ)\",\n    \"(/œâÔºº)\",\n    \"(((ÔºûÔºú)))\",\n    \"~(>_<~)\",\n    \"(√ó_√ó)\",\n    \"(√óÔπè√ó)\",\n    \"(„Éé_<„ÄÇ)\",\n    \"(Œº_Œº)\",\n    \"o(T„ÉòTo)\",\n    \"( ÔæüÔºå_„ÇùÔΩÄ)\",\n    \"( ‚ï•œâ‚ï• )\",\n    \"(ÔºèÀç„Éª„ÄÅ)\",\n    \"(„Å§œâ`ÔΩ°)\",\n    \"(T_T)\",\n    \"o(„ÄíÔπè„Äí)o\",\n    \"(ÔºÉ`–î¬¥)\",\n    \"(„Éª`œâ¬¥„Éª)\",\n    \"( `Œµ¬¥ )\",\n    \"(Ôæí` Ôæõ ¬¥)\",\n    \"Œ£(‚ñº‚ñ°‚ñº„É°)\",\n    \"(“Ç `–∑¬¥ )\",\n    \"Ÿ©(‚ï¨ òÁõä ò‚ï¨)€∂\",\n    \"‚Üë_(Œ¶wŒ¶)Œ®\",\n    \"(Ôæâ‡≤•Áõä‡≤•)Ôæâ\",\n    \"(ÔºÉÔºûÔºú)\",\n    \"(ÔºõÔø£–îÔø£)\",\n    \"(Ôø¢_Ôø¢;)\",\n    \"(ÔºæÔºæÔºÉ)\",\n    \"(Ôø£Ô∏øÔø£)\",\n    \"„Éæ( Ôø£OÔø£)„ÉÑ\",\n    \"(·óí·ó£·óï)’û\",\n    \"(„Éé_<„ÄÇ)„Éæ(¬¥ ‚ñΩ ` )\",\n    \"„ÉΩ(Ôø£œâÔø£(„ÄÇ„ÄÇ )„Çù\",\n    \"(Ôæâ_Ôºõ)„Éæ(¬¥ ‚àÄ ` )\",\n    \"(¬¥-œâ-`( _ _ )\",\n    \"(‚åí_‚åí;)\",\n    \"(*/_Ôºº)\",\n    \"( ‚ó°‚Äø‚ó° *)\",\n    \"(//œâ//)\",\n    \"(Ôø£‚ñΩÔø£*)„Çû\",\n    \"(‚Äû‡≤°œâ‡≤°‚Äû)\",\n    \"(Ôæâ¬¥ –∑ `)„Éé\",\n    \"(‚ô°-_-‚ô°)\",\n    \"(‚îÄ‚Äø‚Äø‚îÄ)‚ô°\",\n    \"(¬¥ œâ `‚ô°)\",\n    \"(·É¶Àò‚å£Àò·É¶)\",\n    \"(¬¥‚Ä¢ œâ ‚Ä¢`) ‚ô°\",\n    \"‚ï∞(*¬¥Ô∏∂`*)‚ïØ‚ô°\",\n    \"(‚âß‚ó°‚â¶) ‚ô°\",\n    \"‚ô° (Àò‚ñΩÀò>‘Ö( Àò‚å£Àò)\",\n    \"œÉ(‚âßŒµ‚â¶œÉ) ‚ô°\",\n    \"(Àò‚àÄÀò)/(Œº‚ÄøŒº) ‚ù§\",\n    \"Œ£>‚Äï(„ÄÉ¬∞œâ¬∞„ÄÉ)‚ô°‚Üí\",\n    \"(* ^ œâ ^)\",\n    \"(o^‚ñΩ^o)\",\n    \"„ÉΩ(„Éª‚àÄ„Éª)Ôæâ\",\n    \"(oÔΩ•œâÔΩ•o)\",\n    \"(^‰∫∫^)\",\n    \"( ¬¥ œâ ` )\",\n    \"(¬¥‚Ä¢ œâ ‚Ä¢`)\",\n    \"‚ï∞(‚ñî‚àÄ‚ñî)‚ïØ\",\n    \"(‚úØ‚ó°‚úØ)\",\n    \"(‚åí‚Äø‚åí)\",\n    \"(*¬∞‚ñΩ¬∞*)\",\n    \"(¬¥ÔΩ°‚Ä¢ ·µï ‚Ä¢ÔΩ°`)\",\n    \"„ÉΩ(>‚àÄ<‚òÜ)„Éé\",\n    \"Ôºº(Ôø£‚ñΩÔø£)Ôºè\",\n    \"(oÀò‚ó°Àòo)\",\n    \"(‚ïØ‚úß‚ñΩ‚úß)‚ïØ\",\n    \"( ‚ÄæÃÅ ‚ó° ‚ÄæÃÅ )\",\n    \"(‡πëÀòÔ∏∂Àò‡πë)\",\n    \"(¬¥ÔΩ•·¥óÔΩ• ` )\",\n    \"( Õ°¬∞  ñÃØ Õ°¬∞)\",\n    \"( ‡∞† Õü ñ ‡∞†)\",\n    \"( ‡≤•  ñÃØ ‡≤•)\",\n    \"(‚âñ Õú ñ‚âñ)\",\n    \"„Éò(Ôø£œâÔø£„Éò)\",\n    \"(Ôæâ‚âß‚àÄ‚â¶)Ôæâ\",\n    \"‚îî(Ôø£-Ôø£‚îî))\",\n    \"‚îå(ÔºæÔºæ)‚îò\",\n    \"(^_^‚ô™)\",\n    \"(„ÄúÔø£‚ñ≥Ôø£)„Äú\",\n    \"(ÔΩ¢‚Ä¢ œâ ‚Ä¢)ÔΩ¢\",\n    \"( Àò …úÀò) ‚ô¨‚ô™‚ô´\",\n    \"( oÀò‚ó°Àòo) ‚îåiii‚îê\",\n    \"‚ô®o(>_<)o‚ô®\",\n    \"( „Éª„Éª)„Å§‚Äï{}@{}@{}-\",\n    \"(*¬¥–∑`)Âè£ÔæüÔΩ°ÔæüÂè£(„Éª‚àÄ„Éª )\",\n    \"( *^^)o‚àÄ*‚àÄo(^^* )\",\n    \"-‚óè‚óè‚óè-ÔΩÉ(„Éª„Éª )\",\n    \"(Ôæâ‚âß‚àÄ‚â¶)Ôæâ ‚Ä•‚Ä¶‚îÅ‚îÅ‚îÅ‚òÖ\",\n    \"‚ï∞( Õ°¬∞ Õú ñ Õ°¬∞ )„Å§‚îÄ‚îÄ‚òÜ*:„ÉªÔæü\",\n    \"(‚à©·Ñë_·Ñë)‚äÉ‚îÅ‚òÜÔæü*ÔΩ•ÔΩ°*ÔΩ•:‚â°( Œµ:)\",\n]\n\n\n@run_async\ndef react(update: Update, context: CallbackContext):\n    message = update.effective_message\n    react = random.choice(reactions)\n    if message.reply_to_message:\n        message.reply_to_message.reply_text(react)\n    else:\n        message.reply_text(react)\n\n\nREACT_HANDLER = DisableAbleCommandHandler(\"react\", react)\n\ndispatcher.add_handler(REACT_HANDLER)\n\n__command_list__ = [\"react\"]\n__handlers__ = [REACT_HANDLER]\n","size_bytes":5853},"sitaBot/modules/blacklist.py":{"content":"import html\nimport re\n\nfrom telegram import ParseMode, ChatPermissions\nfrom telegram.error import BadRequest\nfrom telegram.ext import CommandHandler, MessageHandler, Filters, run_async\nfrom telegram.utils.helpers import mention_html\n\nimport sitaBot.modules.sql.blacklist_sql as sql\nfrom sitaBot import dispatcher, LOGGER\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin, user_not_admin\nfrom sitaBot.modules.helper_funcs.extraction import extract_text\nfrom sitaBot.modules.helper_funcs.misc import split_message\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.warns import warn\nfrom sitaBot.modules.helper_funcs.string_handling import extract_time\nfrom sitaBot.modules.connection import connected\nfrom sitaBot.modules.sql.approve_sql import is_approved\nfrom sitaBot.modules.helper_funcs.alternate import send_message, typing_action\n\nBLACKLIST_GROUP = 11\n\n\n@run_async\n@user_admin\n@typing_action\ndef blacklist(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n    args = context.args\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=False)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if chat.type == \"private\":\n            return\n        chat_id = update.effective_chat.id\n        chat_name = chat.title\n\n    filter_list = \"Current blacklisted words in <b>{}</b>:\\n\".format(chat_name)\n\n    all_blacklisted = sql.get_chat_blacklist(chat_id)\n\n    if len(args) > 0 and args[0].lower() == \"copy\":\n        for trigger in all_blacklisted:\n            filter_list += \"<code>{}</code>\\n\".format(html.escape(trigger))\n    else:\n        for trigger in all_blacklisted:\n            filter_list += \" - <code>{}</code>\\n\".format(html.escape(trigger))\n\n    # for trigger in all_blacklisted:\n    #     filter_list += \" - <code>{}</code>\\n\".format(html.escape(trigger))\n\n    split_text = split_message(filter_list)\n    for text in split_text:\n        if filter_list == \"Current blacklisted words in <b>{}</b>:\\n\".format(\n            html.escape(chat_name)\n        ):\n            send_message(\n                update.effective_message,\n                \"No blacklisted words in <b>{}</b>!\".format(html.escape(chat_name)),\n                parse_mode=ParseMode.HTML,\n            )\n            return\n        send_message(update.effective_message, text, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@user_admin\n@typing_action\ndef add_blacklist(update, context):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n    words = msg.text.split(None, 1)\n\n    conn = connected(context.bot, update, chat, user.id)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            return\n        else:\n            chat_name = chat.title\n\n    if len(words) > 1:\n        text = words[1]\n        to_blacklist = list(\n            {trigger.strip() for trigger in text.split(\"\\n\") if trigger.strip()}\n        )\n        for trigger in to_blacklist:\n            sql.add_to_blacklist(chat_id, trigger.lower())\n\n        if len(to_blacklist) == 1:\n            send_message(\n                update.effective_message,\n                \"Added blacklist <code>{}</code> in chat: <b>{}</b>!\".format(\n                    html.escape(to_blacklist[0]), html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n\n        else:\n            send_message(\n                update.effective_message,\n                \"Added blacklist trigger: <code>{}</code> in <b>{}</b>!\".format(\n                    len(to_blacklist), html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n\n    else:\n        send_message(\n            update.effective_message,\n            \"Tell me which words you would like to add in blacklist.\",\n        )\n\n\n@run_async\n@user_admin\n@typing_action\ndef unblacklist(update, context):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n    words = msg.text.split(None, 1)\n\n    conn = connected(context.bot, update, chat, user.id)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            return\n        else:\n            chat_name = chat.title\n\n    if len(words) > 1:\n        text = words[1]\n        to_unblacklist = list(\n            {trigger.strip() for trigger in text.split(\"\\n\") if trigger.strip()}\n        )\n        successful = 0\n        for trigger in to_unblacklist:\n            success = sql.rm_from_blacklist(chat_id, trigger.lower())\n            if success:\n                successful += 1\n\n        if len(to_unblacklist) == 1:\n            if successful:\n                send_message(\n                    update.effective_message,\n                    \"Removed <code>{}</code> from blacklist in <b>{}</b>!\".format(\n                        html.escape(to_unblacklist[0]), html.escape(chat_name)\n                    ),\n                    parse_mode=ParseMode.HTML,\n                )\n            else:\n                send_message(\n                    update.effective_message, \"This is not a blacklist trigger!\"\n                )\n\n        elif successful == len(to_unblacklist):\n            send_message(\n                update.effective_message,\n                \"Removed <code>{}</code> from blacklist in <b>{}</b>!\".format(\n                    successful, html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n\n        elif not successful:\n            send_message(\n                update.effective_message,\n                \"None of these triggers exist so it can't be removed.\",\n                parse_mode=ParseMode.HTML,\n            )\n\n        else:\n            send_message(\n                update.effective_message,\n                \"Removed <code>{}</code> from blacklist. {} did not exist, \"\n                \"so were not removed.\".format(\n                    successful, len(to_unblacklist) - successful\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n    else:\n        send_message(\n            update.effective_message,\n            \"Tell me which words you would like to remove from blacklist!\",\n        )\n\n\n@run_async\n@loggable\n@user_admin\n@typing_action\ndef blacklist_mode(update, context):\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n    args = context.args\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message,\n                \"This command can be only used in group not in PM\",\n            )\n            return \"\"\n        chat = update.effective_chat\n        chat_id = update.effective_chat.id\n        chat_name = update.effective_message.chat.title\n\n    if args:\n        if args[0].lower() in [\"off\", \"nothing\", \"no\"]:\n            settypeblacklist = \"do nothing\"\n            sql.set_blacklist_strength(chat_id, 0, \"0\")\n        elif args[0].lower() in [\"del\", \"delete\"]:\n            settypeblacklist = \"delete blacklisted message\"\n            sql.set_blacklist_strength(chat_id, 1, \"0\")\n        elif args[0].lower() == \"warn\":\n            settypeblacklist = \"warn the sender\"\n            sql.set_blacklist_strength(chat_id, 2, \"0\")\n        elif args[0].lower() == \"mute\":\n            settypeblacklist = \"mute the sender\"\n            sql.set_blacklist_strength(chat_id, 3, \"0\")\n        elif args[0].lower() == \"kick\":\n            settypeblacklist = \"kick the sender\"\n            sql.set_blacklist_strength(chat_id, 4, \"0\")\n        elif args[0].lower() == \"ban\":\n            settypeblacklist = \"ban the sender\"\n            sql.set_blacklist_strength(chat_id, 5, \"0\")\n        elif args[0].lower() == \"tban\":\n            if len(args) == 1:\n                teks = \"\"\"It looks like you tried to set time value for blacklist but you didn't specified time; Try, `/blacklistmode tban <timevalue>`.\n\t\t\t\t\nExamples of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return \"\"\n            restime = extract_time(msg, args[1])\n            if not restime:\n                teks = \"\"\"Invalid time value!\nExample of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return \"\"\n            settypeblacklist = \"temporarily ban for {}\".format(args[1])\n            sql.set_blacklist_strength(chat_id, 6, str(args[1]))\n        elif args[0].lower() == \"tmute\":\n            if len(args) == 1:\n                teks = \"\"\"It looks like you tried to set time value for blacklist but you didn't specified  time; try, `/blacklistmode tmute <timevalue>`.\n\nExamples of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return \"\"\n            restime = extract_time(msg, args[1])\n            if not restime:\n                teks = \"\"\"Invalid time value!\nExamples of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return \"\"\n            settypeblacklist = \"temporarily mute for {}\".format(args[1])\n            sql.set_blacklist_strength(chat_id, 7, str(args[1]))\n        else:\n            send_message(\n                update.effective_message,\n                \"I only understand: off/del/warn/ban/kick/mute/tban/tmute!\",\n            )\n            return \"\"\n        if conn:\n            text = \"Changed blacklist mode: `{}` in *{}*!\".format(\n                settypeblacklist, chat_name\n            )\n        else:\n            text = \"Changed blacklist mode: `{}`!\".format(settypeblacklist)\n        send_message(update.effective_message, text, parse_mode=\"markdown\")\n        return (\n            \"<b>{}:</b>\\n\"\n            \"<b>Admin:</b> {}\\n\"\n            \"Changed the blacklist mode. will {}.\".format(\n                html.escape(chat.title),\n                mention_html(user.id, html.escape(user.first_name)),\n                settypeblacklist,\n            )\n        )\n    else:\n        getmode, getvalue = sql.get_blacklist_setting(chat.id)\n        if getmode == 0:\n            settypeblacklist = \"do nothing\"\n        elif getmode == 1:\n            settypeblacklist = \"delete\"\n        elif getmode == 2:\n            settypeblacklist = \"warn\"\n        elif getmode == 3:\n            settypeblacklist = \"mute\"\n        elif getmode == 4:\n            settypeblacklist = \"kick\"\n        elif getmode == 5:\n            settypeblacklist = \"ban\"\n        elif getmode == 6:\n            settypeblacklist = \"temporarily ban for {}\".format(getvalue)\n        elif getmode == 7:\n            settypeblacklist = \"temporarily mute for {}\".format(getvalue)\n        if conn:\n            text = \"Current blacklistmode: *{}* in *{}*.\".format(\n                settypeblacklist, chat_name\n            )\n        else:\n            text = \"Current blacklistmode: *{}*.\".format(settypeblacklist)\n        send_message(update.effective_message, text, parse_mode=ParseMode.MARKDOWN)\n    return \"\"\n\n\ndef findall(p, s):\n    i = s.find(p)\n    while i != -1:\n        yield i\n        i = s.find(p, i + 1)\n\n\n@run_async\n@user_not_admin\ndef del_blacklist(update, context):\n    chat = update.effective_chat\n    message = update.effective_message\n    user = update.effective_user\n    bot = context.bot\n    to_match = extract_text(message)\n    if not to_match:\n        return\n    if is_approved(chat.id, user.id):\n        return\n    getmode, value = sql.get_blacklist_setting(chat.id)\n\n    chat_filters = sql.get_chat_blacklist(chat.id)\n    for trigger in chat_filters:\n        pattern = r\"( |^|[^\\w])\" + re.escape(trigger) + r\"( |$|[^\\w])\"\n        if re.search(pattern, to_match, flags=re.IGNORECASE):\n            try:\n                if getmode == 0:\n                    return\n                elif getmode == 1:\n                    try:\n                        message.delete()\n                    except BadRequest:\n                        pass\n                elif getmode == 2:\n                    try:\n                        message.delete()\n                    except BadRequest:\n                        pass\n                    warn(\n                        update.effective_user,\n                        chat,\n                        (\"Using blacklisted trigger: {}\".format(trigger)),\n                        message,\n                        update.effective_user,\n                    )\n                    return\n                elif getmode == 3:\n                    message.delete()\n                    bot.restrict_chat_member(\n                        chat.id,\n                        update.effective_user.id,\n                        permissions=ChatPermissions(can_send_messages=False),\n                    )\n                    bot.sendMessage(\n                        chat.id,\n                        f\"Muted {user.first_name} for using Blacklisted word: {trigger}!\",\n                    )\n                    return\n                elif getmode == 4:\n                    message.delete()\n                    res = chat.unban_member(update.effective_user.id)\n                    if res:\n                        bot.sendMessage(\n                            chat.id,\n                            f\"Kicked {user.first_name} for using Blacklisted word: {trigger}!\",\n                        )\n                    return\n                elif getmode == 5:\n                    message.delete()\n                    chat.kick_member(user.id)\n                    bot.sendMessage(\n                        chat.id,\n                        f\"Banned {user.first_name} for using Blacklisted word: {trigger}\",\n                    )\n                    return\n                elif getmode == 6:\n                    message.delete()\n                    bantime = extract_time(message, value)\n                    chat.kick_member(user.id, until_date=bantime)\n                    bot.sendMessage(\n                        chat.id,\n                        f\"Banned {user.first_name} until '{value}' for using Blacklisted word: {trigger}!\",\n                    )\n                    return\n                elif getmode == 7:\n                    message.delete()\n                    mutetime = extract_time(message, value)\n                    bot.restrict_chat_member(\n                        chat.id,\n                        user.id,\n                        until_date=mutetime,\n                        permissions=ChatPermissions(can_send_messages=False),\n                    )\n                    bot.sendMessage(\n                        chat.id,\n                        f\"Muted {user.first_name} until '{value}' for using Blacklisted word: {trigger}!\",\n                    )\n                    return\n            except BadRequest as excp:\n                if excp.message != \"Message to delete not found\":\n                    LOGGER.exception(\"Error while deleting blacklist message.\")\n            break\n\n\ndef __import_data__(chat_id, data):\n    # set chat blacklist\n    blacklist = data.get(\"blacklist\", {})\n    for trigger in blacklist:\n        sql.add_to_blacklist(chat_id, trigger)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    blacklisted = sql.num_blacklist_chat_filters(chat_id)\n    return \"There are {} blacklisted words.\".format(blacklisted)\n\n\ndef __stats__():\n    return \"‚Ä¢ {} blacklist triggers, across {} chats.\".format(\n        sql.num_blacklist_filters(), sql.num_blacklist_filter_chats()\n    )\n\n\n__mod_name__ = \"BlackList\"\n\n__help__ = \"\"\"\n\nBlacklists are used to stop certain triggers from being said in a group. Any time the trigger is mentioned, the message will immediately be deleted. A good combo is sometimes to pair this up with warn filters!\n\n*NOTE*: Blacklists do not affect group admins.\n\n ‚ùç /blacklist*:* View the current blacklisted words.\n\nAdmin only:\n ‚ùç /addblacklist <triggers>*:* Add a trigger to the blacklist. Each line is considered one trigger, so using different lines will allow you to add multiple triggers.\n ‚ùç /unblacklist <triggers>*:* Remove triggers from the blacklist. Same newline logic applies here, so you can remove multiple triggers at once.\n ‚ùç /blacklistmode <off/del/warn/ban/kick/mute/tban/tmute>*:* Action to perform when someone sends blacklisted words.\n\nBlacklist sticker is used to stop certain stickers. Whenever a sticker is sent, the message will be deleted immediately.\n*NOTE:* Blacklist stickers do not affect the group admin\n ‚ùç /blsticker*:* See current blacklisted sticker\n*Only admin:*\n ‚ùç /addblsticker <sticker link>*:* Add the sticker trigger to the black list. Can be added via reply sticker\n ‚ùç /unblsticker <sticker link>*:* Remove triggers from blacklist. The same newline logic applies here, so you can delete multiple triggers at once\n ‚ùç /rmblsticker <sticker link>*:* Same as above\n ‚ùç /blstickermode <ban/tban/mute/tmute>*:* sets up a default action on what to do if users use blacklisted stickers\nNote:\n ‚ùç <sticker link> can be `https://t.me/addstickers/<sticker>` or just `<sticker>` or reply to the sticker message\n\"\"\"\n\nBLACKLIST_HANDLER = DisableAbleCommandHandler(\n    \"blacklist\", blacklist, pass_args=True, admin_ok=True\n)\nADD_BLACKLIST_HANDLER = CommandHandler(\"addblacklist\", add_blacklist)\nUNBLACKLIST_HANDLER = CommandHandler(\"unblacklist\", unblacklist)\nBLACKLISTMODE_HANDLER = CommandHandler(\"blacklistmode\", blacklist_mode, pass_args=True)\nBLACKLIST_DEL_HANDLER = MessageHandler(\n    (Filters.text | Filters.command | Filters.sticker | Filters.photo) & Filters.group,\n    del_blacklist,\n    allow_edit=True,\n)\n\ndispatcher.add_handler(BLACKLIST_HANDLER)\ndispatcher.add_handler(ADD_BLACKLIST_HANDLER)\ndispatcher.add_handler(UNBLACKLIST_HANDLER)\ndispatcher.add_handler(BLACKLISTMODE_HANDLER)\ndispatcher.add_handler(BLACKLIST_DEL_HANDLER, group=BLACKLIST_GROUP)\n\n__handlers__ = [\n    BLACKLIST_HANDLER,\n    ADD_BLACKLIST_HANDLER,\n    UNBLACKLIST_HANDLER,\n    BLACKLISTMODE_HANDLER,\n    (BLACKLIST_DEL_HANDLER, BLACKLIST_GROUP),\n]\n","size_bytes":18800},"sitaBot/modules/get_common_chats.py":{"content":"import os\nfrom time import sleep\n\nfrom sitaBot import OWNER_ID, dispatcher\nfrom sitaBot.modules.helper_funcs.extraction import extract_user\nfrom sitaBot.modules.sql.users_sql import get_user_com_chats\nfrom telegram import Update\nfrom telegram.error import BadRequest, RetryAfter, Unauthorized\nfrom telegram.ext import CallbackContext, CommandHandler, Filters\nfrom telegram.ext.dispatcher import run_async\n\n\n@run_async\ndef get_user_common_chats(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    msg = update.effective_message\n    user = extract_user(msg, args)\n    if not user:\n        msg.reply_text(\"I share no common chats with the void.\")\n        return\n    common_list = get_user_com_chats(user)\n    if not common_list:\n        msg.reply_text(\"No common chats with this user!\")\n        return\n    name = bot.get_chat(user).first_name\n    text = f\"<b>Common chats with {name}</b>\\n\"\n    for chat in common_list:\n        try:\n            chat_name = bot.get_chat(chat).title\n            sleep(0.3)\n            text += f\"‚Ä¢ <code>{chat_name}</code>\\n\"\n        except BadRequest:\n            pass\n        except Unauthorized:\n            pass\n        except RetryAfter as e:\n            sleep(e.retry_after)\n\n    if len(text) < 4096:\n        msg.reply_text(text, parse_mode=\"HTML\")\n    else:\n        with open(\"common_chats.txt\", \"w\") as f:\n            f.write(text)\n        with open(\"common_chats.txt\", \"rb\") as f:\n            msg.reply_document(f)\n        os.remove(\"common_chats.txt\")\n\n\nCOMMON_CHATS_HANDLER = CommandHandler(\n    \"getchats\", get_user_common_chats, filters=Filters.user(OWNER_ID)\n)\n\ndispatcher.add_handler(COMMON_CHATS_HANDLER)\n","size_bytes":1688},"sitaBot/modules/approve.py":{"content":"import html\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot import dispatcher, DRAGONS\nfrom sitaBot.modules.helper_funcs.extraction import extract_user\nfrom telegram.ext import CallbackContext, CallbackQueryHandler, Filters, run_async\nimport sitaBot.modules.sql.approve_sql as sql\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.log_channel import loggable\nfrom telegram import ParseMode, InlineKeyboardMarkup, InlineKeyboardButton, Update\nfrom telegram.utils.helpers import mention_html\nfrom telegram.error import BadRequest\n@loggable\n@user_admin\n@run_async\ndef approve(update, context):\n    message = update.effective_message\n    chat_title = message.chat.title\n    chat = update.effective_chat\n    args = context.args\n    user = update.effective_user\n    user_id = extract_user(message, args)\n    if not user_id:\n        message.reply_text(\n            \"I don't know who you're talking about, you're going to need to specify a user!\"\n        )\n        return \"\"\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest:\n        return \"\"\n    if member.status == \"administrator\" or member.status == \"creator\":\n        message.reply_text(\n            \"User is already admin - locks, blocklists, and antiflood already don't apply to them.\"\n        )\n        return \"\"\n    if sql.is_approved(message.chat_id, user_id):\n        message.reply_text(\n            f\"[{member.user['first_name']}](tg://user?id={member.user['id']}) is already approved in {chat_title}\",\n            parse_mode=ParseMode.MARKDOWN,\n        )\n        return \"\"\n    sql.approve(message.chat_id, user_id)\n    message.reply_text(\n        f\"[{member.user['first_name']}](tg://user?id={member.user['id']}) has been approved in {chat_title}! They will now be ignored by automated admin actions like locks, blocklists, and antiflood.\",\n        parse_mode=ParseMode.MARKDOWN,\n    )\n    log_message = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#APPROVED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, member.user.first_name)}\"\n    )\n\n    return log_message\n\n\n@loggable\n@user_admin\n@run_async\ndef disapprove(update, context):\n    message = update.effective_message\n    chat_title = message.chat.title\n    chat = update.effective_chat\n    args = context.args\n    user = update.effective_user\n    user_id = extract_user(message, args)\n    if not user_id:\n        message.reply_text(\n            \"I don't know who you're talking about, you're going to need to specify a user!\"\n        )\n        return \"\"\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest:\n        return \"\"\n    if member.status == \"administrator\" or member.status == \"creator\":\n        message.reply_text(\"This user is an admin, they can't be unapproved.\")\n        return \"\"\n    if not sql.is_approved(message.chat_id, user_id):\n        message.reply_text(f\"{member.user['first_name']} isn't approved yet!\")\n        return \"\"\n    sql.disapprove(message.chat_id, user_id)\n    message.reply_text(\n        f\"{member.user['first_name']} is no longer approved in {chat_title}.\"\n    )\n    log_message = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#UNAPPROVED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, member.user.first_name)}\"\n    )\n\n    return log_message\n\n\n@user_admin\n@run_async\ndef approved(update, context):\n    message = update.effective_message\n    chat_title = message.chat.title\n    chat = update.effective_chat\n    msg = \"The following users are approved.\\n\"\n    approved_users = sql.list_approved(message.chat_id)\n    for i in approved_users:\n        member = chat.get_member(int(i.user_id))\n        msg += f\"- `{i.user_id}`: {member.user['first_name']}\\n\"\n    if msg.endswith(\"approved.\\n\"):\n        message.reply_text(f\"No users are approved in {chat_title}.\")\n        return \"\"\n    else:\n        message.reply_text(msg, parse_mode=ParseMode.MARKDOWN)\n\n\n@user_admin\n@run_async\ndef approval(update, context):\n    message = update.effective_message\n    chat = update.effective_chat\n    args = context.args\n    user_id = extract_user(message, args)\n    member = chat.get_member(int(user_id))\n    if not user_id:\n        message.reply_text(\n            \"I don't know who you're talking about, you're going to need to specify a user!\"\n        )\n        return \"\"\n    if sql.is_approved(message.chat_id, user_id):\n        message.reply_text(\n            f\"{member.user['first_name']} is an approved user. Locks, antiflood, and blocklists won't apply to them.\"\n        )\n    else:\n        message.reply_text(\n            f\"{member.user['first_name']} is not an approved user. They are affected by normal commands.\"\n        )\n\n\n@run_async\ndef unapproveall(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    user = update.effective_user\n    member = chat.get_member(user.id)\n    if member.status != \"creator\" and user.id not in DRAGONS:\n        update.effective_message.reply_text(\n            \"Only the chat owner can unapprove all users at once.\"\n        )\n    else:\n        buttons = InlineKeyboardMarkup(\n            [\n                [\n                    InlineKeyboardButton(\n                        text=\"Unapprove all users\", callback_data=\"unapproveall_user\"\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        text=\"Cancel\", callback_data=\"unapproveall_cancel\"\n                    )\n                ],\n            ]\n        )\n        update.effective_message.reply_text(\n            f\"Are you sure you would like to unapprove ALL users in {chat.title}? This action cannot be undone.\",\n            reply_markup=buttons,\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n\n@run_async\ndef unapproveall_btn(update: Update, context: CallbackContext):\n    query = update.callback_query\n    chat = update.effective_chat\n    message = update.effective_message\n    member = chat.get_member(query.from_user.id)\n    if query.data == \"unapproveall_user\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            users = []\n            approved_users = sql.list_approved(chat.id)\n            for i in approved_users:\n                users.append(int(i.user_id))\n            for user_id in users:\n                sql.disapprove(chat.id, user_id)\n\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n    elif query.data == \"unapproveall_cancel\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            message.edit_text(\"Removing of all approved users has been cancelled.\")\n            return \"\"\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n\n\n__help__ = \"\"\"\nSometimes, you might trust a user not to send unwanted content.\nMaybe not enough to make them admin, but you might be ok with locks, blacklists, and antiflood not applying to them.\nThat's what approvals are for - approve of trustworthy users to allow them to send \n*Admin commands:*\n- `/approval`*:* Check a user's approval status in this chat.\n- `/approve`*:* Approve of a user. Locks, blacklists, and antiflood won't apply to them anymore.\n- `/unapprove`*:* Unapprove of a user. They will now be subject to locks, blacklists, and antiflood again.\n- `/approved`*:* List all approved users.\n- `/unapproveall`*:* Unapprove *ALL* users in a chat. This cannot be undone.\n\"\"\"\n\nAPPROVE = DisableAbleCommandHandler(\"approve\", approve)\nDISAPPROVE = DisableAbleCommandHandler(\"unapprove\", disapprove)\nAPPROVED = DisableAbleCommandHandler(\"approved\", approved)\nAPPROVAL = DisableAbleCommandHandler(\"approval\", approval)\nUNAPPROVEALL = DisableAbleCommandHandler(\"unapproveall\", unapproveall)\nUNAPPROVEALL_BTN = CallbackQueryHandler(unapproveall_btn, pattern=r\"unapproveall_.*\")\n\ndispatcher.add_handler(APPROVE)\ndispatcher.add_handler(DISAPPROVE)\ndispatcher.add_handler(APPROVED)\ndispatcher.add_handler(APPROVAL)\ndispatcher.add_handler(UNAPPROVEALL)\ndispatcher.add_handler(UNAPPROVEALL_BTN)\n\n__mod_name__ = \"Approvals\"\n__command_list__ = [\"approve\", \"unapprove\", \"approved\", \"approval\"]\n__handlers__ = [APPROVE, DISAPPROVE, APPROVED, APPROVAL]","size_bytes":8583},"sitaBot/modules/sql/rules_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String, UnicodeText, distinct, func\n\n\nclass Rules(BASE):\n    __tablename__ = \"rules\"\n    chat_id = Column(String(14), primary_key=True)\n    rules = Column(UnicodeText, default=\"\")\n\n    def __init__(self, chat_id):\n        self.chat_id = chat_id\n\n    def __repr__(self):\n        return \"<Chat {} rules: {}>\".format(self.chat_id, self.rules)\n\n\nRules.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\n\n\ndef set_rules(chat_id, rules_text):\n    with INSERTION_LOCK:\n        rules = SESSION.query(Rules).get(str(chat_id))\n        if not rules:\n            rules = Rules(str(chat_id))\n        rules.rules = rules_text\n\n        SESSION.add(rules)\n        SESSION.commit()\n\n\ndef get_rules(chat_id):\n    rules = SESSION.query(Rules).get(str(chat_id))\n    ret = \"\"\n    if rules:\n        ret = rules.rules\n\n    SESSION.close()\n    return ret\n\n\ndef num_chats():\n    try:\n        return SESSION.query(func.count(distinct(Rules.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with INSERTION_LOCK:\n        chat = SESSION.query(Rules).get(str(old_chat_id))\n        if chat:\n            chat.chat_id = str(new_chat_id)\n        SESSION.commit()\n","size_bytes":1300},"sitaBot/modules/blacklistusers.py":{"content":"# Module to blacklist users and prevent them from using commands by @TheRealPhoenix\nimport html\nimport sitaBot.modules.sql.blacklistusers_sql as sql\nfrom sitaBot import (\n    DEV_USERS,\n    OWNER_ID,\n    DRAGONS,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    dispatcher,\n)\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_user,\n    extract_user_and_text,\n)\nfrom sitaBot.modules.log_channel import gloggable\nfrom telegram import ParseMode, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\nfrom telegram.utils.helpers import mention_html\n\nBLACKLISTWHITELIST = [OWNER_ID] + DEV_USERS + DRAGONS + WOLVES + DEMONS\nBLABLEUSERS = [OWNER_ID] + DEV_USERS\n\n\n@run_async\n@dev_plus\n@gloggable\ndef bl_user(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    bot, args = context.bot, context.args\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return \"\"\n\n    if user_id == bot.id:\n        message.reply_text(\"How am I supposed to do my work if I am ignoring myself?\")\n        return \"\"\n\n    if user_id in BLACKLISTWHITELIST:\n        message.reply_text(\"No!\\nNoticing Disasters is my job.\")\n        return \"\"\n\n    try:\n        target_user = bot.get_chat(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user.\")\n            return \"\"\n        else:\n            raise\n\n    sql.blacklist_user(user_id, reason)\n    message.reply_text(\"I shall ignore the existence of this user!\")\n    log_message = (\n        f\"#BLACKLIST\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(target_user.id, html.escape(target_user.first_name))}\"\n    )\n    if reason:\n        log_message += f\"\\n<b>Reason:</b> {reason}\"\n\n    return log_message\n\n\n@run_async\n@dev_plus\n@gloggable\ndef unbl_user(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return \"\"\n\n    if user_id == bot.id:\n        message.reply_text(\"I always notice myself.\")\n        return \"\"\n\n    try:\n        target_user = bot.get_chat(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user.\")\n            return \"\"\n        else:\n            raise\n\n    if sql.is_user_blacklisted(user_id):\n\n        sql.unblacklist_user(user_id)\n        message.reply_text(\"*notices user*\")\n        log_message = (\n            f\"#UNBLACKLIST\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(target_user.id, html.escape(target_user.first_name))}\"\n        )\n\n        return log_message\n\n    else:\n        message.reply_text(\"I am not ignoring them at all though!\")\n        return \"\"\n\n\n@run_async\n@dev_plus\ndef bl_users(update: Update, context: CallbackContext):\n    users = []\n    bot = context.bot\n    for each_user in sql.BLACKLIST_USERS:\n        user = bot.get_chat(each_user)\n        reason = sql.get_reason(each_user)\n\n        if reason:\n            users.append(\n                f\"‚Ä¢ {mention_html(user.id, html.escape(user.first_name))} :- {reason}\"\n            )\n        else:\n            users.append(f\"‚Ä¢ {mention_html(user.id, html.escape(user.first_name))}\")\n\n    message = \"<b>Blacklisted Users</b>\\n\"\n    if not users:\n        message += \"Noone is being ignored as of yet.\"\n    else:\n        message += \"\\n\".join(users)\n\n    update.effective_message.reply_text(message, parse_mode=ParseMode.HTML)\n\n\ndef __user_info__(user_id):\n    is_blacklisted = sql.is_user_blacklisted(user_id)\n\n    text = \"Blacklisted: <b>{}</b>\"\n    if user_id in [777000, 1087968824]:\n        return \"\"\n    if user_id == dispatcher.bot.id:\n        return \"\"\n    if int(user_id) in DRAGONS + TIGERS + WOLVES:\n        return \"\"\n    if is_blacklisted:\n        text = text.format(\"Yes\")\n        reason = sql.get_reason(user_id)\n        if reason:\n            text += f\"\\nReason: <code>{reason}</code>\"\n    else:\n        text = text.format(\"No\")\n\n    return text\n\n\nBL_HANDLER = CommandHandler(\"ignore\", bl_user)\nUNBL_HANDLER = CommandHandler(\"notice\", unbl_user)\nBLUSERS_HANDLER = CommandHandler(\"ignoredlist\", bl_users)\n\ndispatcher.add_handler(BL_HANDLER)\ndispatcher.add_handler(UNBL_HANDLER)\ndispatcher.add_handler(BLUSERS_HANDLER)\n\n__mod_name__ = \"Blacklisting Users\"\n__handlers__ = [BL_HANDLER, UNBL_HANDLER, BLUSERS_HANDLER]\n","size_bytes":4894},"sitaBot/modules/ping.py":{"content":"import time\nfrom typing import List\n\nimport requests\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\n\nfrom sitaBot import StartTime, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import sudo_plus\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\n\nsites_list = {\n    \"Telegram\": \"https://api.telegram.org\",\n    \"Kaizoku\": \"https://animekaizoku.com\",\n    \"Kayo\": \"https://animekayo.com\",\n    \"Jikan\": \"https://api.jikan.moe/v3\",\n}\n\n\ndef get_readable_time(seconds: int) -> str:\n    count = 0\n    ping_time = \"\"\n    time_list = []\n    time_suffix_list = [\"s\", \"m\", \"h\", \"days\"]\n\n    while count < 4:\n        count += 1\n        if count < 3:\n            remainder, result = divmod(seconds, 60)\n        else:\n            remainder, result = divmod(seconds, 24)\n        if seconds == 0 and remainder == 0:\n            break\n        time_list.append(int(result))\n        seconds = int(remainder)\n\n    for x in range(len(time_list)):\n        time_list[x] = str(time_list[x]) + time_suffix_list[x]\n    if len(time_list) == 4:\n        ping_time += time_list.pop() + \", \"\n\n    time_list.reverse()\n    ping_time += \":\".join(time_list)\n\n    return ping_time\n\n\ndef ping_func(to_ping: List[str]) -> List[str]:\n    ping_result = []\n\n    for each_ping in to_ping:\n\n        start_time = time.time()\n        site_to_ping = sites_list[each_ping]\n        r = requests.get(site_to_ping)\n        end_time = time.time()\n        ping_time = str(round((end_time - start_time), 2)) + \"s\"\n\n        pinged_site = f\"<b>{each_ping}</b>\"\n\n        if each_ping == \"Kaizoku\" or each_ping == \"Kayo\":\n            pinged_site = f'<a href=\"{sites_list[each_ping]}\">{each_ping}</a>'\n            ping_time = f\"<code>{ping_time} (Status: {r.status_code})</code>\"\n\n        ping_text = f\"{pinged_site}: <code>{ping_time}</code>\"\n        ping_result.append(ping_text)\n\n    return ping_result\n\n\n@run_async\n@sudo_plus\ndef ping(update: Update, context: CallbackContext):\n    msg = update.effective_message\n\n    start_time = time.time()\n    message = msg.reply_text(\"Pinging...\")\n    end_time = time.time()\n    telegram_ping = str(round((end_time - start_time) * 1000, 3)) + \" ms\"\n    uptime = get_readable_time((time.time() - StartTime))\n\n    message.edit_text(\n        \"PONG!!\\n\"\n        \"<b>Time Taken:</b> <code>{}</code>\\n\"\n        \"<b>Service uptime:</b> <code>{}</code>\".format(telegram_ping, uptime),\n        parse_mode=ParseMode.HTML,\n    )\n\n\n@run_async\n@sudo_plus\ndef pingall(update: Update, context: CallbackContext):\n    to_ping = [\"Kaizoku\", \"Kayo\", \"Telegram\", \"Jikan\"]\n    pinged_list = ping_func(to_ping)\n    pinged_list.insert(2, \"\")\n    uptime = get_readable_time((time.time() - StartTime))\n\n    reply_msg = \"‚è±Ping results are:\\n\"\n    reply_msg += \"\\n\".join(pinged_list)\n    reply_msg += \"\\n<b>Service uptime:</b> <code>{}</code>\".format(uptime)\n\n    update.effective_message.reply_text(\n        reply_msg, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n    )\n\n\nPING_HANDLER = DisableAbleCommandHandler(\"ping\", ping)\nPINGALL_HANDLER = DisableAbleCommandHandler(\"pingall\", pingall)\n\ndispatcher.add_handler(PING_HANDLER)\ndispatcher.add_handler(PINGALL_HANDLER)\n\n__command_list__ = [\"ping\", \"pingall\"]\n__handlers__ = [PING_HANDLER, PINGALL_HANDLER]\n","size_bytes":3293},"sitaBot/modules/__speachtotext.py":{"content":"from sitaBot import telethn as tbot\nimport os\nimport urllib.request\nfrom datetime import datetime\nfrom typing import List\nfrom typing import Optional\nimport requests\nfrom telethon import *\nfrom telethon import events\nfrom telethon.tl import functions\nfrom telethon.tl import types\nfrom telethon.tl.types import *\n\nfrom sitaBot import *\nfrom sitaBot.events import register\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n        return isinstance(\n            (\n                await tbot(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerUser):\n        return True\n\n\n@register(pattern=\"^/stt$\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    if event.is_group:\n     if not (await is_register_admin(event.input_chat, event.message.sender_id)):\n       await event.reply(\"üö® Need Admin Pewer.. You can't use this command.. But you can use in my pm\")\n       return\n\n    start = datetime.now()\n    if not os.path.isdir(TEMP_DOWNLOAD_DIRECTORY):\n        os.makedirs(TEMP_DOWNLOAD_DIRECTORY)\n\n    if event.reply_to_msg_id:\n        previous_message = await event.get_reply_message()\n        required_file_name = await event.client.download_media(\n            previous_message, TEMP_DOWNLOAD_DIRECTORY\n        )\n        if IBM_WATSON_CRED_URL is None or IBM_WATSON_CRED_PASSWORD is None:\n            await event.reply(\n                \"You need to set the required ENV variables for this module. \\nModule stopping\"\n            )\n        else:\n            # await event.reply(\"Starting analysis\")\n            headers = {\n                \"Content-Type\": previous_message.media.document.mime_type,\n            }\n            data = open(required_file_name, \"rb\").read()\n            response = requests.post(\n                IBM_WATSON_CRED_URL + \"/v1/recognize\",\n                headers=headers,\n                data=data,\n                auth=(\"apikey\", IBM_WATSON_CRED_PASSWORD),\n            )\n            r = response.json()\n            if \"results\" in r:\n                # process the json to appropriate string format\n                results = r[\"results\"]\n                transcript_response = \"\"\n                transcript_confidence = \"\"\n                for alternative in results:\n                    alternatives = alternative[\"alternatives\"][0]\n                    transcript_response += \" \" + str(alternatives[\"transcript\"])\n                    transcript_confidence += (\n                        \" \" + str(alternatives[\"confidence\"]) + \" + \"\n                    )\n                end = datetime.now()\n                ms = (end - start).seconds\n                if transcript_response != \"\":\n                    string_to_show = \"TRANSCRIPT: `{}`\\nTime Taken: {} seconds\\nConfidence: `{}`\".format(\n                        transcript_response, ms, transcript_confidence\n                    )\n                else:\n                    string_to_show = \"TRANSCRIPT: `Nil`\\nTime Taken: {} seconds\\n\\n**No Results Found**\".format(\n                        ms\n                    )\n                await event.reply(string_to_show)\n            else:\n                await event.reply(r[\"error\"])\n            # now, remove the temporary file\n            os.remove(required_file_name)\n    else:\n        await event.reply(\"Reply to a voice message, to get the text out of it.\")\n\n\n__help__ = \"\"\"\nI can convert text to voice and voice to text..\n ‚ùç /tts <lang code>*:* Reply to any message to get text to speech output\n ‚ùç /stt*:* Type in reply to a voice message(support english only) to extract text from it.\n*Language Codes*\n`af,am,ar,az,be,bg,bn,bs,ca,ceb,co,cs,cy,da,de,el,en,eo,es,\net,eu,fa,fi,fr,fy,ga,gd,gl,gu,ha,haw,hi,hmn,hr,ht,hu,hy,\nid,ig,is,it,iw,ja,jw,ka,kk,km,kn,ko,ku,ky,la,lb,lo,lt,lv,mg,mi,mk,\nml,mn,mr,ms,mt,my,ne,nl,no,ny,pa,pl,ps,pt,ro,ru,sd,si,sk,sl,\nsm,sn,so,sq,sr,st,su,sv,sw,ta,te,tg,th,tl,tr,uk,ur,uz,\nvi,xh,yi,yo,zh,zh_CN,zh_TW,zu`\n\"\"\"\n\n__mod_name__ = \"Speach\"\n","size_bytes":4116},"sitaBot/utils/__init__.py":{"content":"from .progress import progress\nfrom .tools import human_to_bytes, humanbytes, md5, time_formatter\n","size_bytes":98},"sitaBot/modules/ud.py":{"content":"import requests\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\n\n\n@run_async\ndef ud(update: Update, context: CallbackContext):\n    message = update.effective_message\n    text = message.text[len(\"/ud \") :]\n    results = requests.get(\n        f\"https://api.urbandictionary.com/v0/define?term={text}\"\n    ).json()\n    try:\n        reply_text = f'*{text}*\\n\\n{results[\"list\"][0][\"definition\"]}\\n\\n_{results[\"list\"][0][\"example\"]}_'\n    except:\n        reply_text = \"No results found.\"\n    message.reply_text(reply_text, parse_mode=ParseMode.MARKDOWN)\n\n\nUD_HANDLER = DisableAbleCommandHandler([\"ud\"], ud)\n\ndispatcher.add_handler(UD_HANDLER)\n\n__command_list__ = [\"ud\"]\n__handlers__ = [UD_HANDLER]\n","size_bytes":827},"sitaBot/modules/gettime.py":{"content":"import datetime\nfrom typing import List\n\nimport requests\nfrom sitaBot import TIME_API_KEY, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\n\n\ndef generate_time(to_find: str, findtype: List[str]) -> str:\n    data = requests.get(\n        f\"https://api.timezonedb.com/v2.1/list-time-zone\"\n        f\"?key={TIME_API_KEY}\"\n        f\"&format=json\"\n        f\"&fields=countryCode,countryName,zoneName,gmtOffset,timestamp,dst\"\n    ).json()\n\n    for zone in data[\"zones\"]:\n        for eachtype in findtype:\n            if to_find in zone[eachtype].lower():\n                country_name = zone[\"countryName\"]\n                country_zone = zone[\"zoneName\"]\n                country_code = zone[\"countryCode\"]\n\n                if zone[\"dst\"] == 1:\n                    daylight_saving = \"Yes\"\n                else:\n                    daylight_saving = \"No\"\n\n                date_fmt = r\"%d-%m-%Y\"\n                time_fmt = r\"%H:%M:%S\"\n                day_fmt = r\"%A\"\n                gmt_offset = zone[\"gmtOffset\"]\n                timestamp = datetime.datetime.now(\n                    datetime.timezone.utc\n                ) + datetime.timedelta(seconds=gmt_offset)\n                current_date = timestamp.strftime(date_fmt)\n                current_time = timestamp.strftime(time_fmt)\n                current_day = timestamp.strftime(day_fmt)\n\n                break\n\n    try:\n        result = (\n            f\"<b>Country:</b> <code>{country_name}</code>\\n\"\n            f\"<b>Zone Name:</b> <code>{country_zone}</code>\\n\"\n            f\"<b>Country Code:</b> <code>{country_code}</code>\\n\"\n            f\"<b>Daylight saving:</b> <code>{daylight_saving}</code>\\n\"\n            f\"<b>Day:</b> <code>{current_day}</code>\\n\"\n            f\"<b>Current Time:</b> <code>{current_time}</code>\\n\"\n            f\"<b>Current Date:</b> <code>{current_date}</code>\\n\"\n            '<b>Timezones:</b> <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">List here</a>'\n        )\n    except:\n        result = None\n\n    return result\n\n\n@run_async\ndef gettime(update: Update, context: CallbackContext):\n    message = update.effective_message\n\n    try:\n        query = message.text.strip().split(\" \", 1)[1]\n    except:\n        message.reply_text(\"Provide a country name/abbreviation/timezone to find.\")\n        return\n    send_message = message.reply_text(\n        f\"Finding timezone info for <b>{query}</b>\", parse_mode=ParseMode.HTML\n    )\n\n    query_timezone = query.lower()\n    if len(query_timezone) == 2:\n        result = generate_time(query_timezone, [\"countryCode\"])\n    else:\n        result = generate_time(query_timezone, [\"zoneName\", \"countryName\"])\n\n    if not result:\n        send_message.edit_text(\n            f\"Timezone info not available for <b>{query}</b>\\n\"\n            '<b>All Timezones:</b> <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">List here</a>',\n            parse_mode=ParseMode.HTML,\n            disable_web_page_preview=True,\n        )\n        return\n\n    send_message.edit_text(\n        result, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n    )\n\n\nTIME_HANDLER = DisableAbleCommandHandler(\"time\", gettime)\n\ndispatcher.add_handler(TIME_HANDLER)\n\n__mod_name__ = \"TIME\"\n__command_list__ = [\"time\"]\n__handlers__ = [TIME_HANDLER]\n","size_bytes":3385},"sitaBot/modules/__aimultilanguage.py":{"content":"import re\n\nimport emoji\ntry:\n    from emoji import EMOJI_DATA as EMOJI_MAP\nexcept Exception:\n    try:\n        from emoji import UNICODE_EMOJI as EMOJI_MAP\n    except Exception:\n        EMOJI_MAP = {}\n\nIBM_WATSON_CRED_URL = \"https://api.us-south.speech-to-text.watson.cloud.ibm.com/instances/bd6b59ba-3134-4dd4-aff2-49a79641ea15\"\nIBM_WATSON_CRED_PASSWORD = \"UQ1MtTzZhEsMGK094klnfa-7y_4MCpJY1yhd52MXOo3Y\"\nurl = \"https://acobot-brainshop-ai-v1.p.rapidapi.com/get\"\nimport re\n\nimport aiohttp\nfrom google_trans_new import google_translator\nfrom pyrogram import filters\n\nfrom sitaBot import BOT_ID\nfrom sitaBot.helper_extra.aichat import add_chat, get_session, remove_chat\nfrom sitaBot.pyrogramee.pluginshelper import admins_only, edit_or_reply\nfrom sitaBot import pbot as sita\n\ntranslator = google_translator()\nimport requests\n\n\ndef extract_emojis(s):\n    return \"\".join(c for c in s if c in EMOJI_MAP)\n\n\nasync def fetch(url):\n    try:\n        async with aiohttp.Timeout(10.0):\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url) as resp:\n                    try:\n                        data = await resp.json()\n                    except:\n                        data = await resp.text()\n            return data\n    except:\n        print(\"AI response Timeout\")\n        return\n\n\nsita_chats = []\nen_chats = []\n\n@sita.on_message(\n    filters.command(\"chatbot\") & ~filters.bot & ~filters.private\n)\n@admins_only\nasync def hmm(_, message):\n    global sita_chats\n    if len(message.command) != 2:\n        await message.reply_text(\n            \"I only recognize `/chatbot on` and /chatbot `off only`\"\n        )\n        message.continue_propagation()\n    status = message.text.split(None, 1)[1]\n    chat_id = message.chat.id\n    if status == \"ON\" or status == \"on\" or status == \"On\":\n        lel = await edit_or_reply(message, \"`Processing...`\")\n        lol = add_chat(int(message.chat.id))\n        if not lol:\n            await lel.edit(\"sita AI Already Activated In This Chat\")\n            return\n        await lel.edit(\n            f\"sita AI Successfully Added For Users In The Chat {message.chat.id}\"\n        )\n\n    elif status == \"OFF\" or status == \"off\" or status == \"Off\":\n        lel = await edit_or_reply(message, \"`Processing...`\")\n        Escobar = remove_chat(int(message.chat.id))\n        if not Escobar:\n            await lel.edit(\"sita AI Was Not Activated In This Chat\")\n            return\n        await lel.edit(\n            f\"sita AI Successfully Deactivated For Users In The Chat {message.chat.id}\"\n        )\n\n    elif status == \"EN\" or status == \"en\" or status == \"english\":\n        if not chat_id in en_chats:\n            en_chats.append(chat_id)\n            await message.reply_text(\"English AI chat Enabled!\")\n            return\n        await message.reply_text(\"AI Chat Is Already Disabled.\")\n        message.continue_propagation()\n    else:\n        await message.reply_text(\n            \"I only recognize `/chatbot on` and /chatbot `off only`\"\n        )\n\n\n@sita.on_message(\n    filters.text\n    & filters.reply\n    & ~filters.bot\n    & ~filters.via_bot\n    & ~filters.forwarded,\n    group=2,\n)\nasync def hmm(client, message):\n    if not get_session(int(message.chat.id)):\n        return\n    if not message.reply_to_message:\n        return\n    try:\n        senderr = message.reply_to_message.from_user.id\n    except:\n        return\n    if senderr != BOT_ID:\n        return\n    msg = message.text\n    chat_id = message.chat.id\n    if msg.startswith(\"/\") or msg.startswith(\"@\"):\n        message.continue_propagation()\n    if chat_id in en_chats:\n        test = msg\n        test = test.replace(\"sita\", \"Aco\")\n        test = test.replace(\"sita\", \"Aco\")\n        URL = \"https://api.affiliateplus.xyz/api/chatbot?message=hi&botname=@Innexiiiabot&ownername=@brahix\"\n\n        try:\n            r = requests.request(\"GET\", url=URL)\n        except:\n            return\n\n        try:\n            result = r.json()\n        except:\n            return\n\n        pro = result[\"message\"]\n        try:\n            await sita.send_chat_action(message.chat.id, \"typing\")\n            await message.reply_text(pro)\n        except CFError:\n            return\n\n    else:\n        u = msg.split()\n        emj = extract_emojis(msg)\n        msg = msg.replace(emj, \"\")\n        if (\n            [(k) for k in u if k.startswith(\"@\")]\n            and [(k) for k in u if k.startswith(\"#\")]\n            and [(k) for k in u if k.startswith(\"/\")]\n            and re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []\n        ):\n\n            h = \" \".join(filter(lambda x: x[0] != \"@\", u))\n            km = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", h)\n            tm = km.split()\n            jm = \" \".join(filter(lambda x: x[0] != \"#\", tm))\n            hm = jm.split()\n            rm = \" \".join(filter(lambda x: x[0] != \"/\", hm))\n        elif [(k) for k in u if k.startswith(\"@\")]:\n\n            rm = \" \".join(filter(lambda x: x[0] != \"@\", u))\n        elif [(k) for k in u if k.startswith(\"#\")]:\n            rm = \" \".join(filter(lambda x: x[0] != \"#\", u))\n        elif [(k) for k in u if k.startswith(\"/\")]:\n            rm = \" \".join(filter(lambda x: x[0] != \"/\", u))\n        elif re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []:\n            rm = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", msg)\n        else:\n            rm = msg\n            # print (rm)\n        try:\n            lan = translator.detect(rm)\n        except:\n            return\n        test = rm\n        if not \"en\" in lan and not lan == \"\":\n            try:\n                test = translator.translate(test, lang_tgt=\"en\")\n            except:\n                return\n        # test = emoji.demojize(test.strip())\n\n        # Kang with the credits bitches @InukaASiTH\n        test = test.replace(\"sita\", \"Aco\")\n        test = test.replace(\"sita\", \"Aco\")\n        URL = f\"https://api.affiliateplus.xyz/api/chatbot?message={test}&botname=@Innexiiiabot&ownername=@brahix\"\n        try:\n            r = requests.request(\"GET\", url=URL)\n        except:\n            return\n\n        try:\n            result = r.json()\n        except:\n            return\n        pro = result[\"message\"]\n        if not \"en\" in lan and not lan == \"\":\n            try:\n                pro = translator.translate(pro, lang_tgt=lan[0])\n            except:\n                return\n        try:\n            await sita.send_chat_action(message.chat.id, \"typing\")\n            await message.reply_text(pro)\n        except CFError:\n            return\n\n\n@sita.on_message(\n    filters.text & filters.private & filters.reply & ~filters.bot\n)\nasync def inuka(client, message):\n    msg = message.text\n    if msg.startswith(\"/\") or msg.startswith(\"@\"):\n        message.continue_propagation()\n    u = msg.split()\n    emj = extract_emojis(msg)\n    msg = msg.replace(emj, \"\")\n    if (\n        [(k) for k in u if k.startswith(\"@\")]\n        and [(k) for k in u if k.startswith(\"#\")]\n        and [(k) for k in u if k.startswith(\"/\")]\n        and re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []\n    ):\n\n        h = \" \".join(filter(lambda x: x[0] != \"@\", u))\n        km = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", h)\n        tm = km.split()\n        jm = \" \".join(filter(lambda x: x[0] != \"#\", tm))\n        hm = jm.split()\n        rm = \" \".join(filter(lambda x: x[0] != \"/\", hm))\n    elif [(k) for k in u if k.startswith(\"@\")]:\n\n        rm = \" \".join(filter(lambda x: x[0] != \"@\", u))\n    elif [(k) for k in u if k.startswith(\"#\")]:\n        rm = \" \".join(filter(lambda x: x[0] != \"#\", u))\n    elif [(k) for k in u if k.startswith(\"/\")]:\n        rm = \" \".join(filter(lambda x: x[0] != \"/\", u))\n    elif re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []:\n        rm = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", msg)\n    else:\n        rm = msg\n        # print (rm)\n    try:\n        lan = translator.detect(rm)\n    except:\n        return\n    test = rm\n    if not \"en\" in lan and not lan == \"\":\n        try:\n            test = translator.translate(test, lang_tgt=\"en\")\n        except:\n            return\n\n    # test = emoji.demojize(test.strip())\n\n    # Kang with the credits bitches @InukaASiTH\n    test = test.replace(\"sita\", \"Aco\")\n    test = test.replace(\"sita\", \"Aco\")\n    URL = f\"https://api.affiliateplus.xyz/api/chatbot?message={test}&botname=@Innexiiiabot&ownername=@brahix\"\n    try:\n        r = requests.request(\"GET\", url=URL)\n    except:\n        return\n\n    try:\n        result = r.json()\n    except:\n        return\n\n    pro = result[\"message\"]\n    if not \"en\" in lan and not lan == \"\":\n        pro = translator.translate(pro, lang_tgt=lan[0])\n    try:\n        await sita.send_chat_action(message.chat.id, \"typing\")\n        await message.reply_text(pro)\n    except CFError:\n        return\n\n\n@sita.on_message(\n    filters.regex(\"sita|sita|sita|sita|sita\")\n    & ~filters.bot\n    & ~filters.via_bot\n    & ~filters.forwarded\n    & ~filters.reply\n    & ~filters.channel\n)\nasync def inuka(client, message):\n    msg = message.text\n    if msg.startswith(\"/\") or msg.startswith(\"@\"):\n        message.continue_propagation()\n    u = msg.split()\n    emj = extract_emojis(msg)\n    msg = msg.replace(emj, \"\")\n    if (\n        [(k) for k in u if k.startswith(\"@\")]\n        and [(k) for k in u if k.startswith(\"#\")]\n        and [(k) for k in u if k.startswith(\"/\")]\n        and re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []\n    ):\n\n        h = \" \".join(filter(lambda x: x[0] != \"@\", u))\n        km = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", h)\n        tm = km.split()\n        jm = \" \".join(filter(lambda x: x[0] != \"#\", tm))\n        hm = jm.split()\n        rm = \" \".join(filter(lambda x: x[0] != \"/\", hm))\n    elif [(k) for k in u if k.startswith(\"@\")]:\n\n        rm = \" \".join(filter(lambda x: x[0] != \"@\", u))\n    elif [(k) for k in u if k.startswith(\"#\")]:\n        rm = \" \".join(filter(lambda x: x[0] != \"#\", u))\n    elif [(k) for k in u if k.startswith(\"/\")]:\n        rm = \" \".join(filter(lambda x: x[0] != \"/\", u))\n    elif re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []:\n        rm = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", msg)\n    else:\n        rm = msg\n        # print (rm)\n    try:\n        lan = translator.detect(rm)\n    except:\n        return\n    test = rm\n    if not \"en\" in lan and not lan == \"\":\n        try:\n            test = translator.translate(test, lang_tgt=\"en\")\n        except:\n            return\n\n    # test = emoji.demojize(test.strip())\n\n    # Kang with the credits bitches @InukaASiTH\n    test = test.replace(\"sita\", \"Aco\")\n    test = test.replace(\"sita\", \"Aco\")\n    URL = f\"https://api.affiliateplus.xyz/api/chatbot?message={test}&botname=@Innexiiiabot&ownername=@brahix\"\n    try:\n        r = requests.request(\"GET\", url=URL)\n    except:\n        return\n\n    try:\n        result = r.json()\n    except:\n        return\n    pro = result[\"message\"]\n    if not \"en\" in lan and not lan == \"\":\n        try:\n            pro = translator.translate(pro, lang_tgt=lan[0])\n        except Exception:\n            return\n    try:\n        await sita.send_chat_action(message.chat.id, \"typing\")\n        await message.reply_text(pro)\n    except CFError:\n        return\n\n\n__help__ = \"\"\"\n<b> Chatbot </b>\nsita AI 3.0 IS THE ONLY AI SYSTEM WHICH CAN DETECT & REPLY UPTO 200 LANGUAGES\n - /chatbot [ON/OFF]: Enables and disables AI Chat mode (EXCLUSIVE)\n - /chatbot EN : Enables English only chatbot\n \n\"\"\"\n\n__mod_name__ = \"Chatbot\"\n","size_bytes":11400},"sitaBot/modules/__songs.py":{"content":"import os\n\n#Saavn \n\nimport requests\nimport wget\nfrom pyrogram import filters\n\nfrom sitaBot import pbot as Jebot\nfrom sitaBot.pyrogramee.dark import get_arg\n\n\n@Jebot.on_message(filters.command(\"saavn\"))\nasync def song(client, message):\n    message.chat.id\n    message.from_user[\"id\"]\n    args = get_arg(message) + \" \" + \"song\"\n    if args.startswith(\" \"):\n        await message.reply(\"<b>Enter song name‚ùó</b>\")\n        return \"\"\n    m = await message.reply_text(\n        \"Downloading your song,\\nPlz wait ‚è≥Ô∏è\"\n    )\n    try:\n        r = requests.get(f\"https://jostapi.herokuapp.com/saavn?query={args}\")\n    except Exception as e:\n        await m.edit(str(e))\n        return\n    sname = r.json()[0][\"song\"]\n    slink = r.json()[0][\"media_url\"]\n    ssingers = r.json()[0][\"singers\"]\n    file = wget.download(slink)\n    ffile = file.replace(\"mp4\", \"m4a\")\n    os.rename(file, ffile)\n    await message.reply_audio(audio=ffile, title=sname, performer=ssingers)\n    os.remove(ffile)\n    await m.delete()\n\n\n#deezer#\n# Credits for @TheHamkerCat\n\nimport os\nimport aiofiles\nimport aiohttp\nfrom pyrogram import filters\nfrom sitaBot import pbot as sita\n\nARQ = \"https://thearq.tech/\"\n\nasync def fetch(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            try:\n                data = await resp.json()\n            except:\n                data = await resp.text()\n    return data\n\nasync def download_song(url):\n    song_name = f\"asuna.mp3\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            if resp.status == 200:\n                f = await aiofiles.open(song_name, mode=\"wb\")\n                await f.write(await resp.read())\n                await f.close()\n    return song_name\n\n\n@sita.on_message(filters.command(\"deezer\"))\nasync def deezer(_, message):\n    if len(message.command) < 2:\n        await message.reply_text(\"Download Now Deezer\")\n        return\n    text = message.text.split(None, 1)[1]\n    query = text.replace(\" \", \"%20\")\n    m = await message.reply_text(\"Searching...\")\n    try:\n        r = await fetch(f\"{ARQ}deezer?query={query}&count=1\")\n        title = r[0][\"title\"]\n        url = r[0][\"url\"]\n        artist = r[0][\"artist\"]\n    except Exception as e:\n        await m.edit(str(e))\n        return\n    await m.edit(\"Downloading...\")\n    song = await download_song(url)\n    await m.edit(\"Uploading...\")\n    await message.reply_audio(audio=song, title=title, performer=artist)\n    os.remove(song)\n    await m.delete()\n\n#Deezer\n# Credits for @TheHamkerCat\n\nimport os\nimport aiofiles\nimport aiohttp\nfrom pyrogram import filters\nfrom sitaBot import pbot as ASUNA\n\nARQ = \"https://thearq.tech/\"\n\nasync def fetch(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            try:\n                data = await resp.json()\n            except:\n                data = await resp.text()\n    return data\n\nasync def download_song(url):\n    song_name = f\"asuna.mp3\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            if resp.status == 200:\n                f = await aiofiles.open(song_name, mode=\"wb\")\n                await f.write(await resp.read())\n                await f.close()\n    return song_name\n\n\n@sita.on_message(filters.command(\"deezer\"))\nasync def deezer(_, message):\n    if len(message.command) < 2:\n        await message.reply_text(\"Download Now Deezer\")\n        return\n    text = message.text.split(None, 1)[1]\n    query = text.replace(\" \", \"%20\")\n    m = await message.reply_text(\"Searching...\")\n    try:\n        r = await fetch(f\"{ARQ}deezer?query={query}&count=1\")\n        title = r[0][\"title\"]\n        url = r[0][\"url\"]\n        artist = r[0][\"artist\"]\n    except Exception as e:\n        await m.edit(str(e))\n        return\n    await m.edit(\"Downloading...\")\n    song = await download_song(url)\n    await m.edit(\"Uploading...\")\n    await message.reply_audio(audio=song, title=title, performer=artist)\n    os.remove(song)\n    await m.delete()\n    \n    \n__mod_name__ = \"Music\"\n\n__help__ = \"\"\"\n‚Ä¢ `/song`** <songname artist(optional)>: download the song in it's best quality available.(API BASED)\n‚Ä¢ `/video`** <songname artist(optional)>: download the video song in it's best quality available.\n‚Ä¢ `/deezer`** <songname>: download from deezer\n‚Ä¢ `/lyrics`** <songname artist(optional)>: sends the complete lyrics of the song provided as input\n‚Ä¢ `/glyrics`** <i> song name </i> : This plugin searches for song lyrics with song name and artist.\n\"\"\"\n\n","size_bytes":4586},"sitaBot/modules/__imdb.py":{"content":"from sitaBot import telethn as tbot\nimport os\nimport re\nimport bs4\nimport requests\nfrom telethon import types\nfrom telethon.tl import functions\nfrom sitaBot.events import register\n\nlangi = \"en\"\n\n\n@register(pattern=\"^/imdb (.*)\")\nasync def imdb(e):\n    if e.fwd_from:\n        return\n    try:\n        movie_name = e.pattern_match.group(1)\n        remove_space = movie_name.split(\" \")\n        final_name = \"+\".join(remove_space)\n        page = requests.get(\n            \"https://www.imdb.com/find?ref_=nv_sr_fn&q=\" + final_name + \"&s=all\"\n        )\n        str(page.status_code)\n        soup = bs4.BeautifulSoup(page.content, \"html.parser\")\n        odds = soup.findAll(\"tr\", \"odd\")\n        mov_title = odds[0].findNext(\"td\").findNext(\"td\").text\n        mov_link = (\n            \"http://www.imdb.com/\" + odds[0].findNext(\"td\").findNext(\"td\").a[\"href\"]\n        )\n        page1 = requests.get(mov_link)\n        soup = bs4.BeautifulSoup(page1.content, \"lxml\")\n        if soup.find(\"div\", \"poster\"):\n            poster = soup.find(\"div\", \"poster\").img[\"src\"]\n        else:\n            poster = \"\"\n        if soup.find(\"div\", \"title_wrapper\"):\n            pg = soup.find(\"div\", \"title_wrapper\").findNext(\"div\").text\n            mov_details = re.sub(r\"\\s+\", \" \", pg)\n        else:\n            mov_details = \"\"\n        credits = soup.findAll(\"div\", \"credit_summary_item\")\n        if len(credits) == 1:\n            director = credits[0].a.text\n            writer = \"Not available\"\n            stars = \"Not available\"\n        elif len(credits) > 2:\n            director = credits[0].a.text\n            writer = credits[1].a.text\n            actors = []\n            for x in credits[2].findAll(\"a\"):\n                actors.append(x.text)\n            actors.pop()\n            stars = actors[0] + \",\" + actors[1] + \",\" + actors[2]\n        else:\n            director = credits[0].a.text\n            writer = \"Not available\"\n            actors = []\n            for x in credits[1].findAll(\"a\"):\n                actors.append(x.text)\n            actors.pop()\n            stars = actors[0] + \",\" + actors[1] + \",\" + actors[2]\n        if soup.find(\"div\", \"inline canwrap\"):\n            story_line = soup.find(\"div\", \"inline canwrap\").findAll(\"p\")[0].text\n        else:\n            story_line = \"Not available\"\n        info = soup.findAll(\"div\", \"txt-block\")\n        if info:\n            mov_country = []\n            mov_language = []\n            for node in info:\n                a = node.findAll(\"a\")\n                for i in a:\n                    if \"country_of_origin\" in i[\"href\"]:\n                        mov_country.append(i.text)\n                    elif \"primary_language\" in i[\"href\"]:\n                        mov_language.append(i.text)\n        if soup.findAll(\"div\", \"ratingValue\"):\n            for r in soup.findAll(\"div\", \"ratingValue\"):\n                mov_rating = r.strong[\"title\"]\n        else:\n            mov_rating = \"Not available\"\n        await e.reply(\n            \"<a href=\" + poster + \">&#8203;</a>\"\n            \"<b>Title : </b><code>\"\n            + mov_title\n            + \"</code>\\n<code>\"\n            + mov_details\n            + \"</code>\\n<b>Rating : </b><code>\"\n            + mov_rating\n            + \"</code>\\n<b>Country : </b><code>\"\n            + mov_country[0]\n            + \"</code>\\n<b>Language : </b><code>\"\n            + mov_language[0]\n            + \"</code>\\n<b>Director : </b><code>\"\n            + director\n            + \"</code>\\n<b>Writer : </b><code>\"\n            + writer\n            + \"</code>\\n<b>Stars : </b><code>\"\n            + stars\n            + \"</code>\\n<b>IMDB Url : </b>\"\n            + mov_link\n            + \"\\n<b>Story Line : </b>\"\n            + story_line,\n            link_preview=True,\n            parse_mode=\"HTML\",\n        )\n    except IndexError:\n        await e.reply(\"Plox enter **Valid movie name** kthx\")\n","size_bytes":3852},"sitaBot/modules/rules.py":{"content":"from typing import Optional\n\nimport sitaBot.modules.sql.rules_sql as sql\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.helper_funcs.string_handling import markdown_parser\nfrom telegram import (\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n    Message,\n    ParseMode,\n    Update,\n    User,\n)\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, Filters, run_async\nfrom telegram.utils.helpers import escape_markdown\n\n\n@run_async\ndef get_rules(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    send_rules(update, chat_id)\n\n\n# Do not async - not from a handler\ndef send_rules(update, chat_id, from_pm=False):\n    bot = dispatcher.bot\n    user = update.effective_user  # type: Optional[User]\n    try:\n        chat = bot.get_chat(chat_id)\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\" and from_pm:\n            bot.send_message(\n                user.id,\n                \"The rules shortcut for this chat hasn't been set properly! Ask admins to \"\n                \"fix this.\\nMaybe they forgot the hyphen in ID\",\n            )\n            return\n        else:\n            raise\n\n    rules = sql.get_rules(chat_id)\n    text = f\"The rules for *{escape_markdown(chat.title)}* are:\\n\\n{rules}\"\n\n    if from_pm and rules:\n        bot.send_message(\n            user.id, text, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True\n        )\n    elif from_pm:\n        bot.send_message(\n            user.id,\n            \"The group admins haven't set any rules for this chat yet. \"\n            \"This probably doesn't mean it's lawless though...!\",\n        )\n    elif rules:\n        update.effective_message.reply_text(\n            \"Please click the button below to see the rules.\",\n            reply_markup=InlineKeyboardMarkup(\n                [\n                    [\n                        InlineKeyboardButton(\n                            text=\"Rules\", url=f\"t.me/{bot.username}?start={chat_id}\"\n                        )\n                    ]\n                ]\n            ),\n        )\n    else:\n        update.effective_message.reply_text(\n            \"The group admins haven't set any rules for this chat yet. \"\n            \"This probably doesn't mean it's lawless though...!\"\n        )\n\n\n@run_async\n@user_admin\ndef set_rules(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    msg = update.effective_message  # type: Optional[Message]\n    raw_text = msg.text\n    args = raw_text.split(None, 1)  # use python's maxsplit to separate cmd and args\n    if len(args) == 2:\n        txt = args[1]\n        offset = len(txt) - len(raw_text)  # set correct offset relative to command\n        markdown_rules = markdown_parser(\n            txt, entities=msg.parse_entities(), offset=offset\n        )\n\n        sql.set_rules(chat_id, markdown_rules)\n        update.effective_message.reply_text(\"Successfully set rules for this group.\")\n\n\n@run_async\n@user_admin\ndef clear_rules(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    sql.set_rules(chat_id, \"\")\n    update.effective_message.reply_text(\"Successfully cleared rules!\")\n\n\ndef __stats__():\n    return f\"‚Ä¢ {sql.num_chats()} chats have rules set.\"\n\n\ndef __import_data__(chat_id, data):\n    # set chat rules\n    rules = data.get(\"info\", {}).get(\"rules\", \"\")\n    sql.set_rules(chat_id, rules)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    return f\"This chat has had it's rules set: `{bool(sql.get_rules(chat_id))}`\"\n\n\n__help__ = \"\"\"\n ‚ùç /rules*:* get the rules for this chat.\n\n*Admins only:*\n ‚ùç /setrules <your rules here>*:* set the rules for this chat.\n ‚ùç /clearrules*:* clear the rules for this chat.\n\"\"\"\n\n__mod_name__ = \"Rules\"\n\nGET_RULES_HANDLER = CommandHandler(\"rules\", get_rules, filters=Filters.group)\nSET_RULES_HANDLER = CommandHandler(\"setrules\", set_rules, filters=Filters.group)\nRESET_RULES_HANDLER = CommandHandler(\"clearrules\", clear_rules, filters=Filters.group)\n\ndispatcher.add_handler(GET_RULES_HANDLER)\ndispatcher.add_handler(SET_RULES_HANDLER)\ndispatcher.add_handler(RESET_RULES_HANDLER)\n","size_bytes":4294},"sitaBot/modules/nsfw.py":{"content":"import os\nimport html\nimport nekos\nimport requests\nfrom PIL import Image\nfrom telegram import ParseMode\nfrom sitaBot import dispatcher, updater\nimport sitaBot.modules.sql.nsfw_sql as sql\nfrom sitaBot.modules.log_channel import gloggable\nfrom telegram import Message, Chat, Update, Bot, MessageEntity\nfrom telegram.error import BadRequest, RetryAfter, Unauthorized\nfrom telegram.ext import CommandHandler, run_async, CallbackContext\nfrom sitaBot.modules.helper_funcs.filters import CustomFilters\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom telegram.utils.helpers import mention_html, mention_markdown, escape_markdown\n\n@run_async\n@user_admin\n@gloggable\ndef add_nsfw(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    msg = update.effective_message\n    user = update.effective_user #Remodified by @EverythingSuckz\n    is_nsfw = sql.is_nsfw(chat.id)\n    if not is_nsfw:\n        sql.set_nsfw(chat.id)\n        msg.reply_text(\"Activated NSFW Mode!\")\n        message = (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"ACTIVATED_NSFW\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        )\n        return message\n    else:\n        msg.reply_text(\"NSFW Mode is already Activated for this chat!\")\n        return \"\"\n\n\n@run_async\n@user_admin\n@gloggable\ndef rem_nsfw(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n    is_nsfw = sql.is_nsfw(chat.id)\n    if not is_nsfw:\n        msg.reply_text(\"NSFW Mode is already Deactivated\")\n        return \"\"\n    else:\n        sql.rem_nsfw(chat.id)\n        msg.reply_text(\"Rolled Back to SFW Mode!\")\n        message = (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"DEACTIVATED_NSFW\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        )\n        return message\n\n@run_async\ndef list_nsfw_chats(update: Update, context: CallbackContext):\n    chats = sql.get_all_nsfw_chats()\n    text = \"<b>NSFW Activated Chats</b>\\n\"\n    for chat in chats:\n        try:\n            x = context.bot.get_chat(int(*chat))\n            name = x.title if x.title else x.first_name\n            text += f\"‚Ä¢ <code>{name}</code>\\n\"\n        except BadRequest:\n            sql.rem_nsfw(*chat)\n        except Unauthorized:\n            sql.rem_nsfw(*chat)\n        except RetryAfter as e:\n            sleep(e.retry_after)\n    update.effective_message.reply_text(text, parse_mode=\"HTML\")\n\n\n@run_async\ndef neko(update, context):\n    msg = update.effective_message\n    target = \"neko\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef feet(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"feet\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef yuri(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"yuri\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef trap(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"trap\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef futanari(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"futanari\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef hololewd(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"hololewd\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef lewdkemo(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"lewdkemo\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef sologif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"solog\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef feetgif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"feetg\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef cumgif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"cum\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef erokemo(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"erokemo\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef lesbian(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"les\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef wallpaper(update, context):\n    msg = update.effective_message\n    target = \"wallpaper\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef lewdk(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"lewdk\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef ngif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"ngif\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef tickle(update, context):\n     msg = update.effective_message\n     target = \"tickle\"\n     msg.reply_video(nekos.img(target))\n\n@run_async\ndef lewd(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"lewd\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef feed(update, context):\n    msg = update.effective_message\n    target = \"feed\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef eroyuri(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"eroyuri\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef eron(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"eron\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef cum(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"cum_jpg\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef bjgif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"bj\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef bj(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"blowjob\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef nekonsfw(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"nsfw_neko_gif\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef solo(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"solo\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef kemonomimi(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"kemonomimi\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef avatarlewd(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"nsfw_avatar\"\n    with open(\"temp.png\", \"wb\") as f:\n        f.write(requests.get(nekos.img(target)).content)\n    img = Image.open(\"temp.png\")\n    img.save(\"temp.webp\", \"webp\")\n    msg.reply_document(open(\"temp.webp\", \"rb\"))\n    os.remove(\"temp.webp\")\n\n@run_async\ndef gasm(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"gasm\"\n    with open(\"temp.png\", \"wb\") as f:\n        f.write(requests.get(nekos.img(target)).content)\n    img = Image.open(\"temp.png\")\n    img.save(\"temp.webp\", \"webp\")\n    msg.reply_document(open(\"temp.webp\", \"rb\"))\n    os.remove(\"temp.webp\")\n\n\n@run_async\ndef poke(update, context):\n    msg = update.effective_message\n    target = \"poke\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef anal(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"anal\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef hentai(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"hentai\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef avatar(update, context):\n    msg = update.effective_message\n    target = \"nsfw_avatar\"\n    with open(\"temp.png\", \"wb\") as f:\n        f.write(requests.get(nekos.img(target)).content)\n    img = Image.open(\"temp.png\")\n    img.save(\"temp.webp\", \"webp\")\n    msg.reply_document(open(\"temp.webp\", \"rb\"))\n    os.remove(\"temp.webp\")\n\n@run_async\ndef erofeet(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"erofeet\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef holo(update, context):\n    msg = update.effective_message\n    target = \"holo\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef keta(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = 'keta'\n    if not target:\n        msg.reply_text(\"No URL was received from the API!\")\n        return\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef pussygif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"pussy\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef tits(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"tits\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef holoero(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"holoero\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef pussy(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"pussy_jpg\"\n    msg.reply_photo(nekos.img(target))\n\n@run_async\ndef hentaigif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"random_hentai_gif\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef classic(update, context):\n    msg = update.effective_message\n    target = \"classic\"\n    msg.reply_video(nekos.img(target))\n\n@run_async\ndef kuni(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"kuni\"\n    try:\n        video_url = nekos.img(target)\n        if video_url:\n            msg.reply_video(video_url)\n        else:\n            msg.reply_text(\"Sorry, couldn't fetch that content right now.\")\n    except Exception as e:\n        msg.reply_text(\"Sorry, an error occurred while fetching the content.\")\n\n\n@run_async\ndef waifu(update, context):\n    msg = update.effective_message\n    target = \"waifu\"\n    with open(\"temp.png\", \"wb\") as f:\n        f.write(requests.get(nekos.img(target)).content)\n    img = Image.open(\"temp.png\")\n    img.save(\"temp.webp\", \"webp\")\n    msg.reply_document(open(\"temp.webp\", \"rb\"))\n    os.remove(\"temp.webp\")\n\n\n@run_async\ndef kiss(update, context):\n    msg = update.effective_message\n    target = \"kiss\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef femdom(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"femdom\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef hug(update, context):\n    msg = update.effective_message\n    target = \"cuddle\"\n    msg.reply_video(nekos.img(target))\n\n\n@run_async\ndef erok(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"erok\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef foxgirl(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"fox_girl\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef titsgif(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"boobs\"\n    try:\n        video_url = nekos.img(target)\n        if video_url:\n            msg.reply_video(video_url)\n        else:\n            msg.reply_text(\"Sorry, couldn't fetch that content right now.\")\n    except Exception as e:\n        msg.reply_text(\"Sorry, an error occurred while fetching the content.\")\n\n\n@run_async\ndef ero(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    target = \"ero\"\n    msg.reply_photo(nekos.img(target))\n\n\n@run_async\ndef smug(update, context):\n    msg = update.effective_message\n    target = \"smug\"\n    try:\n        video_url = nekos.img(target)\n        if video_url:\n            msg.reply_video(video_url)\n        else:\n            msg.reply_text(\"Sorry, couldn't fetch that content right now.\")\n    except Exception as e:\n        msg.reply_text(\"Sorry, an error occurred while fetching the content.\")\n\n\n@run_async\ndef baka(update, context):\n    msg = update.effective_message\n    target = \"baka\"\n    try:\n        video_url = nekos.img(target)\n        if video_url:\n            msg.reply_video(video_url)\n        else:\n            msg.reply_text(\"Sorry, couldn't fetch that content right now.\")\n    except Exception as e:\n        msg.reply_text(\"Sorry, an error occurred while fetching the content.\")\n\n\n@run_async\ndef dva(update, context):\n    chat_id = update.effective_chat.id\n    if not update.effective_message.chat.type == \"private\":\n        is_nsfw = sql.is_nsfw(chat_id)\n        if not is_nsfw:\n            return\n    msg = update.effective_message\n    try:\n        nsfw = requests.get(\"https://api.computerfreaker.cf/v1/dva\", timeout=10).json()\n        url = nsfw.get(\"url\")\n        if not url:\n            msg.reply_text(\"No URL was received from the API!\")\n            return\n        msg.reply_photo(url)\n    except Exception as e:\n        msg.reply_text(\"Sorry, couldn't fetch content from the API right now.\")\n\nADD_NSFW_HANDLER = CommandHandler(\"addnsfw\", add_nsfw)\nREMOVE_NSFW_HANDLER = CommandHandler(\"rmnsfw\", rem_nsfw)\nLIST_NSFW_CHATS_HANDLER = CommandHandler(\n    \"nsfwchats\", list_nsfw_chats, filters=CustomFilters.dev_filter)\nLEWDKEMO_HANDLER = CommandHandler(\"lewdkemo\", lewdkemo)\nNEKO_HANDLER = CommandHandler(\"neko\", neko)\nFEET_HANDLER = CommandHandler(\"feet\", feet)\nYURI_HANDLER = CommandHandler(\"yuri\", yuri)\nTRAP_HANDLER = CommandHandler(\"trap\", trap)\nFUTANARI_HANDLER = CommandHandler(\"futanari\", futanari)\nHOLOLEWD_HANDLER = CommandHandler(\"hololewd\", hololewd)\nSOLOGIF_HANDLER = CommandHandler(\"sologif\", sologif)\nCUMGIF_HANDLER = CommandHandler(\"cumgif\", cumgif)\nEROKEMO_HANDLER = CommandHandler(\"erokemo\", erokemo)\nLESBIAN_HANDLER = CommandHandler(\"lesbian\", lesbian)\nWALLPAPER_HANDLER = CommandHandler(\"wallpaper\", wallpaper)\nLEWDK_HANDLER = CommandHandler(\"lewdk\", lewdk)\nNGIF_HANDLER = CommandHandler(\"ngif\", ngif)\nTICKLE_HANDLER = CommandHandler(\"tickle\", tickle)\nLEWD_HANDLER = CommandHandler(\"lewd\", lewd)\nFEED_HANDLER = CommandHandler(\"feed\", feed)\nEROYURI_HANDLER = CommandHandler(\"eroyuri\", eroyuri)\nERON_HANDLER = CommandHandler(\"eron\", eron)\nCUM_HANDLER = CommandHandler(\"cum\", cum)\nBJGIF_HANDLER = CommandHandler(\"bjgif\", bjgif)\nBJ_HANDLER = CommandHandler(\"bj\", bj)\nNEKONSFW_HANDLER = CommandHandler(\"nekonsfw\", nekonsfw)\nSOLO_HANDLER = CommandHandler(\"solo\", solo)\nKEMONOMIMI_HANDLER = CommandHandler(\"kemonomimi\", kemonomimi)\nAVATARLEWD_HANDLER = CommandHandler(\"avatarlewd\", avatarlewd)\nGASM_HANDLER = CommandHandler(\"gasm\", gasm)\nPOKE_HANDLER = CommandHandler(\"poke\", poke)\nANAL_HANDLER = CommandHandler(\"anal\", anal)\nHENTAI_HANDLER = CommandHandler(\"hentai\", hentai)\nAVATAR_HANDLER = CommandHandler(\"avatar\", avatar)\nEROFEET_HANDLER = CommandHandler(\"erofeet\", erofeet)\nHOLO_HANDLER = CommandHandler(\"holo\", holo)\nTITS_HANDLER = CommandHandler(\"tits\", tits)\nPUSSYGIF_HANDLER = CommandHandler(\"pussygif\", pussygif)\nHOLOERO_HANDLER = CommandHandler(\"holoero\", holoero)\nPUSSY_HANDLER = CommandHandler(\"pussy\", pussy)\nHENTAIGIF_HANDLER = CommandHandler(\"hentaigif\", hentaigif)\nCLASSIC_HANDLER = CommandHandler(\"classic\", classic)\nKUNI_HANDLER = CommandHandler(\"kuni\", kuni)\nWAIFU_HANDLER = CommandHandler(\"waifu\", waifu)\nLEWD_HANDLER = CommandHandler(\"lewd\", lewd)\nKISS_HANDLER = CommandHandler(\"kiss\", kiss)\nFEMDOM_HANDLER = CommandHandler(\"femdom\", femdom)\nCUDDLE_HANDLER = CommandHandler(\"hug\", hug)\nEROK_HANDLER = CommandHandler(\"erok\", erok)\nFOXGIRL_HANDLER = CommandHandler(\"foxgirl\", foxgirl)\nTITSGIF_HANDLER = CommandHandler(\"titsgif\", titsgif)\nERO_HANDLER = CommandHandler(\"ero\", ero)\nSMUG_HANDLER = CommandHandler(\"smug\", smug)\nBAKA_HANDLER = CommandHandler(\"baka\", baka)\nDVA_HANDLER = CommandHandler(\"dva\", dva)\n\n\ndispatcher.add_handler(ADD_NSFW_HANDLER)\ndispatcher.add_handler(REMOVE_NSFW_HANDLER)\ndispatcher.add_handler(LIST_NSFW_CHATS_HANDLER)\ndispatcher.add_handler(LEWDKEMO_HANDLER)\ndispatcher.add_handler(NEKO_HANDLER)\ndispatcher.add_handler(FEET_HANDLER)\ndispatcher.add_handler(YURI_HANDLER)\ndispatcher.add_handler(TRAP_HANDLER)\ndispatcher.add_handler(FUTANARI_HANDLER)\ndispatcher.add_handler(HOLOLEWD_HANDLER)\ndispatcher.add_handler(SOLOGIF_HANDLER)\ndispatcher.add_handler(CUMGIF_HANDLER)\ndispatcher.add_handler(EROKEMO_HANDLER)\ndispatcher.add_handler(LESBIAN_HANDLER)\ndispatcher.add_handler(WALLPAPER_HANDLER)\ndispatcher.add_handler(LEWDK_HANDLER)\ndispatcher.add_handler(NGIF_HANDLER)\ndispatcher.add_handler(TICKLE_HANDLER)\ndispatcher.add_handler(LEWD_HANDLER)\ndispatcher.add_handler(FEED_HANDLER)\ndispatcher.add_handler(EROYURI_HANDLER)\ndispatcher.add_handler(ERON_HANDLER)\ndispatcher.add_handler(CUM_HANDLER)\ndispatcher.add_handler(BJGIF_HANDLER)\ndispatcher.add_handler(BJ_HANDLER)\ndispatcher.add_handler(NEKONSFW_HANDLER)\ndispatcher.add_handler(SOLO_HANDLER)\ndispatcher.add_handler(KEMONOMIMI_HANDLER)\ndispatcher.add_handler(AVATARLEWD_HANDLER)\ndispatcher.add_handler(GASM_HANDLER)\ndispatcher.add_handler(POKE_HANDLER)\ndispatcher.add_handler(ANAL_HANDLER)\ndispatcher.add_handler(HENTAI_HANDLER)\ndispatcher.add_handler(AVATAR_HANDLER)\ndispatcher.add_handler(EROFEET_HANDLER)\ndispatcher.add_handler(HOLO_HANDLER)\ndispatcher.add_handler(TITS_HANDLER)\ndispatcher.add_handler(PUSSYGIF_HANDLER)\ndispatcher.add_handler(HOLOERO_HANDLER)\ndispatcher.add_handler(PUSSY_HANDLER)\ndispatcher.add_handler(HENTAIGIF_HANDLER)\ndispatcher.add_handler(CLASSIC_HANDLER)\ndispatcher.add_handler(KUNI_HANDLER)\ndispatcher.add_handler(WAIFU_HANDLER)\ndispatcher.add_handler(LEWD_HANDLER)\ndispatcher.add_handler(KISS_HANDLER)\ndispatcher.add_handler(FEMDOM_HANDLER)\ndispatcher.add_handler(CUDDLE_HANDLER)\ndispatcher.add_handler(EROK_HANDLER)\ndispatcher.add_handler(FOXGIRL_HANDLER)\ndispatcher.add_handler(TITSGIF_HANDLER)\ndispatcher.add_handler(ERO_HANDLER)\ndispatcher.add_handler(SMUG_HANDLER)\ndispatcher.add_handler(BAKA_HANDLER)\ndispatcher.add_handler(DVA_HANDLER)\n\n__handlers__ = [\n    ADD_NSFW_HANDLER,\n    REMOVE_NSFW_HANDLER,\n    LIST_NSFW_CHATS_HANDLER,\n    NEKO_HANDLER,\n    FEET_HANDLER,\n    YURI_HANDLER,\n    TRAP_HANDLER,\n    FUTANARI_HANDLER,\n    HOLOLEWD_HANDLER,\n    SOLOGIF_HANDLER,\n    CUMGIF_HANDLER,\n    EROKEMO_HANDLER,\n    LESBIAN_HANDLER,\n    WALLPAPER_HANDLER,\n    LEWDK_HANDLER,\n    NGIF_HANDLER,\n    TICKLE_HANDLER,\n    LEWD_HANDLER,\n    FEED_HANDLER,\n    EROYURI_HANDLER,\n    ERON_HANDLER,\n    CUM_HANDLER,\n    BJGIF_HANDLER,\n    BJ_HANDLER,\n    NEKONSFW_HANDLER,\n    SOLO_HANDLER,\n    KEMONOMIMI_HANDLER,\n    AVATARLEWD_HANDLER,\n    GASM_HANDLER,\n    POKE_HANDLER,\n    ANAL_HANDLER,\n    HENTAI_HANDLER,\n    AVATAR_HANDLER,\n    EROFEET_HANDLER,\n    HOLO_HANDLER,\n    TITS_HANDLER,\n    PUSSYGIF_HANDLER,\n    HOLOERO_HANDLER,\n    PUSSY_HANDLER,\n    HENTAIGIF_HANDLER,\n    CLASSIC_HANDLER,\n    KUNI_HANDLER,\n    WAIFU_HANDLER,\n    LEWD_HANDLER,\n    KISS_HANDLER,\n    FEMDOM_HANDLER,\n    LEWDKEMO_HANDLER,\n    CUDDLE_HANDLER,\n    EROK_HANDLER,\n    FOXGIRL_HANDLER,\n    TITSGIF_HANDLER,\n    ERO_HANDLER,\n    SMUG_HANDLER,\n    BAKA_HANDLER,\n    DVA_HANDLER,\n]\n\n__help__ = \"\"\"\n*NSFW:*\n/addnsfw : Enable NSFW mode\n/rmnsfw : Disable NSFW mode\n \n*Available commands:*  \n - /neko: Sends Random SFW Neko source Images.\n - /feet: Sends Random Anime Feet Images.\n - /yuri: Sends Random Yuri source Images.\n - /trap: Sends Random Trap source Images.\n - /futanari: Sends Random Futanari source Images.\n - /hololewd: Sends Random Holo Lewds.\n - /lewdkemo: Sends Random Kemo Lewds.\n - /sologif: Sends Random Solo GIFs.\n - /cumgif: Sends Random Cum GIFs.\n - /erokemo: Sends Random Ero-Kemo Images.\n - /lesbian: Sends Random Les Source Images.\n - /lewdk: Sends Random Kitsune Lewds.\n - /ngif: Sends Random Neko GIFs.\n - /tickle: Sends Random Tickle GIFs.\n - /lewd: Sends Random Lewds.\n - /feed: Sends Random Feeding GIFs.\n - /eroyuri: Sends Random Ero-Yuri source Images.\n - /eron: Sends Random Ero-Neko source Images.\n - /cum: Sends Random Cum Images.\n - /bjgif: Sends Random Blow Job GIFs.\n - /bj: Sends Random Blow Job source Images.\n - /nekonsfw: Sends Random NSFW Neko source Images.\n - /solo: Sends Random NSFW Neko GIFs.\n - /kemonomimi: Sends Random KemonoMimi source Images.\n - /avatarlewd: Sends Random Avater Lewd Stickers.\n - /gasm: Sends Random Orgasm Stickers.\n - /poke: Sends Random Poke GIFs.\n - /anal: Sends Random Anal GIFs.\n - /hentai: Sends Random Hentai source Images.\n - /avatar: Sends Random Avatar Stickers.\n - /erofeet: Sends Random Ero-Feet source Images.\n - /holo: Sends Random Holo source Images.\n - /tits: Sends Random Tits source Images.\n - /pussygif: Sends Random Pussy GIFs.\n - /holoero: Sends Random Ero-Holo source Images.\n - /pussy: Sends Random Pussy source Images.\n - /hentaigif: Sends Random Hentai GIFs.\n - /classic: Sends Random Classic Hentai GIFs.\n - /kuni: Sends Random Pussy Lick GIFs.\n - /waifu: Sends Random Waifu Stickers.\n - /kiss: Sends Random Kissing GIFs.\n - /femdom: Sends Random Femdom source Images.\n - /cuddle: Sends Random Cuddle GIFs.\n - /erok: Sends Random Ero-Kitsune source Images.\n - /foxgirl: Sends Random FoxGirl source Images.\n - /titsgif: Sends Random Tits GIFs.\n - /ero: Sends Random Ero source Images.\n - /smug: Sends Random Smug GIFs.\n - /baka: Sends Random Baka Shout GIFs.\n - /dva: Sends Random D.VA source Images.\n\"\"\"\n\n__mod_name__ = \"NSFW\"\n","size_bytes":27529},"sitaBot/modules/math.py":{"content":"import math\n\nimport pynewtonmath as newton\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import Update\nfrom telegram.ext import CallbackContext, run_async\n\n\n@run_async\ndef simplify(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.simplify(\"{}\".format(args[0])))\n\n\n@run_async\ndef factor(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.factor(\"{}\".format(args[0])))\n\n\n@run_async\ndef derive(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.derive(\"{}\".format(args[0])))\n\n\n@run_async\ndef integrate(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.integrate(\"{}\".format(args[0])))\n\n\n@run_async\ndef zeroes(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.zeroes(\"{}\".format(args[0])))\n\n\n@run_async\ndef tangent(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.tangent(\"{}\".format(args[0])))\n\n\n@run_async\ndef area(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(newton.area(\"{}\".format(args[0])))\n\n\n@run_async\ndef cos(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.cos(int(args[0])))\n\n\n@run_async\ndef sin(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.sin(int(args[0])))\n\n\n@run_async\ndef tan(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.tan(int(args[0])))\n\n\n@run_async\ndef arccos(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.acos(int(args[0])))\n\n\n@run_async\ndef arcsin(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.asin(int(args[0])))\n\n\n@run_async\ndef arctan(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.atan(int(args[0])))\n\n\n@run_async\ndef abs(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.fabs(int(args[0])))\n\n\n@run_async\ndef log(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    message.reply_text(math.log(int(args[0])))\n\n\n\n__mod_name__ = \"Math\"\n\nSIMPLIFY_HANDLER = DisableAbleCommandHandler(\"math\", simplify)\nFACTOR_HANDLER = DisableAbleCommandHandler(\"factor\", factor)\nDERIVE_HANDLER = DisableAbleCommandHandler(\"derive\", derive)\nINTEGRATE_HANDLER = DisableAbleCommandHandler(\"integrate\", integrate)\nZEROES_HANDLER = DisableAbleCommandHandler(\"zeroes\", zeroes)\nTANGENT_HANDLER = DisableAbleCommandHandler(\"tangent\", tangent)\nAREA_HANDLER = DisableAbleCommandHandler(\"area\", area)\nCOS_HANDLER = DisableAbleCommandHandler(\"cos\", cos)\nSIN_HANDLER = DisableAbleCommandHandler(\"sin\", sin)\nTAN_HANDLER = DisableAbleCommandHandler(\"tan\", tan)\nARCCOS_HANDLER = DisableAbleCommandHandler(\"arccos\", arccos)\nARCSIN_HANDLER = DisableAbleCommandHandler(\"arcsin\", arcsin)\nARCTAN_HANDLER = DisableAbleCommandHandler(\"arctan\", arctan)\nABS_HANDLER = DisableAbleCommandHandler(\"abs\", abs)\nLOG_HANDLER = DisableAbleCommandHandler(\"log\", log)\n\ndispatcher.add_handler(SIMPLIFY_HANDLER)\ndispatcher.add_handler(FACTOR_HANDLER)\ndispatcher.add_handler(DERIVE_HANDLER)\ndispatcher.add_handler(INTEGRATE_HANDLER)\ndispatcher.add_handler(ZEROES_HANDLER)\ndispatcher.add_handler(TANGENT_HANDLER)\ndispatcher.add_handler(AREA_HANDLER)\ndispatcher.add_handler(COS_HANDLER)\ndispatcher.add_handler(SIN_HANDLER)\ndispatcher.add_handler(TAN_HANDLER)\ndispatcher.add_handler(ARCCOS_HANDLER)\ndispatcher.add_handler(ARCSIN_HANDLER)\ndispatcher.add_handler(ARCTAN_HANDLER)\ndispatcher.add_handler(ABS_HANDLER)\ndispatcher.add_handler(LOG_HANDLER)\n","size_bytes":4438},"sitaBot/utils/dbfunc.py":{"content":"from sitaBot.mongo import db\nfrom typing import Dict, List, Union\n\n\ncoupledb = db.couple\n\n\n# Couple Chooser\n\nasync def _get_lovers(chat_id: int):\n    lovers = coupledb.find_one({\"chat_id\": chat_id})\n    if lovers:\n        lovers = lovers[\"couple\"]\n    else:\n        lovers = {}\n    return lovers\n\n\nasync def get_couple(chat_id: int, date: str):\n    lovers = await _get_lovers(chat_id)\n    if date in lovers:\n        return lovers[date]\n    else:\n        return False\n\n\nasync def save_couple(chat_id: int, date: str, couple: dict):\n    lovers = await _get_lovers(chat_id)\n    lovers[date] = couple\n    await coupledb.update_one(\n        {\"chat_id\": chat_id},\n        {\n            \"$set\": {\n                \"couple\": lovers\n            }\n        },\n        upsert=True\n    )\n","size_bytes":774},"sitaBot/modules/sql/disable_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String, UnicodeText, distinct, func\n\n\nclass Disable(BASE):\n    __tablename__ = \"disabled_commands\"\n    chat_id = Column(String(14), primary_key=True)\n    command = Column(UnicodeText, primary_key=True)\n\n    def __init__(self, chat_id, command):\n        self.chat_id = chat_id\n        self.command = command\n\n    def __repr__(self):\n        return \"Disabled cmd {} in {}\".format(self.command, self.chat_id)\n\n\nDisable.__table__.create(checkfirst=True)\nDISABLE_INSERTION_LOCK = threading.RLock()\n\nDISABLED = {}\n\n\ndef disable_command(chat_id, disable):\n    with DISABLE_INSERTION_LOCK:\n        disabled = SESSION.query(Disable).get((str(chat_id), disable))\n\n        if not disabled:\n            DISABLED.setdefault(str(chat_id), set()).add(disable)\n\n            disabled = Disable(str(chat_id), disable)\n            SESSION.add(disabled)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef enable_command(chat_id, enable):\n    with DISABLE_INSERTION_LOCK:\n        disabled = SESSION.query(Disable).get((str(chat_id), enable))\n\n        if disabled:\n            if enable in DISABLED.get(str(chat_id)):  # sanity check\n                DISABLED.setdefault(str(chat_id), set()).remove(enable)\n\n            SESSION.delete(disabled)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef is_command_disabled(chat_id, cmd):\n    return str(cmd).lower() in DISABLED.get(str(chat_id), set())\n\n\ndef get_all_disabled(chat_id):\n    return DISABLED.get(str(chat_id), set())\n\n\ndef num_chats():\n    try:\n        return SESSION.query(func.count(distinct(Disable.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef num_disabled():\n    try:\n        return SESSION.query(Disable).count()\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with DISABLE_INSERTION_LOCK:\n        chats = SESSION.query(Disable).filter(Disable.chat_id == str(old_chat_id)).all()\n        for chat in chats:\n            chat.chat_id = str(new_chat_id)\n            SESSION.add(chat)\n\n        if str(old_chat_id) in DISABLED:\n            DISABLED[str(new_chat_id)] = DISABLED.get(str(old_chat_id), set())\n\n        SESSION.commit()\n\n\ndef __load_disabled_commands():\n    global DISABLED\n    try:\n        all_chats = SESSION.query(Disable).all()\n        for chat in all_chats:\n            DISABLED.setdefault(chat.chat_id, set()).add(chat.command)\n\n    finally:\n        SESSION.close()\n\n\n__load_disabled_commands()\n","size_bytes":2607},"sitaBot/modules/tgraph_pyro.py":{"content":"import os\nfrom typing import Optional\n\nfrom pyrogram import filters\nfrom pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message\n\nfrom sitaBot import pbot\nimport requests\n\n\nCATBOX_URL = \"https://catbox.moe/user/api.php\"\n\n\ndef _upload_catbox(file_path: str) -> Optional[str]:\n    try:\n        with open(file_path, \"rb\") as f:\n            resp = requests.post(\n                CATBOX_URL,\n                data={\"reqtype\": \"fileupload\", \"json\": \"true\"},\n                files={\"fileToUpload\": f},\n                timeout=120,\n            )\n        if resp.status_code == 200:\n            return resp.text.strip()\n        return None\n    except Exception:\n        return None\n\n\n@pbot.on_message(filters.command([\"tgm\", \"tgt\", \"telegraph\", \"tl\"]))\nasync def tgraph_upload(_, m: Message):\n    if not m.reply_to_message:\n        return await m.reply_text(\"‚ùñ  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥á·¥Ö…™·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è …¢·¥á·¥õ ·¥Ä  ü…™…¥·¥ã\")\n\n    media = m.reply_to_message\n    size = 0\n    if getattr(media, \"photo\", None):\n        size = media.photo.file_size\n    elif getattr(media, \"video\", None):\n        size = media.video.file_size\n    elif getattr(media, \"document\", None):\n        size = media.document.file_size\n\n    status = await m.reply_text(\"‚ùç ·¥ò Ä·¥è·¥Ñ·¥áss…™…¥…¢...\")\n    try:\n        local = await media.download()\n        await status.edit_text(\"‚ùç ·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢...\")\n        url = _upload_catbox(local)\n        if not url:\n            await status.edit_text(\"‚ùñ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö “ì·¥Ä…™ ü·¥á·¥Ö\")\n            return\n        await status.edit_text(\n            f\"‚ùñ | [·¥õ·¥á ü·¥á…¢ Ä·¥Ä·¥ò ú  ü…™…¥·¥ã]({url}) | ‚ùñ\",\n            reply_markup=InlineKeyboardMarkup(\n                [[InlineKeyboardButton(\"‚Ä¢ ·¥õ·¥á ü·¥á…¢ Ä·¥Ä·¥ò ú  ü…™…¥·¥ã ‚Ä¢\", url=url)]]\n            ),\n            disable_web_page_preview=True,\n        )\n    finally:\n        try:\n            if 'local' in locals() and os.path.exists(local):\n                os.remove(local)\n        except Exception:\n            pass\n\n\n__mod_name__ = \"T-Graph\"\n__help__ = \"\"\"\n- /tgm, /tgt, /telegraph, /tl: Reply to any media to upload and get a link.\n\"\"\"\n\n\n","size_bytes":2170},"sitaBot/modules/games.py":{"content":"from telethon.tl.types import InputMediaDice\n\nfrom sitaBot.events import register\n\n\n@register(pattern=\"^/dice(?: |$)(.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    input_str = event.pattern_match.group(1)\n    r = await event.reply(file=InputMediaDice(\"\"))\n    input_int = int(input_str)\n    if input_int > 6:\n        await event.reply(\"hey nigga use number 1 to 6 only\")\n    \n    else:\n        try:\n            required_number = input_int\n            while r.media.value != required_number:\n                await r.delete()\n                r = await event.reply(file=InputMediaDice(\"\"))\n        except BaseException:\n            pass\n\n\n@register(pattern=\"^/dart(?: |$)(.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    input_str = event.pattern_match.group(1)\n    r = await event.reply(file=InputMediaDice(\"üéØ\"))\n    input_int = int(input_str)\n    if input_int > 6:\n        await event.reply(\"hey nigga use number 1 to 6 only\")\n    \n    else:\n        try:\n            required_number = input_int\n            while r.media.value != required_number:\n                await r.delete()\n                r = await event.reply(file=InputMediaDice(\"üéØ\"))\n        except BaseException:\n            pass\n\n\n@register(pattern=\"^/ball(?: |$)(.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    input_str = event.pattern_match.group(1)\n    r = await event.reply(file=InputMediaDice(\"üèÄ\"))\n    input_int = int(input_str)\n    if input_int > 5:\n        await event.reply(\"hey nigga use number 1 to 6 only\")\n    \n    else:\n        try:\n            required_number = input_int\n            while r.media.value != required_number:\n                await r.delete()\n                r = await event.reply(file=InputMediaDice(\"üèÄ\"))\n        except BaseException:\n            pass\n\n\n\n__help__ = \"\"\"\n *Play Game With Emojis:*\n  - /dice or /dice 1 to 6 any value\n  - /ball or /ball 1 to 5 any value\n  - /dart or /dart 1 to 6 any value\n Usage: hahaha just a magic.\n warning: you would be in trouble if you input any other value than mentioned.\n *Truth And Dare:*\n  - /Truth : for random truth.\n  - /dare : for random dare.\n\"\"\"\n\n__mod_name__ = \"Game\"\n","size_bytes":2183},"sitaBot/helper_extra/badmedia.py":{"content":"from sitaBot import telethn as tbot\nimport requests\nimport time\n\n\n\nasync def is_nsfw(event):\n    lmao = event\n    if not (\n            lmao.gif\n            or lmao.video\n            or lmao.video_note\n            or lmao.photo\n            or lmao.sticker\n            or lmao.media\n    ):\n        return False\n    if lmao.video or lmao.video_note or lmao.sticker or lmao.gif:\n        try:\n            starkstark = event.client.download_media(lmao.media, thumb=-1)\n        except:\n            return False\n    elif lmao.photo or lmao.sticker:\n        try:\n            starkstark = event.client.download_media(lmao.media)\n        except:\n            return False\n    img = starkstark\n    f = {\"file\": (img, open(img, \"rb\"))}\n    \n    r = requests.post(\"https://starkapi.herokuapp.com/nsfw/\", files = f).json()\n    if r.get(\"success\") is False:\n      is_nsfw = False\n    elif r.get(\"is_nsfw\") is True:\n      is_nsfw = True\n    elif r.get(\"is_nsfw\") is False:\n      is_nsfw = False\n    return is_nsfw\n","size_bytes":996},"sitaBot/modules/helper_funcs/__init__.py":{"content":"\"\"\"Helpers, also known as Utilities.\"\"\"\n","size_bytes":40},"sitaBot/modules/wallpaper.py":{"content":"from random import randint\n\nimport requests as r\nfrom sitaBot import SUPPORT_CHAT, WALL_API, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import Update\nfrom telegram.ext import CallbackContext, run_async\n\n# Wallpapers module by @TheRealPhoenix using wall.alphacoders.com\n\n\n@run_async\ndef wall(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    msg = update.effective_message\n    args = context.args\n    msg_id = update.effective_message.message_id\n    bot = context.bot\n    query = \" \".join(args)\n    if not query:\n        msg.reply_text(\"Please enter a query!\")\n        return\n    else:\n        caption = query\n        term = query.replace(\" \", \"%20\")\n        json_rep = r.get(\n            f\"https://wall.alphacoders.com/api2.0/get.php?auth={WALL_API}&method=search&term={term}\"\n        ).json()\n        if not json_rep.get(\"success\"):\n            msg.reply_text(f\"An error occurred! Report this @{SUPPORT_CHAT}\")\n        else:\n            wallpapers = json_rep.get(\"wallpapers\")\n            if not wallpapers:\n                msg.reply_text(\"No results found! Refine your search.\")\n                return\n            else:\n                index = randint(0, len(wallpapers) - 1)  # Choose random index\n                wallpaper = wallpapers[index]\n                wallpaper = wallpaper.get(\"url_image\")\n                wallpaper = wallpaper.replace(\"\\\\\", \"\")\n                bot.send_photo(\n                    chat_id,\n                    photo=wallpaper,\n                    caption=\"Preview\",\n                    reply_to_message_id=msg_id,\n                    timeout=60,\n                )\n                bot.send_document(\n                    chat_id,\n                    document=wallpaper,\n                    filename=\"wallpaper\",\n                    caption=caption,\n                    reply_to_message_id=msg_id,\n                    timeout=60,\n                )\n\n\nWALLPAPER_HANDLER = DisableAbleCommandHandler(\"wall\", wall)\ndispatcher.add_handler(WALLPAPER_HANDLER)\n","size_bytes":2058},"sitaBot/modules/fun_strings.py":{"content":"RUN_STRINGS = (\n    \"Now you see me, now you don't.\" \"Œµ=Œµ=Œµ=Œµ=‚îå(;Ôø£‚ñΩÔø£)‚îò\",\n    \"Get back here!\",\n    \"REEEEEEEEEEEEEEEEEE!!!!!!!\",\n    \"Look out for the wall!\",\n    \"Don't leave me alone with them!!\",\n    \"You've got company!\",\n    \"Chotto matte!\",\n    \"Yare yare daze\",\n    \"*Naruto run activated*\",\n    \"*Nezuko run activated*\",\n    \"Hey take responsibilty for what you just did!\",\n    \"May the odds be ever in your favour.\",\n    \"Run everyone, they just dropped a bomb üí£üí£\",\n    \"And they disappeared forever, never to be seen again.\",\n    \"Legend has it, they're still running.\",\n    \"Hasta la vista, baby.\",\n    \"Ah, what a waste. I liked that one.\",\n    \"As The Doctor would say... RUN!\",\n)\n\nGIFS = [\n    \"CgACAgQAAx0CSVUvGgAC7KpfWxMrgGyQs-GUUJgt-TSO8cOIDgACaAgAAlZD0VHT3Zynpr5nGxsE\",\n    \"CgACAgUAAx0CU_rCTAABAjdgX1s4NVaeCls6YaH3p43vgdCRwQIAAqsAA4P_MFUYQhyoR-kgpRsE\",\n    \"CgACAgUAAx0CU_rCTAABAjdSX1s3fq5iEJ64YeQLKI8cD7CSuSEAAlUBAAJu09hW5iqWB0hTPD4bBA\",\n]\n\nSLAP_YONE_TEMPLATES = (\n    \"Slap me one more time and I'll mute you.\",\n    \"Stop slapping me. REEEEEEEEEEEEEE.\",\n    [\n        \"I am muting you for a minute.\",  # normal reply\n        \"Stop slapping me just because I can't mute you. REEEEEEEEEE.\",  # reply to admin\n        \"tmute\",  # command\n        \"Shut up!\",\n        \"Silence!\",\n    ],\n)\n\nSLAP_TEMPLATES = (\n    \"{user2} was killed by magic.\",\n    \"{user2} starved without pats.\",\n    \"{user2} was knocked into the void by {user1}.\",\n    \"{user2} fainted.\",\n    \"{user2} is out of usable Pokemon! {user2} whited out!.\",\n    \"{user2} is out of usable Pokemon! {user2} blacked out!.\",\n    \"{user2} got rekt.\",\n    \"{user2}'s melon was split by {user1}.\",\n    \"{user2} was sliced and diced by {user1}.\",\n    \"{user2} played hot-potato with a grenade.\",\n    \"{user2} was knifed by {user1}.\",\n    \"{user2} ate a grenade.\",\n    \"{user2} is what's for dinner!\",\n    \"{user2} was terminated by {user1}.\",\n    \"{user1} spammed {user2}'s email.\",\n    \"{user1} RSA-encrypted {user2} and deleted the private key.\",\n    \"{user1} put {user2} in the friendzone.\",\n    \"{user1} slaps {user2} with a DMCA takedown request!\",\n    \"{user2} got a house call from Doctor {user1}.\",\n    \"{user1} beheaded {user2}.\",\n    \"{user2} got stoned...by an angry mob.\",\n    \"{user1} sued the pants off {user2}.\",\n    \"{user2} was one-hit KO'd by {user1}.\",\n    \"{user1} sent {user2} down the memory hole.\",\n    \"{user2} was a mistake. - '{user1}' \",\n    \"{user2} was made redundant.\",\n    \"{user1} {hits} {user2} with a bat!.\",\n    \"{user1} {hits} {user2} with a Taijutsu Kick!.\",\n    \"{user1} {hits} {user2} with X-Gloves!.\",\n    \"{user1} {hits} {user2} with a Jet Punch!.\",\n    \"{user1} {hits} {user2} with a Jet Pistol!.\",\n    \"{user1} {hits} {user2} with a United States of Smash!.\",\n    \"{user1} {hits} {user2} with a Detroit Smash!.\",\n    \"{user1} {hits} {user2} with a Texas Smash!.\",\n    \"{user1} {hits} {user2} with a California Smash!.\",\n    \"{user1} {hits} {user2} with a New Hampshire Smash!.\",\n    \"{user1} {hits} {user2} with a Missouri Smash!.\",\n    \"{user1} {hits} {user2} with a Carolina Smash!.\",\n    \"{user1} {hits} {user2} with a King Kong Gun!.\",\n    \"{user1} {hits} {user2} with a baseball bat - metal one.!.\",\n    \"*Serious punches {user2}*.\",\n    \"*Normal punches {user2}*.\",\n    \"*Consecutive Normal punches {user2}*.\",\n    \"*Two Handed Consecutive Normal Punches {user2}*.\",\n    \"*Ignores {user2} to let them die of embarassment*.\",\n    \"*points at {user2}* What's with this sassy... lost child?.\",\n    \"*Hits {user2} with a Fire Tornado*.\",\n    \"{user1} pokes {user2} in the eye !\",\n    \"{user1} pokes {user2} on the sides!\",\n    \"{user1} pokes {user2}!\",\n    \"{user1} pokes {user2} with a needle!\",\n    \"{user1} pokes {user2} with a pen!\",\n    \"{user1} pokes {user2} with a stun gun!\",\n    \"{user2} is secretly a Furry!\",\n    \"Hey Everybody! {user1} is asking me to be mean!\",\n    \"( ÔΩ•_ÔΩ•)Ôæâ‚åí‚óè~* (ÔΩ•.ÔΩ•;) <-{user2}\",\n    \"Take this {user2}\\n(ÔæâÔæü–îÔæü)Ôæâ ))))‚óè~* \",\n    \"Here {user2} hold this\\n(ÔΩÄ„Éªœâ„Éª)„Å§ ‚óè~Ôºä\",\n    \"( „Éª_„Éª)„ÉéŒû‚óè~*  {user2}\\nDieeeee!!.\",\n    \"( „Éª‚àÄ„Éª)ÔΩíÈπµ~<‚â™Â∑õ;Ôæü–îÔæü)Ôæâ\\n*Bug sprays {user2}*.\",\n    \"( Ôæü–îÔæü)ÔæâÂç†~<Â∑õÂ∑õÂ∑õ.\\n-{user2} You pest!\",\n    \"( „ÅÜ-¬¥)„Å•Ô∏ª‚ï¶ÃµÃµÃø‚ï§‚îÄ‚îÄ \\(Àö‚òêÀö‚Äù)/ {user2}.\",\n    \"{user1} {hits} {user2} with a {item}.\",\n    \"{user1} {hits} {user2} in the face with a {item}.\",\n    \"{user1} {hits} {user2} around a bit with a {item}.\",\n    \"{user1} {throws} a {item} at {user2}.\",\n    \"{user1} grabs a {item} and {throws} it at {user2}'s face.\",\n    \"{user1} launches a {item} in {user2}'s general direction.\",\n    \"{user1} starts slapping {user2} silly with a {item}.\",\n    \"{user1} pins {user2} down and repeatedly {hits} them with a {item}.\",\n    \"{user1} grabs up a {item} and {hits} {user2} with it.\",\n    \"{user1} ties {user2} to a chair and {throws} a {item} at them.\",\n    \"{user1} gave a friendly push to help {user2} learn to swim in lava.\",\n    \"{user1} bullied {user2}.\",\n    \"Nyaan ate {user2}'s leg. *nomnomnom*\",\n    \"{user1} {throws} a master ball at {user2}, resistance is futile.\",\n    \"{user1} hits {user2} with an action beam...bbbbbb (‡∏á„Éªœâ„Éª)‡∏á ====*\",\n    \"{user1} ara ara's {user2}.\",\n    \"{user1} ora ora's {user2}.\",\n    \"{user1} muda muda's {user2}.\",\n    \"{user2} was turned into a Jojo reference!\",\n    \"{user1} hits {user2} with {item}.\",\n    \"Round 2!..Ready? .. FIGHT!!\",\n    \"WhoPixel will oof {user2} to infinity and beyond.\",\n    \"{user2} ate a bat and discovered a new disease.\",\n    \"{user1} folded {user2} into a paper plane\",\n    \"{user1} served {user2} some bat soup.\",\n    \"{user2} was sent to his home, the planet of the apes.\",\n    \"{user1} kicked {user2} out of a moving train.\",\n    \"{user2} just killed John Wick‚Äôs dog.\",\n    \"{user1} performed an Avada Kedavra spell on {user2}.\",\n    \"{user1} subjected {user2} to a fiery furnace.\",\n    \"Sakura Haruno just got more useful than {user2}\",\n    \"{user1} unplugged {user2}'s life support.\",\n    \"{user1} subscribed {user2}' to 5 years of bad internet.\",\n    \"You know what‚Äôs worse than Dad jokes? {user2}!\",\n    \"{user1} took all of {user2}'s cookies.\",\n    \"{user2} wa mou.......Shindeiru! - {user1}.\",\n    \"{user2} lost his race piece!\",  # No game no life reference\n    \"Shut up {user2}, you are just {user2}.\",  # No game no life reference\n    \"{user1} hits {user2} with Aka si anse!\",  # No game no life reference\n    \"@NeoTheKitty scratches {user2}\",  # Pixels pet cat - @NeoTheKitty\n    \"Majin buu ate {user2}\",  # Dbz\n    \"Goblin slayer slays {user2}\",  # Goblin Slayer\n)\n\nPAT_TEMPLATES = (\n    \"{user1} pats {user2} on the head.\",\n    \"*gently rubs {user2}'s head*.\",\n    \"*{user1} mofumofus {user2}'s head*\",\n    \"*{user1} messes up {user2}'s head*\",\n    \"*{user1} intensly rubs {user2}'s head*\",\n    \"*{user2}'s waifu pats their head*\",\n    \"*{user2}'s got free headpats*\",\n    \"No pats for {user2}!\",\n    \"Oh no! We are all out of pats.\",\n    \"This is a designated no pat zone!\",\n    \"No pats for {user2}!\",\n    \"{user1} spoils {user2} with headpats!\",\n    \"{user2} received one free headpat!\",\n    \"{user1} headpats {user2} whilst giving a lap pillow\",\n    \"{user1} aggressively pats {user2}\",\n    \"{user1} gently strokes {user2}'s head\",\n    \"Pat, pat, pat, pat\",\n    \"{user2} could not escape {user1}'s headpats\",\n    \"{user2}.exe has stopped working\",\n    \"{user1} rubs {user2} on the neck\",\n    \"Must... extort... HEADPATS\",\n    \"{user1} headpats {user2}'s head with a pat\",\n    \"{user1} pats {user2} unexpectedly\",\n    \"{user1} pats {user2} with consent, maybe?\",\n    \"Pat pat, {user2} honto kawaii ne!\",\n    \"{user1} headpats {user2} at 420apm\",\n    \"{user1} bellyrubs {user2}\",\n    \"{user1} pats {user2} friendlily\",\n    \"{user2} uses HEADPATS? O KAWAII KOTO\",\n    \"*headpats.gif intensifies for {user2}*\",\n    \"(*¬¥œâ¬¥(*ÔΩÄœâÔΩÄ)\",\n    \"(ÔΩè„Éª_„Éª)„Éé‚Äù(·¥ó_ ·¥ó„ÄÇ)\",\n    \"(*Ôø£‚ñΩÔø£)„Éé‚Äù(- -*)\",\n    \"(„Å£¬¥œâ`)Ôæâ(‚ï•œâ‚ï•)\",\n    \"( ¬¥–îÔΩÄ)Ôæâ(¬¥ÔΩ•œâÔΩ•`) ÔæÖÔæÉÔæûÔæÖÔæÉÔæû\",\n)\n\nPAT_GIFS = (\n    \"CgACAgQAAxkBAALRX19Xs7tBdOH1gQwS_rglVRkTbgVYAAKEAgACmQn9UWlyGa_xy9_aGwQ\",\n    \"CgACAgEAAxkBAALRYF9Xs8EnhsDfDpld3ILoqTbzDmwxAAJFAAOJxjlHECanwn69E5QbBA\",\n)\n\nPAT_STICKERS = (\n    \"CAACAgQAAxkBAALRWV9Xs4HH0XaXfhZe-jWaZoXfs-IsAAJYAwACdDgSEHYOt4KvL02oGwQ\",\n    \"CAACAgQAAxkBAALRXF9Xs6XmIeDbnoL1wiDky0TdX-CvAAKKAQAC1TMzC9A3CtiT2rqVGwQ\",\n)\n\nPING_STRING = (\n    \"PONG!!\",\n    \"I am here!\",\n)\n\nITEMS = (\n    \"cast iron skillet\",\n    \"angry meow\",\n    \"cricket bat\",\n    \"wooden cane\",\n    \"shovel\",\n    \"toaster\",\n    \"book\",\n    \"laptop\",\n    \"rubber chicken\",\n    \"spiked bat\",\n    \"heavy rock\",\n    \"chunk of dirt\",\n    \"ton of bricks\",\n    \"rasengan\",\n    \"spirit bomb\",\n    \"100-Type Guanyin Bodhisattva\",\n    \"rasenshuriken\",\n    \"Murasame\",\n    \"ban\",\n    \"chunchunmaru\",\n    \"Kubikirib≈çch≈ç\",\n    \"rasengan\",\n    \"spherical flying kat\",\n)\n\nTHROW = (\n    \"throws\",\n    \"flings\",\n    \"chucks\",\n    \"hurls\",\n)\n\nHIT = (\n    \"hits\",\n    \"whacks\",\n    \"slaps\",\n    \"smacks\",\n    \"bashes\",\n    \"pats\",\n)\n\nEYES = [\n    [\"‚åê‚ñ†\", \"‚ñ†\"],\n    [\" Õ†¬∞\", \" ¬∞\"],\n    [\"‚áÄ\", \"‚Üº\"],\n    [\"¬¥‚Ä¢ \", \" ‚Ä¢`\"],\n    [\"¬¥\", \"`\"],\n    [\"`\", \"¬¥\"],\n    [\"√≥\", \"√≤\"],\n    [\"√≤\", \"√≥\"],\n    [\"‚∏å\", \"‚∏ç\"],\n    [\">\", \"<\"],\n    [\"∆∏ÃµÃ°\", \"∆∑\"],\n    [\"·óí\", \"·óï\"],\n    [\"‚üÉ\", \"‚üÑ\"],\n    [\"‚™ß\", \"‚™¶\"],\n    [\"‚™¶\", \"‚™ß\"],\n    [\"‚™©\", \"‚™®\"],\n    [\"‚™®\", \"‚™©\"],\n    [\"‚™∞\", \"‚™Ø\"],\n    [\"‚´ë\", \"‚´í\"],\n    [\"‚®¥\", \"‚®µ\"],\n    [\"‚©ø\", \"‚™Ä\"],\n    [\"‚©æ\", \"‚©Ω\"],\n    [\"‚©∫\", \"‚©π\"],\n    [\"‚©π\", \"‚©∫\"],\n    [\"‚ó•‚ñ∂\", \"‚óÄ‚ó§\"],\n    [\"‚óç\", \"‚óé\"],\n    [\"/Õ†-\", \"‚îêÕ°-\\\\\"],\n    [\"‚å£\", \"‚å£‚Äù\"],\n    [\" Õ°‚éö\", \" Õ°‚éö\"],\n    [\"‚âã\"],\n    [\"‡´¶‡™Å\"],\n    [\"  ÕØ\"],\n    [\"  Õå\"],\n    [\"‡∑Ö\"],\n    [\"‚óâ\"],\n    [\"‚òâ\"],\n    [\"„Éª\"],\n    [\"‚ñ∞\"],\n    [\"·µî\"],\n    [\" Ôæü\"],\n    [\"‚ñ°\"],\n    [\"‚òº\"],\n    [\"*\"],\n    [\"`\"],\n    [\"‚öÜ\"],\n    [\"‚äú\"],\n    [\">\"],\n    [\"‚ùç\"],\n    [\"Ôø£\"],\n    [\"‚îÄ\"],\n    [\"‚úø\"],\n    [\"‚Ä¢\"],\n    [\"T\"],\n    [\"^\"],\n    [\"‚±∫\"],\n    [\"@\"],\n    [\"»ç\"],\n    [\" Óñï \"],\n    [\" Óññ \"],\n    [\"x\"],\n    [\"-\"],\n    [\"$\"],\n    [\"»å\"],\n    [\" ò\"],\n    [\"Íùä\"],\n    [\"ÓÉó\"],\n    [\"‚∏ü\"],\n    [\"‡πè\"],\n    [\"‚¥≤\"],\n    [\"‚óï\"],\n    [\"‚óî\"],\n    [\"‚úß\"],\n    [\"‚ñ†\"],\n    [\"‚ô•\"],\n    [\" Õ°¬∞\"],\n    [\"¬¨\"],\n    [\" ¬∫ \"],\n    [\"‚®∂\"],\n    [\"‚®±\"],\n    [\"‚èì\"],\n    [\"‚èí\"],\n    [\"‚çú\"],\n    [\"‚ç§\"],\n    [\"·öñ\"],\n    [\"·¥ó\"],\n    [\"‡≤†\"],\n    [\"œÉ\"],\n    [\"‚òØ\"],\n]\n\nMOUTHS = [\n    [\"v\"],\n    [\"·¥•\"],\n    [\"·óù\"],\n    [\"—†\"],\n    [\"·óú\"],\n    [\"·é≤\"],\n    [\"·®ì\"],\n    [\"·®é\"],\n    [\"„ÉÆ\"],\n    [\"‚ï≠Õú ñ‚ïÆ\"],\n    [\" ÕüŸÑÕú\"],\n    [\" Õú ñ\"],\n    [\" Õü ñ\"],\n    [\"  ñÃØ\"],\n    [\"œâ\"],\n    [\" ¬≥\"],\n    [\" Œµ \"],\n    [\"Ôπè\"],\n    [\"‚ñ°\"],\n    [\"ŸÑÕú\"],\n    [\"‚Äø\"],\n    [\"‚ï≠‚ïÆ\"],\n    [\"‚Äø‚Äø\"],\n    [\"‚ñæ\"],\n    [\"‚Ä∏\"],\n    [\"–î\"],\n    [\"‚àÄ\"],\n    [\"!\"],\n    [\"‰∫∫\"],\n    [\".\"],\n    [\"„É≠\"],\n    [\"_\"],\n    [\"‡∑¥\"],\n    [\"—Ω\"],\n    [\"‡¥å\"],\n    [\"‚è†\"],\n    [\"‚èè\"],\n    [\"‚çä\"],\n    [\"‚çò\"],\n    [\"„ÉÑ\"],\n    [\"Áõä\"],\n    [\"‚ï≠‚à©‚ïÆ\"],\n    [\"ƒπÃØ\"],\n    [\"‚ó°\"],\n    [\" Õú„Å§\"],\n]\n\nEARS = [\n    [\"q\", \"p\"],\n    [\" ¢\", \" °\"],\n    [\"‚∏Æ\", \"?\"],\n    [\" ï\", \" î\"],\n    [\"·ñó\", \"·ñò\"],\n    [\"·ï¶\", \"·ï•\"],\n    [\"·ï¶(\", \")·ï•\"],\n    [\"·ïô(\", \")·ïó\"],\n    [\"·ò≥\", \"·ò∞\"],\n    [\"·ïÆ\", \"·ï≠\"],\n    [\"·ï≥\", \"·ï≤\"],\n    [\"(\", \")\"],\n    [\"[\", \"]\"],\n    [\"¬Ø\\\\_\", \"_/¬Ø\"],\n    [\"‡≠ß\", \"‡≠®\"],\n    [\"‡≠®\", \"‡≠ß\"],\n    [\"‚§ú(\", \")‚§è\"],\n    [\"‚òû\", \"‚òû\"],\n    [\"·ë´\", \"·ë∑\"],\n    [\"·ë¥\", \"·ë∑\"],\n    [\"„ÉΩ(\", \")Ôæâ\"],\n    [\"\\\\(\", \")/\"],\n    [\"‰πÅ(\", \")„Ñè\"],\n    [\"‚îî[\", \"]‚îò\"],\n    [\"(„Å•\", \")„Å•\"],\n    [\"(‡∏á\", \")‡∏á\"],\n    [\"‚éù\", \"‚é†\"],\n    [\"·Éö(\", \"·Éö)\"],\n    [\"·ïï(\", \")·ïó\"],\n    [\"(‚à©\", \")‚äÉ‚îÅ‚òÜÔæü.*\"],\n]\n\nTOSS = (\"Heads\", \"Tails\")\n\nEIGHTBALL = [\n    \"üü¢ As I see it, yes.\",\n    \"üü° Ask again later.\",\n    \"üü° Better not tell you now.\",\n    \"üü° Cannot predict now.\",\n    \"üü° Concentrate and ask again.\",\n    \"üü° Don‚Äôt count on it.\",\n    \"üü¢ It is certain.\",\n    \"üü¢ It is decidedly so.\",\n    \"üü¢ Most likely.\",\n    \"üî¥ My reply is no.\",\n    \"üî¥ My sources say no.\",\n    \"üî¥ Outlook not so good.\",\n    \"üü¢ Outlook good.\",\n    \"üü° Reply hazy, try again.\",\n    \"üü¢ Signs point to yes.\",\n    \"üî¥ Very doubtful.\",\n    \"üü¢ Without a doubt.\",\n    \"üü¢ Yes.\",\n    \"üü¢ Yes ‚Äì definitely.\",\n    \"üü¢ You may rely on it.\",\n]\n\nDECIDE = (\"Yes.\", \"No.\", \"Maybe.\")\n\nTABLE = (\n    \"(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÂΩ° ‚îª‚îÅ‚îª\",\n    \"I ran out of tables, will order more.\",\n    \"Go do some work instead of flippin tables.\",\n)\n","size_bytes":12516},"sitaBot/modules/helper_funcs/chat_status.py":{"content":"from time import perf_counter\nfrom functools import wraps\nfrom cachetools import TTLCache\nfrom threading import RLock\nfrom sitaBot import (\n    DEL_CMDS,\n    DEV_USERS,\n    DRAGONS,\n    SUPPORT_CHAT,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    dispatcher,\n)\n\nfrom telegram import Chat, ChatMember, ParseMode, Update\nfrom telegram.ext import CallbackContext\n\n# stores admemes in memory for 10 min.\nADMIN_CACHE = TTLCache(maxsize=512, ttl=60 * 10, timer=perf_counter)\nTHREAD_LOCK = RLock()\n\n\ndef is_whitelist_plus(chat: Chat, user_id: int, member: ChatMember = None) -> bool:\n    return any(user_id in user for user in [WOLVES, TIGERS, DEMONS, DRAGONS, DEV_USERS])\n\n\ndef is_support_plus(chat: Chat, user_id: int, member: ChatMember = None) -> bool:\n    return user_id in DEMONS or user_id in DRAGONS or user_id in DEV_USERS\n\n\ndef is_sudo_plus(chat: Chat, user_id: int, member: ChatMember = None) -> bool:\n    return user_id in DRAGONS or user_id in DEV_USERS\n\n\ndef is_user_admin(chat: Chat, user_id: int, member: ChatMember = None) -> bool:\n    if (\n        chat.type == \"private\"\n        or user_id in DRAGONS\n        or user_id in DEV_USERS\n        or chat.all_members_are_administrators\n        or user_id in [777000, 1087968824]\n    ):  # Count telegram and Group Anonymous as admin\n        return True\n    if not member:\n        with THREAD_LOCK:\n            # try to fetch from cache first.\n            try:\n                return user_id in ADMIN_CACHE[chat.id]\n            except KeyError:\n                # keyerror happend means cache is deleted,\n                # so query bot api again and return user status\n                # while saving it in cache for future useage...\n                chat_admins = dispatcher.bot.getChatAdministrators(chat.id)\n                admin_list = [x.user.id for x in chat_admins]\n                ADMIN_CACHE[chat.id] = admin_list\n\n                return user_id in admin_list\n    else:\n        return member.status in (\"administrator\", \"creator\")\n\n\ndef is_bot_admin(chat: Chat, bot_id: int, bot_member: ChatMember = None) -> bool:\n    if chat.type == \"private\" or chat.all_members_are_administrators:\n        return True\n\n    if not bot_member:\n        bot_member = chat.get_member(bot_id)\n\n    return bot_member.status in (\"administrator\", \"creator\")\n\n\ndef can_delete(chat: Chat, bot_id: int) -> bool:\n    return chat.get_member(bot_id).can_delete_messages\n\n\ndef is_user_ban_protected(chat: Chat, user_id: int, member: ChatMember = None) -> bool:\n    if (\n        chat.type == \"private\"\n        or user_id in DRAGONS\n        or user_id in DEV_USERS\n        or user_id in WOLVES\n        or user_id in TIGERS\n        or chat.all_members_are_administrators\n        or user_id in [777000, 1087968824]\n    ):  # Count telegram and Group Anonymous as admin\n        return True\n\n    if not member:\n        member = chat.get_member(user_id)\n\n    return member.status in (\"administrator\", \"creator\")\n\n\ndef is_user_in_chat(chat: Chat, user_id: int) -> bool:\n    member = chat.get_member(user_id)\n    return member.status not in (\"left\", \"kicked\")\n\n\ndef dev_plus(func):\n    @wraps(func)\n    def is_dev_plus_func(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user\n\n        if user.id in DEV_USERS:\n            return func(update, context, *args, **kwargs)\n        elif not user:\n            pass\n        elif DEL_CMDS and \" \" not in update.effective_message.text:\n            try:\n                update.effective_message.delete()\n            except:\n                pass\n        else:\n            update.effective_message.reply_text(\n                \"This is a developer restricted command.\"\n                \" You do not have permissions to run this.\"\n            )\n\n    return is_dev_plus_func\n\n\ndef sudo_plus(func):\n    @wraps(func)\n    def is_sudo_plus_func(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and is_sudo_plus(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        elif not user:\n            pass\n        elif DEL_CMDS and \" \" not in update.effective_message.text:\n            try:\n                update.effective_message.delete()\n            except:\n                pass\n        else:\n            update.effective_message.reply_text(\n                \"Who dis non-admin telling me what to do? You want a punch?\"\n            )\n\n    return is_sudo_plus_func\n\n\ndef support_plus(func):\n    @wraps(func)\n    def is_support_plus_func(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and is_support_plus(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        elif DEL_CMDS and \" \" not in update.effective_message.text:\n            try:\n                update.effective_message.delete()\n            except:\n                pass\n\n    return is_support_plus_func\n\n\ndef whitelist_plus(func):\n    @wraps(func)\n    def is_whitelist_plus_func(\n        update: Update, context: CallbackContext, *args, **kwargs\n    ):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and is_whitelist_plus(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(\n                f\"You don't have access to use this.\\nVisit @{SUPPORT_CHAT}\"\n            )\n\n    return is_whitelist_plus_func\n\n\ndef user_admin(func):\n    @wraps(func)\n    def is_admin(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and is_user_admin(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        elif not user:\n            pass\n        elif DEL_CMDS and \" \" not in update.effective_message.text:\n            try:\n                update.effective_message.delete()\n            except:\n                pass\n        else:\n            update.effective_message.reply_text(\n                \"Who dis non-admin telling me what to do? You want a punch?\"\n            )\n\n    return is_admin\n\n\ndef user_admin_no_reply(func):\n    @wraps(func)\n    def is_not_admin_no_reply(\n        update: Update, context: CallbackContext, *args, **kwargs\n    ):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and is_user_admin(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        elif not user:\n            pass\n        elif DEL_CMDS and \" \" not in update.effective_message.text:\n            try:\n                update.effective_message.delete()\n            except:\n                pass\n\n    return is_not_admin_no_reply\n\n\ndef user_not_admin(func):\n    @wraps(func)\n    def is_not_admin(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user\n        chat = update.effective_chat\n\n        if user and not is_user_admin(chat, user.id):\n            return func(update, context, *args, **kwargs)\n        elif not user:\n            pass\n\n    return is_not_admin\n\n\ndef bot_admin(func):\n    @wraps(func)\n    def is_admin(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        chat = update.effective_chat\n        update_chat_title = chat.title\n        message_chat_title = update.effective_message.chat.title\n\n        if update_chat_title == message_chat_title:\n            not_admin = \"I'm not admin! - REEEEEE\"\n        else:\n            not_admin = f\"I'm not admin in <b>{update_chat_title}</b>! - REEEEEE\"\n\n        if is_bot_admin(chat, bot.id):\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(not_admin, parse_mode=ParseMode.HTML)\n\n    return is_admin\n\n\ndef bot_can_delete(func):\n    @wraps(func)\n    def delete_rights(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        chat = update.effective_chat\n        update_chat_title = chat.title\n        message_chat_title = update.effective_message.chat.title\n\n        if update_chat_title == message_chat_title:\n            cant_delete = \"I can't delete messages here!\\nMake sure I'm admin and can delete other user's messages.\"\n        else:\n            cant_delete = f\"I can't delete messages in <b>{update_chat_title}</b>!\\nMake sure I'm admin and can delete other user's messages there.\"\n\n        if can_delete(chat, bot.id):\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(cant_delete, parse_mode=ParseMode.HTML)\n\n    return delete_rights\n\n\ndef can_pin(func):\n\n    @wraps(func)\n    def pin_rights(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        chat = update.effective_chat\n        update_chat_title = chat.title\n        message_chat_title = update.effective_message.chat.title\n\n        if update_chat_title == message_chat_title:\n            cant_pin = \"I can't pin messages here!\\nMake sure I'm admin and can pin messages.\"\n        else:\n            cant_pin = f\"I can't pin messages in <b>{update_chat_title}</b>!\\nMake sure I'm admin and can pin messages there.\"\n\n        if chat.get_member(bot.id).can_pin_messages:\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(\n                cant_pin, parse_mode=ParseMode.HTML)\n\n    return pin_rights\n\ndef can_promote(func):\n    @wraps(func)\n    def promote_rights(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        chat = update.effective_chat\n        update_chat_title = chat.title\n        message_chat_title = update.effective_message.chat.title\n\n        if update_chat_title == message_chat_title:\n            cant_promote = \"I can't promote/demote people here!\\nMake sure I'm admin and can appoint new admins.\"\n        else:\n            cant_promote = (\n                f\"I can't promote/demote people in <b>{update_chat_title}</b>!\\n\"\n                f\"Make sure I'm admin there and can appoint new admins.\"\n            )\n\n        if chat.get_member(bot.id).can_promote_members:\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(cant_promote, parse_mode=ParseMode.HTML)\n\n    return promote_rights\n\n\ndef can_restrict(func):\n    @wraps(func)\n    def restrict_rights(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        chat = update.effective_chat\n        update_chat_title = chat.title\n        message_chat_title = update.effective_message.chat.title\n\n        if update_chat_title == message_chat_title:\n            cant_restrict = \"I can't restrict people here!\\nMake sure I'm admin and can restrict users.\"\n        else:\n            cant_restrict = f\"I can't restrict people in <b>{update_chat_title}</b>!\\nMake sure I'm admin there and can restrict users.\"\n\n        if chat.get_member(bot.id).can_restrict_members:\n            return func(update, context, *args, **kwargs)\n        else:\n            update.effective_message.reply_text(\n                cant_restrict, parse_mode=ParseMode.HTML\n            )\n\n    return restrict_rights\n\n\ndef user_can_ban(func):\n    @wraps(func)\n    def user_is_banhammer(update: Update, context: CallbackContext, *args, **kwargs):\n        bot = context.bot\n        user = update.effective_user.id\n        member = update.effective_chat.get_member(user)\n        if (\n            not (member.can_restrict_members or member.status == \"creator\")\n            and user not in DRAGONS\n            and user not in [777000, 1087968824]\n        ):\n            update.effective_message.reply_text(\n                \"üòπ Sorry You can't do that\"\n            )\n            return \"\"\n        return func(update, context, *args, **kwargs)\n\n    return user_is_banhammer\n\n\ndef connection_status(func):\n    @wraps(func)\n    def connected_status(update: Update, context: CallbackContext, *args, **kwargs):\n        conn = connected(\n            context.bot,\n            update,\n            update.effective_chat,\n            update.effective_user.id,\n            need_admin=False,\n        )\n\n        if conn:\n            chat = dispatcher.bot.getChat(conn)\n            update.__setattr__(\"_effective_chat\", chat)\n            return func(update, context, *args, **kwargs)\n        else:\n            if update.effective_message.chat.type == \"private\":\n                update.effective_message.reply_text(\n                    \"Send /connect in a group that you and I have in common first.\"\n                )\n                return connected_status\n\n            return func(update, context, *args, **kwargs)\n\n    return connected_status\n\n\n# Workaround for circular import with connection.py\nfrom sitaBot.modules import connection\n\nconnected = connection.connected\n","size_bytes":13179},"sitaBot/modules/sql/__init__.py":{"content":"from sitaBot import DB_URI\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\n\ndef start() -> scoped_session:\n    engine = create_engine(DB_URI, client_encoding=\"utf8\")\n    BASE.metadata.bind = engine\n    BASE.metadata.create_all(engine)\n    # Lightweight migrations for bigint Telegram IDs\n    with engine.connect() as conn:\n        for stmt in [\n            'ALTER TABLE IF EXISTS users ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS approval ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS afk_users ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS warns ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS userinfo ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS userbio ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS gbans ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS connection ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS connection_history ALTER COLUMN user_id TYPE BIGINT USING user_id::bigint',\n            'ALTER TABLE IF EXISTS chat_members ALTER COLUMN \"user\" TYPE BIGINT USING \"user\"::bigint',\n        ]:\n            try:\n                conn.execute(text(stmt))\n            except Exception:\n                pass\n    return scoped_session(sessionmaker(bind=engine, autoflush=False))\n\n\nBASE = declarative_base()\nSESSION = start()\n","size_bytes":1704},"sitaBot/pyrogramee/pluginshelper.py":{"content":"import asyncio\nimport math\nimport shlex\nimport sys\nimport time\nimport traceback\nfrom functools import wraps\nfrom typing import Callable, Coroutine, Dict, List, Tuple, Union\n\nfrom PIL import Image\nfrom pyrogram import Client\nfrom pyrogram.enums import ChatMembersFilter\nfrom pyrogram.errors import FloodWait, MessageNotModified\nfrom pyrogram.types import Chat, Message, User\n\nfrom sitaBot  import OWNER_ID, SUPPORT_CHAT\nfrom sitaBot import pbot\n\n\ndef get_user(message: Message, text: str) -> [int, str, None]:\n    if text is None:\n        asplit = None\n    else:\n        asplit = text.split(\" \", 1)\n    user_s = None\n    reason_ = None\n    if message.reply_to_message:\n        user_s = message.reply_to_message.from_user.id\n        reason_ = text if text else None\n    elif asplit is None:\n        return None, None\n    elif len(asplit[0]) > 0:\n        user_s = int(asplit[0]) if asplit[0].isdigit() else asplit[0]\n        if len(asplit) == 2:\n            reason_ = asplit[1]\n    return user_s, reason_\n\n\ndef get_readable_time(seconds: int) -> int:\n    count = 0\n    ping_time = \"\"\n    time_list = []\n    time_suffix_list = [\"s\", \"m\", \"h\", \"days\"]\n\n    while count < 4:\n        count += 1\n        if count < 3:\n            remainder, result = divmod(seconds, 60)\n        else:\n            remainder, result = divmod(seconds, 24)\n        if seconds == 0 and remainder == 0:\n            break\n        time_list.append(int(result))\n        seconds = int(remainder)\n\n    for x in range(len(time_list)):\n        time_list[x] = str(time_list[x]) + time_suffix_list[x]\n    if len(time_list) == 4:\n        ping_time += time_list.pop() + \", \"\n\n    time_list.reverse()\n    ping_time += \":\".join(time_list)\n\n    return ping_time\n\n\ndef time_formatter(milliseconds: int) -> str:\n    seconds, milliseconds = divmod(int(milliseconds), 1000)\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    days, hours = divmod(hours, 24)\n    tmp = (\n        ((str(days) + \" day(s), \") if days else \"\")\n        + ((str(hours) + \" hour(s), \") if hours else \"\")\n        + ((str(minutes) + \" minute(s), \") if minutes else \"\")\n        + ((str(seconds) + \" second(s), \") if seconds else \"\")\n        + ((str(milliseconds) + \" millisecond(s), \") if milliseconds else \"\")\n    )\n    return tmp[:-2]\n\n\nasync def delete_or_pass(message):\n    if message.from_user.id == 1141839926:\n        return message\n    return await message.delete()\n\n\ndef humanbytes(size):\n    if not size:\n        return \"\"\n    power = 2 ** 10\n    raised_to_pow = 0\n    dict_power_n = {0: \"\", 1: \"Ki\", 2: \"Mi\", 3: \"Gi\", 4: \"Ti\"}\n    while size > power:\n        size /= power\n        raised_to_pow += 1\n    return str(round(size, 2)) + \" \" + dict_power_n[raised_to_pow] + \"B\"\n\n\nasync def progress(current, total, message, start, type_of_ps, file_name=None):\n    now = time.time()\n    diff = now - start\n    if round(diff % 10.00) == 0 or current == total:\n        percentage = current * 100 / total\n        speed = current / diff\n        elapsed_time = round(diff) * 1000\n        if elapsed_time == 0:\n            return\n        time_to_completion = round((total - current) / speed) * 1000\n        estimated_total_time = elapsed_time + time_to_completion\n        progress_str = \"{0}{1} {2}%\\n\".format(\n            \"\".join([\"üî¥\" for i in range(math.floor(percentage / 10))]),\n            \"\".join([\"üîò\" for i in range(10 - math.floor(percentage / 10))]),\n            round(percentage, 2),\n        )\n        tmp = progress_str + \"{0} of {1}\\nETA: {2}\".format(\n            humanbytes(current), humanbytes(total), time_formatter(estimated_total_time)\n        )\n        if file_name:\n            try:\n                await message.edit(\n                    \"{}\\n**File Name:** `{}`\\n{}\".format(type_of_ps, file_name, tmp)\n                )\n            except FloodWait as e:\n                await asyncio.sleep(e.x)\n            except MessageNotModified:\n                pass\n        else:\n            try:\n                await message.edit(\"{}\\n{}\".format(type_of_ps, tmp))\n            except FloodWait as e:\n                await asyncio.sleep(e.x)\n            except MessageNotModified:\n                pass\n\n\ndef get_text(message: Message) -> [None, str]:\n    text_to_return = message.text\n    if message.text is None:\n        return None\n    if \" \" in text_to_return:\n        try:\n            return message.text.split(None, 1)[1]\n        except IndexError:\n            return None\n    else:\n        return None\n\n\nasync def iter_chats(client):\n    chats = []\n    async for dialog in client.iter_dialogs():\n        if dialog.chat.type in [\"supergroup\", \"channel\"]:\n            chats.append(dialog.chat.id)\n    return chats\n\n\nasync def fetch_audio(client, message):\n    time.time()\n    if not message.reply_to_message:\n        await message.reply(\"`Reply To A Video / Audio.`\")\n        return\n    warner_stark = message.reply_to_message\n    if warner_stark.audio is None and warner_stark.video is None:\n        await message.reply(\"`Format Not Supported`\")\n        return\n    if warner_stark.video:\n        lel = await message.reply(\"`Video Detected, Converting To Audio !`\")\n        warner_bros = await message.reply_to_message.download()\n        stark_cmd = f\"ffmpeg -i {warner_bros} -map 0:a friday.mp3\"\n        await runcmd(stark_cmd)\n        final_warner = \"friday.mp3\"\n    elif warner_stark.audio:\n        lel = await edit_or_reply(message, \"`Download Started !`\")\n        final_warner = await message.reply_to_message.download()\n    await lel.edit(\"`Almost Done!`\")\n    await lel.delete()\n    return final_warner\n\n\nasync def edit_or_reply(message, text, parse_mode=\"md\"):\n    if message.from_user.id:\n        if message.reply_to_message:\n            kk = message.reply_to_message.message_id\n            return await message.reply_text(\n                text, reply_to_message_id=kk, parse_mode=parse_mode\n            )\n        return await message.reply_text(text, parse_mode=parse_mode)\n    return await message.edit(text, parse_mode=parse_mode)\n\n\nasync def runcmd(cmd: str) -> Tuple[str, str, int, int]:\n    \"\"\" run command in terminal \"\"\"\n    args = shlex.split(cmd)\n    process = await asyncio.create_subprocess_exec(\n        *args, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE\n    )\n    stdout, stderr = await process.communicate()\n    return (\n        stdout.decode(\"utf-8\", \"replace\").strip(),\n        stderr.decode(\"utf-8\", \"replace\").strip(),\n        process.returncode,\n        process.pid,\n    )\n\n\nasync def convert_to_image(message, client) -> [None, str]:\n    \"\"\"Convert Most Media Formats To Raw Image\"\"\"\n    final_path = None\n    if not (\n        message.reply_to_message.photo\n        or message.reply_to_message.sticker\n        or message.reply_to_message.media\n        or message.reply_to_message.animation\n        or message.reply_to_message.audio\n    ):\n        return None\n    if message.reply_to_message.photo:\n        final_path = await message.reply_to_message.download()\n    elif message.reply_to_message.sticker:\n        if message.reply_to_message.sticker.mime_type == \"image/webp\":\n            final_path = \"webp_to_png_s_proton.png\"\n            path_s = await message.reply_to_message.download()\n            im = Image.open(path_s)\n            im.save(final_path, \"PNG\")\n        else:\n            path_s = await client.download_media(message.reply_to_message)\n            final_path = \"lottie_proton.png\"\n            cmd = (\n                f\"lottie_convert.py --frame 0 -if lottie -of png {path_s} {final_path}\"\n            )\n            await runcmd(cmd)\n    elif message.reply_to_message.audio:\n        thumb = message.reply_to_message.audio.thumbs[0].file_id\n        final_path = await client.download_media(thumb)\n    elif message.reply_to_message.video or message.reply_to_message.animation:\n        final_path = \"fetched_thumb.png\"\n        vid_path = await client.download_media(message.reply_to_message)\n        await runcmd(f\"ffmpeg -i {vid_path} -filter:v scale=500:500 -an {final_path}\")\n    return final_path\n\n\ndef get_text(message: Message) -> [None, str]:\n    \"\"\"Extract Text From Commands\"\"\"\n    text_to_return = message.text\n    if message.text is None:\n        return None\n    if \" \" in text_to_return:\n        try:\n            return message.text.split(None, 1)[1]\n        except IndexError:\n            return None\n    else:\n        return None\n\n\n# Admin check\n\nadmins: Dict[str, List[User]] = {}\n\n\ndef set(chat_id: Union[str, int], admins_: List[User]):\n    if isinstance(chat_id, int):\n        chat_id = str(chat_id)\n\n    admins[chat_id] = admins_\n\n\ndef get(chat_id: Union[str, int]) -> Union[List[User], bool]:\n    if isinstance(chat_id, int):\n        chat_id = str(chat_id)\n\n    if chat_id in admins:\n        return admins[chat_id]\n\n    return False\n\n\nasync def get_administrators(chat: Chat) -> List[User]:\n    _get = get(chat.id)\n\n    if _get:\n        return _get\n    else:\n        admin_list = []\n        async for member in chat.get_members(filter=ChatMembersFilter.ADMINISTRATORS):\n            admin_list.append(member.user)\n        set(chat.id, admin_list)\n        return await get_administrators(chat)\n\n\ndef admins_only(func: Callable) -> Coroutine:\n    async def wrapper(client: Client, message: Message):\n        if message.from_user.id == OWNER_ID:\n            return await func(client, message)\n        admins = await get_administrators(message.chat)\n        for admin in admins:\n            if admin.id == message.from_user.id:\n                return await func(client, message)\n\n    return wrapper\n\n\n# @Mr_Dark_Prince\ndef capture_err(func):\n    @wraps(func)\n    async def capture(client, message, *args, **kwargs):\n        try:\n            return await func(client, message, *args, **kwargs)\n        except Exception as err:\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            errors = traceback.format_exception(\n                etype=exc_type,\n                value=exc_obj,\n                tb=exc_tb,\n            )\n            error_feedback = split_limits(\n                \"**ERROR** | `{}` | `{}`\\n\\n```{}```\\n\\n```{}```\\n\".format(\n                    0 if not message.from_user else message.from_user.id,\n                    0 if not message.chat else message.chat.id,\n                    message.text or message.caption,\n                    \"\".join(errors),\n                ),\n            )\n            for x in error_feedback:\n                await pbot.send_message(SUPPORT_CHAT, x)\n            raise err\n\n    return capture\n\n\n# Special credits to TheHamkerCat\n\n\nasync def member_permissions(chat_id, user_id):\n    perms = []\n    member = await pbot.get_chat_member(chat_id, user_id)\n    if member.can_post_messages:\n        perms.append(\"can_post_messages\")\n    if member.can_edit_messages:\n        perms.append(\"can_edit_messages\")\n    if member.can_delete_messages:\n        perms.append(\"can_delete_messages\")\n    if member.can_restrict_members:\n        perms.append(\"can_restrict_members\")\n    if member.can_promote_members:\n        perms.append(\"can_promote_members\")\n    if member.can_change_info:\n        perms.append(\"can_change_info\")\n    if member.can_invite_users:\n        perms.append(\"can_invite_users\")\n    if member.can_pin_messages:\n        perms.append(\"can_pin_messages\")\n    return perms","size_bytes":11288},"sitaBot/modules/sql/chatbot_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String\n\n\nclass ChatbotChats(BASE):\n    __tablename__ = \"chatbot_chats\"\n    chat_id = Column(String(14), primary_key=True)\n    ses_id = Column(String(70))\n    expires = Column(String(15))\n\n    def __init__(self, chat_id, ses_id, expires):\n        self.chat_id = chat_id\n        self.ses_id = ses_id\n        self.expires = expires\n\n\nChatbotChats.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\n\n\ndef is_chat(chat_id):\n    try:\n        chat = SESSION.query(ChatbotChats).get(str(chat_id))\n        if chat:\n            return True\n        else:\n            return False\n    finally:\n        SESSION.close()\n\n\ndef set_ses(chat_id, ses_id, expires):\n    with INSERTION_LOCK:\n        autochat = SESSION.query(ChatbotChats).get(str(chat_id))\n        if not autochat:\n            autochat = ChatbotChats(str(chat_id), str(ses_id), str(expires))\n        else:\n            autochat.ses_id = str(ses_id)\n            autochat.expires = str(expires)\n\n        SESSION.add(autochat)\n        SESSION.commit()\n\n\ndef get_ses(chat_id):\n    autochat = SESSION.query(ChatbotChats).get(str(chat_id))\n    sesh = \"\"\n    exp = \"\"\n    if autochat:\n        sesh = str(autochat.ses_id)\n        exp = str(autochat.expires)\n\n    SESSION.close()\n    return sesh, exp\n\n\ndef rem_chat(chat_id):\n    with INSERTION_LOCK:\n        autochat = SESSION.query(ChatbotChats).get(str(chat_id))\n        if autochat:\n            SESSION.delete(autochat)\n\n        SESSION.commit()\n\n\ndef get_all_chats():\n    try:\n        return SESSION.query(ChatbotChats.chat_id).all()\n    finally:\n        SESSION.close()\n","size_bytes":1677},"sitaBot/modules/helper_funcs/telethn/__init__.py":{"content":"from sitaBot import DEV_USERS, DRAGONS, DEMONS, TIGERS, WOLVES, telethn\n\nIMMUNE_USERS = DRAGONS + WOLVES + DEMONS + TIGERS + DEV_USERS\n\nIMMUNE_USERS = (\n    list(DRAGONS) + list(WOLVES) + list(DEMONS) + list(TIGERS) + list(DEV_USERS)\n)\n","size_bytes":236},"sitaBot/helper_extra/admin_rights.py":{"content":"from telegram import User, Chat\n\n\ndef user_can_promote(chat: Chat, user: User, bot_id: int) -> bool:\n    return chat.get_member(user.id).can_promote_members\n\n\ndef user_can_ban(chat: Chat, user: User, bot_id: int) -> bool:\n    return chat.get_member(user.id).can_restrict_members\n\n\ndef user_can_pin(chat: Chat, user: User, bot_id: int) -> bool:\n    return chat.get_member(user.id).can_pin_messages\n\n\ndef user_can_changeinfo(chat: Chat, user: User, bot_id: int) -> bool:\n    return chat.get_member(user.id).can_change_info\n","size_bytes":521},"sitaBot/events.py":{"content":"from telethon import events\nfrom sitaBot import telethn\n\n\ndef register(**args):\n    \"\"\" Registers a new message. \"\"\"\n    pattern = args.get(\"pattern\", None)\n\n    r_pattern = r\"^[/!]\"\n\n    if pattern is not None and not pattern.startswith(\"(?i)\"):\n        args[\"pattern\"] = \"(?i)\" + pattern\n\n    args[\"pattern\"] = pattern.replace(\"^/\", r_pattern, 1)\n\n    def decorator(func):\n        telethn.add_event_handler(func, events.NewMessage(**args))\n        return func\n\n    return decorator\n\n\ndef chataction(**args):\n    \"\"\" Registers chat actions. \"\"\"\n\n    def decorator(func):\n        telethn.add_event_handler(func, events.ChatAction(**args))\n        return func\n\n    return decorator\n\n\ndef userupdate(**args):\n    \"\"\" Registers user updates. \"\"\"\n\n    def decorator(func):\n        telethn.add_event_handler(func, events.UserUpdate(**args))\n        return func\n\n    return decorator\n\n\ndef inlinequery(**args):\n    \"\"\" Registers inline query. \"\"\"\n    pattern = args.get(\"pattern\", None)\n\n    if pattern is not None and not pattern.startswith(\"(?i)\"):\n        args[\"pattern\"] = \"(?i)\" + pattern\n\n    def decorator(func):\n        telethn.add_event_handler(func, events.InlineQuery(**args))\n        return func\n\n    return decorator\n\n\ndef callbackquery(**args):\n    \"\"\" Registers inline query. \"\"\"\n\n    def decorator(func):\n        telethn.add_event_handler(func, events.CallbackQuery(**args))\n        return func\n\n    return decorator\n\n","size_bytes":1428},"sitaBot/modules/dev.py":{"content":"import os\nimport subprocess\nimport sys\n\nfrom contextlib import suppress\nfrom time import sleep\n\nimport sitaBot\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom telegram import TelegramError, Update\nfrom telegram.error import Unauthorized\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\n@run_async\n@dev_plus\ndef allow_groups(update: Update, context: CallbackContext):\n    args = context.args\n    if not args:\n        update.effective_message.reply_text(f\"Current state: {sitaBot.ALLOW_CHATS}\")\n        return\n    if args[0].lower() in [\"off\", \"no\"]:\n        sitaBot.ALLOW_CHATS = True\n    elif args[0].lower() in [\"yes\", \"on\"]:\n        sitaBot.ALLOW_CHATS = False\n    else:\n        update.effective_message.reply_text(\"Format: /lockdown Yes/No or Off/On\")\n        return\n    update.effective_message.reply_text(\"Done! Lockdown value toggled.\")\n\n@run_async\n@dev_plus\ndef leave(update: Update, context: CallbackContext):\n    bot = context.bot\n    args = context.args\n    if args:\n        chat_id = str(args[0])\n        try:\n            bot.leave_chat(int(chat_id))\n        except TelegramError:\n            update.effective_message.reply_text(\n                \"Beep boop, I could not leave that group(dunno why tho).\"\n            )\n            return\n        with suppress(Unauthorized):\n            update.effective_message.reply_text(\"Beep boop, I left that soup!.\")\n    else:\n        update.effective_message.reply_text(\"Send a valid chat ID\")\n\n\n@run_async\n@dev_plus\ndef gitpull(update: Update, context: CallbackContext):\n    sent_msg = update.effective_message.reply_text(\n        \"Pulling all changes from remote and then attempting to restart.\"\n    )\n    subprocess.Popen(\"git pull\", stdout=subprocess.PIPE, shell=True)\n\n    sent_msg_text = sent_msg.text + \"\\n\\nChanges pulled...I guess.. Restarting in \"\n\n    for i in reversed(range(5)):\n        sent_msg.edit_text(sent_msg_text + str(i + 1))\n        sleep(1)\n\n    sent_msg.edit_text(\"Restarted.\")\n\n    os.system(\"restart.bat\")\n    os.execv(\"start.bat\", sys.argv)\n\n\n@run_async\n@dev_plus\ndef restart(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(\n        \"Starting a new instance and shutting down this one\"\n    )\n\n    os.system(\"restart.bat\")\n    os.execv(\"start.bat\", sys.argv)\n\n\nLEAVE_HANDLER = CommandHandler(\"leave\", leave)\nGITPULL_HANDLER = CommandHandler(\"gitpull\", gitpull)\nRESTART_HANDLER = CommandHandler(\"reboot\", restart)\nALLOWGROUPS_HANDLER = CommandHandler(\"lockdown\", allow_groups)\n\ndispatcher.add_handler(ALLOWGROUPS_HANDLER)\ndispatcher.add_handler(LEAVE_HANDLER)\ndispatcher.add_handler(GITPULL_HANDLER)\ndispatcher.add_handler(RESTART_HANDLER)\n\n__mod_name__ = \"Devs\"\n__handlers__ = [LEAVE_HANDLER, GITPULL_HANDLER, RESTART_HANDLER, ALLOWGROUPS_HANDLER]\n","size_bytes":2830},"sitaBot/modules/wiki.py":{"content":"import wikipedia\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\nfrom wikipedia.exceptions import DisambiguationError, PageError\n\n\n@run_async\ndef wiki(update: Update, context: CallbackContext):\n    msg = (\n        update.effective_message.reply_to_message\n        if update.effective_message.reply_to_message\n        else update.effective_message\n    )\n    res = \"\"\n    if msg == update.effective_message:\n        search = msg.text.split(\" \", maxsplit=1)[1]\n    else:\n        search = msg.text\n    try:\n        res = wikipedia.summary(search)\n    except DisambiguationError as e:\n        update.message.reply_text(\n            \"Disambiguated pages found! Adjust your query accordingly.\\n<i>{}</i>\".format(\n                e\n            ),\n            parse_mode=ParseMode.HTML,\n        )\n    except PageError as e:\n        update.message.reply_text(\n            \"<code>{}</code>\".format(e), parse_mode=ParseMode.HTML\n        )\n    if res:\n        result = f\"<b>{search}</b>\\n\\n\"\n        result += f\"<i>{res}</i>\\n\"\n        result += f\"\"\"<a href=\"https://en.wikipedia.org/wiki/{search.replace(\" \", \"%20\")}\">Read more...</a>\"\"\"\n        if len(result) > 4000:\n            with open(\"result.txt\", \"w\") as f:\n                f.write(f\"{result}\\n\\nUwU OwO OmO UmU\")\n            with open(\"result.txt\", \"rb\") as f:\n                context.bot.send_document(\n                    document=f,\n                    filename=f.name,\n                    reply_to_message_id=update.message.message_id,\n                    chat_id=update.effective_chat.id,\n                    parse_mode=ParseMode.HTML,\n                )\n        else:\n            update.message.reply_text(\n                result, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n            )\n\n\nWIKI_HANDLER = DisableAbleCommandHandler(\"wiki\", wiki)\ndispatcher.add_handler(WIKI_HANDLER)\n","size_bytes":1984},"sitaBot/modules/disasters.py":{"content":"import html\nimport json\nimport os\nfrom typing import Optional\n\nfrom sitaBot import (\n    DEV_USERS,\n    OWNER_ID,\n    DRAGONS,\n    SUPPORT_CHAT,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    dispatcher,\n)\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    dev_plus,\n    sudo_plus,\n    whitelist_plus,\n)\nfrom sitaBot.modules.helper_funcs.extraction import extract_user\nfrom sitaBot.modules.log_channel import gloggable\nfrom telegram import ParseMode, TelegramError, Update\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\nfrom telegram.utils.helpers import mention_html\n\nELEVATED_USERS_FILE = os.path.join(os.getcwd(), \"sitaBot/elevated_users.json\")\n\n\ndef check_user_id(user_id: int, context: CallbackContext) -> Optional[str]:\n    bot = context.bot\n    if not user_id:\n        reply = \"That...is a chat! baka ka omae?\"\n\n    elif user_id == bot.id:\n        reply = \"This does not work that way.\"\n\n    else:\n        reply = None\n    return reply\n\n\n# This can serve as a deeplink example.\n# disasters =\n# \"\"\" Text here \"\"\"\n\n# do not async, not a handler\n# def send_disasters(update):\n#    update.effective_message.reply_text(\n#        disasters, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)\n\n### Deep link example ends\n\n\n@run_async\n@dev_plus\n@gloggable\ndef addsudo(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n    rt = \"\"\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DRAGONS:\n        message.reply_text(\"This member is already a Dragon Disaster\")\n        return \"\"\n\n    if user_id in DEMONS:\n        rt += \"Requested HA to promote a Demon Disaster to Dragon.\"\n        data[\"supports\"].remove(user_id)\n        DEMONS.remove(user_id)\n\n    if user_id in WOLVES:\n        rt += \"Requested HA to promote a Wolf Disaster to Dragon.\"\n        data[\"whitelists\"].remove(user_id)\n        WOLVES.remove(user_id)\n\n    data[\"sudos\"].append(user_id)\n    DRAGONS.append(user_id)\n\n    with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n        json.dump(data, outfile, indent=4)\n\n    update.effective_message.reply_text(\n        rt\n        + \"\\nSuccessfully set Disaster level of {} to Dragon!\".format(\n            user_member.first_name\n        )\n    )\n\n    log_message = (\n        f\"#SUDO\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n    )\n\n    if chat.type != \"private\":\n        log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n    return log_message\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef addsupport(\n    update: Update,\n    context: CallbackContext,\n) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n    rt = \"\"\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DRAGONS:\n        rt += \"Requested HA to demote this Dragon to Demon\"\n        data[\"sudos\"].remove(user_id)\n        DRAGONS.remove(user_id)\n\n    if user_id in DEMONS:\n        message.reply_text(\"This user is already a Demon Disaster.\")\n        return \"\"\n\n    if user_id in WOLVES:\n        rt += \"Requested HA to promote this Wolf Disaster to Demon\"\n        data[\"whitelists\"].remove(user_id)\n        WOLVES.remove(user_id)\n\n    data[\"supports\"].append(user_id)\n    DEMONS.append(user_id)\n\n    with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n        json.dump(data, outfile, indent=4)\n\n    update.effective_message.reply_text(\n        rt + f\"\\n{user_member.first_name} was added as a Demon Disaster!\"\n    )\n\n    log_message = (\n        f\"#SUPPORT\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n    )\n\n    if chat.type != \"private\":\n        log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n    return log_message\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef addwhitelist(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n    rt = \"\"\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DRAGONS:\n        rt += \"This member is a Dragon Disaster, Demoting to Wolf.\"\n        data[\"sudos\"].remove(user_id)\n        DRAGONS.remove(user_id)\n\n    if user_id in DEMONS:\n        rt += \"This user is already a Demon Disaster, Demoting to Wolf.\"\n        data[\"supports\"].remove(user_id)\n        DEMONS.remove(user_id)\n\n    if user_id in WOLVES:\n        message.reply_text(\"This user is already a Wolf Disaster.\")\n        return \"\"\n\n    data[\"whitelists\"].append(user_id)\n    WOLVES.append(user_id)\n\n    with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n        json.dump(data, outfile, indent=4)\n\n    update.effective_message.reply_text(\n        rt + f\"\\nSuccessfully promoted {user_member.first_name} to a Wolf Disaster!\"\n    )\n\n    log_message = (\n        f\"#WHITELIST\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))} \\n\"\n        f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n    )\n\n    if chat.type != \"private\":\n        log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n    return log_message\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef addtiger(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n    rt = \"\"\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DRAGONS:\n        rt += \"This member is a Dragon Disaster, Demoting to Tiger.\"\n        data[\"sudos\"].remove(user_id)\n        DRAGONS.remove(user_id)\n\n    if user_id in DEMONS:\n        rt += \"This user is already a Demon Disaster, Demoting to Tiger.\"\n        data[\"supports\"].remove(user_id)\n        DEMONS.remove(user_id)\n\n    if user_id in WOLVES:\n        rt += \"This user is already a Wolf Disaster, Demoting to Tiger.\"\n        data[\"whitelists\"].remove(user_id)\n        WOLVES.remove(user_id)\n\n    if user_id in TIGERS:\n        message.reply_text(\"This user is already a Tiger.\")\n        return \"\"\n\n    data[\"tigers\"].append(user_id)\n    TIGERS.append(user_id)\n\n    with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n        json.dump(data, outfile, indent=4)\n\n    update.effective_message.reply_text(\n        rt + f\"\\nSuccessfully promoted {user_member.first_name} to a Tiger Disaster!\"\n    )\n\n    log_message = (\n        f\"#TIGER\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))} \\n\"\n        f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n    )\n\n    if chat.type != \"private\":\n        log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n    return log_message\n\n\n@run_async\n@dev_plus\n@gloggable\ndef removesudo(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DRAGONS:\n        message.reply_text(\"Requested HA to demote this user to Civilian\")\n        DRAGONS.remove(user_id)\n        data[\"sudos\"].remove(user_id)\n\n        with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n            json.dump(data, outfile, indent=4)\n\n        log_message = (\n            f\"#UNSUDO\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n        )\n\n        if chat.type != \"private\":\n            log_message = \"<b>{}:</b>\\n\".format(html.escape(chat.title)) + log_message\n\n        return log_message\n\n    else:\n        message.reply_text(\"This user is not a Dragon Disaster!\")\n        return \"\"\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef removesupport(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in DEMONS:\n        message.reply_text(\"Requested HA to demote this user to Civilian\")\n        DEMONS.remove(user_id)\n        data[\"supports\"].remove(user_id)\n\n        with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n            json.dump(data, outfile, indent=4)\n\n        log_message = (\n            f\"#UNSUPPORT\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n        )\n\n        if chat.type != \"private\":\n            log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n        return log_message\n\n    else:\n        message.reply_text(\"This user is not a Demon level Disaster!\")\n        return \"\"\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef removewhitelist(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in WOLVES:\n        message.reply_text(\"Demoting to normal user\")\n        WOLVES.remove(user_id)\n        data[\"whitelists\"].remove(user_id)\n\n        with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n            json.dump(data, outfile, indent=4)\n\n        log_message = (\n            f\"#UNWHITELIST\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n        )\n\n        if chat.type != \"private\":\n            log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n        return log_message\n    else:\n        message.reply_text(\"This user is not a Wolf Disaster!\")\n        return \"\"\n\n\n@run_async\n@sudo_plus\n@gloggable\ndef removetiger(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    bot, args = context.bot, context.args\n    user_id = extract_user(message, args)\n    user_member = bot.getChat(user_id)\n\n    reply = check_user_id(user_id, bot)\n    if reply:\n        message.reply_text(reply)\n        return \"\"\n\n    with open(ELEVATED_USERS_FILE, \"r\") as infile:\n        data = json.load(infile)\n\n    if user_id in TIGERS:\n        message.reply_text(\"Demoting to normal user\")\n        TIGERS.remove(user_id)\n        data[\"tigers\"].remove(user_id)\n\n        with open(ELEVATED_USERS_FILE, \"w\") as outfile:\n            json.dump(data, outfile, indent=4)\n\n        log_message = (\n            f\"#UNTIGER\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(user_member.id, html.escape(user_member.first_name))}\"\n        )\n\n        if chat.type != \"private\":\n            log_message = f\"<b>{html.escape(chat.title)}:</b>\\n\" + log_message\n\n        return log_message\n    else:\n        message.reply_text(\"This user is not a Tiger Disaster!\")\n        return \"\"\n\n\n@run_async\n@whitelist_plus\ndef whitelistlist(update: Update, context: CallbackContext):\n    reply = \"<b>Known Wolf Disasters üê∫:</b>\\n\"\n    m = update.effective_message.reply_text(\n        \"<code>Gathering intel..</code>\", parse_mode=ParseMode.HTML\n    )\n    bot = context.bot\n    for each_user in WOLVES:\n        user_id = int(each_user)\n        try:\n            user = bot.get_chat(user_id)\n\n            reply += f\"‚Ä¢ {mention_html(user_id, html.escape(user.first_name))}\\n\"\n        except TelegramError:\n            pass\n    m.edit_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@whitelist_plus\ndef tigerlist(update: Update, context: CallbackContext):\n    reply = \"<b>Known Tiger Disasters üêØ:</b>\\n\"\n    m = update.effective_message.reply_text(\n        \"<code>Gathering intel..</code>\", parse_mode=ParseMode.HTML\n    )\n    bot = context.bot\n    for each_user in TIGERS:\n        user_id = int(each_user)\n        try:\n            user = bot.get_chat(user_id)\n            reply += f\"‚Ä¢ {mention_html(user_id, html.escape(user.first_name))}\\n\"\n        except TelegramError:\n            pass\n    m.edit_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@whitelist_plus\ndef supportlist(update: Update, context: CallbackContext):\n    bot = context.bot\n    m = update.effective_message.reply_text(\n        \"<code>Gathering intel..</code>\", parse_mode=ParseMode.HTML\n    )\n    reply = \"<b>Known Demon Disasters üëπ:</b>\\n\"\n    for each_user in DEMONS:\n        user_id = int(each_user)\n        try:\n            user = bot.get_chat(user_id)\n            reply += f\"‚Ä¢ {mention_html(user_id, html.escape(user.first_name))}\\n\"\n        except TelegramError:\n            pass\n    m.edit_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@whitelist_plus\ndef sudolist(update: Update, context: CallbackContext):\n    bot = context.bot\n    m = update.effective_message.reply_text(\n        \"<code>Gathering intel..</code>\", parse_mode=ParseMode.HTML\n    )\n    true_sudo = list(set(DRAGONS) - set(DEV_USERS))\n    reply = \"<b>Known Dragon Disasters üêâ:</b>\\n\"\n    for each_user in true_sudo:\n        user_id = int(each_user)\n        try:\n            user = bot.get_chat(user_id)\n            reply += f\"‚Ä¢ {mention_html(user_id, html.escape(user.first_name))}\\n\"\n        except TelegramError:\n            pass\n    m.edit_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@whitelist_plus\ndef devlist(update: Update, context: CallbackContext):\n    bot = context.bot\n    m = update.effective_message.reply_text(\n        \"<code>Gathering intel..</code>\", parse_mode=ParseMode.HTML\n    )\n    true_dev = list(set(DEV_USERS) - {OWNER_ID})\n    reply = \"<b>Hero Association Members ‚ö°Ô∏è:</b>\\n\"\n    for each_user in true_dev:\n        user_id = int(each_user)\n        try:\n            user = bot.get_chat(user_id)\n            reply += f\"‚Ä¢ {mention_html(user_id, html.escape(user.first_name))}\\n\"\n        except TelegramError:\n            pass\n    m.edit_text(reply, parse_mode=ParseMode.HTML)\n\n\n# __help__ = f\"\"\"\n# *‚ö†Ô∏è Notice:*\n# Commands listed here only work for users with special access are mainly used for troubleshooting, debugging purposes.\n# Group admins/group owners do not need these commands. \n\n# *List all special users:*\n#  ‚ùç /dragons*:* Lists all Dragon disasters\n#  ‚ùç /demons*:* Lists all Demon disasters\n#  ‚ùç /tigers*:* Lists all Tigers disasters\n#  ‚ùç /wolves*:* Lists all Wolf disasters\n#  ‚ùç /heroes*:* Lists all Hero Association members\n#  ‚ùç /adddragon*:* Adds a user to Dragon\n#  ‚ùç /adddemon*:* Adds a user to Demon\n#  ‚ùç /addtiger*:* Adds a user to Tiger\n#  ‚ùç /addwolf*:* Adds a user to Wolf\n#  ‚ùç `Add dev doesnt exist, devs should know how to add themselves`\n\n# *Ping:*\n#  ‚ùç /ping*:* gets ping time of bot to telegram server\n#  ‚ùç /pingall*:* gets all listed ping times\n\n# *Broadcast: (Bot owner only)*\n# *Note:* This supports basic markdown\n#  ‚ùç /broadcastall*:* Broadcasts everywhere\n#  ‚ùç /broadcastusers*:* Broadcasts too all users\n#  ‚ùç /broadcastgroups*:* Broadcasts too all groups\n\n# *Groups Info:*\n#  ‚ùç /groups*:* List the groups with Name, ID, members count as a txt\n#  ‚ùç /leave <ID>*:* Leave the group, ID must have hyphen\n#  ‚ùç /stats*:* Shows overall bot stats\n#  ‚ùç /getchats*:* Gets a list of group names the user has been seen in. Bot owner only\n#  ‚ùç /ginfo username/link/ID*:* Pulls info panel for entire group\n\n# *Access control:* \n#  ‚ùç /ignore*:* Blacklists a user from using the bot entirely\n#  ‚ùç /lockdown <off/on>*:* Toggles bot adding to groups\n#  ‚ùç /notice*:* Removes user from blacklist\n#  ‚ùç /ignoredlist*:* Lists ignored users\n\n# *Speedtest:*\n#  ‚ùç /speedtest*:* Runs a speedtest and gives you 2 options to choose from, text or image output\n\n# *Module loading:*\n#  ‚ùç /listmodules*:* Lists names of all modules\n#  ‚ùç /load modulename*:* Loads the said module to memory without restarting.\n#  ‚ùç /unload modulename*:* Loads the said module frommemory without restarting memory without restarting the bot \n\n# *Remote commands:*\n#  ‚ùç /rban*:* user group*:* Remote ban\n#  ‚ùç /runban*:* user group*:* Remote un-ban\n#  ‚ùç /rpunch*:* user group*:* Remote punch\n#  ‚ùç /rmute*:* user group*:* Remote mute\n#  ‚ùç /runmute*:* user group*:* Remote un-mute\n\n# *Windows self hosted only:*\n#  ‚ùç /reboot*:* Restarts the bots service\n#  ‚ùç /gitpull*:* Pulls the repo and then restarts the bots service\n\n# *Chatbot:* \n#  ‚ùç /listaichats*:* Lists the chats the chatmode is enabled in\n \n# *Debugging and Shell:* \n#  ‚ùç /debug <on/off>*:* Logs commands to updates.txt\n#  ‚ùç /logs*:* Run this in support group to get logs in pm\n#  ‚ùç /eval*:* Self explanatory\n#  ‚ùç /sh*:* Runs shell command\n#  ‚ùç /shell*:* Runs shell command\n#  ‚ùç /clearlocals*:* As the name goes\n#  ‚ùç /dbcleanup*:* Removes deleted accs and groups from db\n#  ‚ùç /py*:* Runs python code\n \n# *Global Bans:*\n#  ‚ùç /gban <id> <reason>*:* Gbans the user, works by reply too\n#  ‚ùç /ungban*:* Ungbans the user, same usage as gban\n#  ‚ùç /gbanlist*:* Outputs a list of gbanned users\n\n# *Global Blue Text*\n#  ‚ùç /gignoreblue*:* <word>*:* Globally ignorea bluetext cleaning of saved word across sitaBot.\n#  ‚ùç /ungignoreblue*:* <word>*:* Remove said command from global cleaning list\n\n# *Sita Core*\n# *Owner only*\n#  ‚ùç /send*:* <module name>*:* Send module\n#  ‚ùç /install*:* <reply to a .py>*:* Install module \n\n# *Heroku Settings*\n# *Owner only*\n#  ‚ùç /usage*:* Check your heroku dyno hours remaining.\n#  ‚ùç /see var <var>*:* Get your existing varibles, use it only on your private group!\n#  ‚ùç /set var <newvar> <vavariable>*:* Add new variable or update existing value variable.\n#  ‚ùç /del var <var>*:* Delete existing variable.\n#  ‚ùç /logs Get heroku dyno logs.\n\n# `‚ö†Ô∏è Read from top`\n# Visit @{SUPPORT_CHAT} for more information.\n# \"\"\"\n\nSUDO_HANDLER = CommandHandler((\"addsudo\", \"adddragon\"), addsudo)\nSUPPORT_HANDLER = CommandHandler((\"addsupport\", \"adddemon\"), addsupport)\nTIGER_HANDLER = CommandHandler((\"addtiger\"), addtiger)\nWHITELIST_HANDLER = CommandHandler((\"addwhitelist\", \"addwolf\"), addwhitelist)\nUNSUDO_HANDLER = CommandHandler((\"removesudo\", \"removedragon\"), removesudo)\nUNSUPPORT_HANDLER = CommandHandler((\"removesupport\", \"removedemon\"), removesupport)\nUNTIGER_HANDLER = CommandHandler((\"removetiger\"), removetiger)\nUNWHITELIST_HANDLER = CommandHandler((\"removewhitelist\", \"removewolf\"), removewhitelist)\n\nWHITELISTLIST_HANDLER = CommandHandler([\"whitelistlist\", \"wolves\"], whitelistlist)\nTIGERLIST_HANDLER = CommandHandler([\"tigers\"], tigerlist)\nSUPPORTLIST_HANDLER = CommandHandler([\"supportlist\", \"demons\"], supportlist)\nSUDOLIST_HANDLER = CommandHandler([\"sudolist\", \"dragons\"], sudolist)\nDEVLIST_HANDLER = CommandHandler([\"devlist\", \"heroes\"], devlist)\n\ndispatcher.add_handler(SUDO_HANDLER)\ndispatcher.add_handler(SUPPORT_HANDLER)\ndispatcher.add_handler(TIGER_HANDLER)\ndispatcher.add_handler(WHITELIST_HANDLER)\ndispatcher.add_handler(UNSUDO_HANDLER)\ndispatcher.add_handler(UNSUPPORT_HANDLER)\ndispatcher.add_handler(UNTIGER_HANDLER)\ndispatcher.add_handler(UNWHITELIST_HANDLER)\n\ndispatcher.add_handler(WHITELISTLIST_HANDLER)\ndispatcher.add_handler(TIGERLIST_HANDLER)\ndispatcher.add_handler(SUPPORTLIST_HANDLER)\ndispatcher.add_handler(SUDOLIST_HANDLER)\ndispatcher.add_handler(DEVLIST_HANDLER)\n\n__mod_name__ = \"Dev\"\n__handlers__ = [\n    SUDO_HANDLER,\n    SUPPORT_HANDLER,\n    TIGER_HANDLER,\n    WHITELIST_HANDLER,\n    UNSUDO_HANDLER,\n    UNSUPPORT_HANDLER,\n    UNTIGER_HANDLER,\n    UNWHITELIST_HANDLER,\n    WHITELISTLIST_HANDLER,\n    TIGERLIST_HANDLER,\n    SUPPORTLIST_HANDLER,\n    SUDOLIST_HANDLER,\n    DEVLIST_HANDLER,\n]\n","size_bytes":21666},"sitaBot/modules/backups.py":{"content":"import json, time, os\nfrom io import BytesIO\n\nfrom telegram import ParseMode, Message\nfrom telegram.error import BadRequest\nfrom telegram.ext import CommandHandler, run_async\n\nimport sitaBot.modules.sql.notes_sql as sql\nfrom sitaBot import dispatcher, LOGGER, OWNER_ID, JOIN_LOGGER, SUPPORT_CHAT\nfrom sitaBot.__main__ import DATA_IMPORT\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.helper_funcs.alternate import typing_action\n\n# from sitaBot.modules.rules import get_rules\nimport sitaBot.modules.sql.rules_sql as rulessql\n\n# from sitaBot.modules.sql import warns_sql as warnssql\nimport sitaBot.modules.sql.blacklist_sql as blacklistsql\nfrom sitaBot.modules.sql import disable_sql as disabledsql\n\n# from sitaBot.modules.sql import cust_filters_sql as filtersql\n# import sitaBot.modules.sql.welcome_sql as welcsql\nimport sitaBot.modules.sql.locks_sql as locksql\nfrom sitaBot.modules.connection import connected\n\n\n@run_async\n@user_admin\n@typing_action\ndef import_data(update, context):\n    msg = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n    # TODO: allow uploading doc with command, not just as reply\n    # only work with a doc\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            update.effective_message.reply_text(\"This is a group only command!\")\n            return \"\"\n\n        chat = update.effective_chat\n        chat_name = update.effective_message.chat.title\n\n    if msg.reply_to_message and msg.reply_to_message.document:\n        try:\n            file_info = context.bot.get_file(msg.reply_to_message.document.file_id)\n        except BadRequest:\n            msg.reply_text(\n                \"Try downloading and uploading the file yourself again, This one seem broken to me!\"\n            )\n            return\n\n        with BytesIO() as file:\n            file_info.download(out=file)\n            file.seek(0)\n            data = json.load(file)\n\n        # only import one group\n        if len(data) > 1 and str(chat.id) not in data:\n            msg.reply_text(\n                \"There are more than one group in this file and the chat.id is not same! How am i supposed to import it?\"\n            )\n            return\n\n        # Check if backup is this chat\n        try:\n            if data.get(str(chat.id)) is None:\n                if conn:\n                    text = \"Backup comes from another chat, I can't return another chat to chat *{}*\".format(\n                        chat_name\n                    )\n                else:\n                    text = \"Backup comes from another chat, I can't return another chat to this chat\"\n                return msg.reply_text(text, parse_mode=\"markdown\")\n        except Exception:\n            return msg.reply_text(\"There was a problem while importing the data!\")\n        # Check if backup is from self\n        try:\n            if str(context.bot.id) != str(data[str(chat.id)][\"bot\"]):\n                return msg.reply_text(\n                    \"Backup from another bot that is not suggested might cause the problem, documents, photos, videos, audios, records might not work as it should be.\"\n                )\n        except Exception:\n            pass\n        # Select data source\n        if str(chat.id) in data:\n            data = data[str(chat.id)][\"hashes\"]\n        else:\n            data = data[list(data.keys())[0]][\"hashes\"]\n\n        try:\n            for mod in DATA_IMPORT:\n                mod.__import_data__(str(chat.id), data)\n        except Exception:\n            msg.reply_text(\n                f\"An error occurred while recovering your data. The process failed. If you experience a problem with this, please take it to @{SUPPORT_CHAT}\"\n            )\n\n            LOGGER.exception(\n                \"Imprt for the chat %s with the name %s failed.\",\n                str(chat.id),\n                str(chat.title),\n            )\n            return\n\n        # TODO: some of that link logic\n        # NOTE: consider default permissions stuff?\n        if conn:\n\n            text = \"Backup fully restored on *{}*.\".format(chat_name)\n        else:\n            text = \"Backup fully restored\"\n        msg.reply_text(text, parse_mode=\"markdown\")\n\n\n@run_async\n@user_admin\ndef export_data(update, context):\n    chat_data = context.chat_data\n    msg = update.effective_message  # type: Optional[Message]\n    user = update.effective_user  # type: Optional[User]\n    chat_id = update.effective_chat.id\n    chat = update.effective_chat\n    current_chat_id = update.effective_chat.id\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_id = conn\n        # chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            update.effective_message.reply_text(\"This is a group only command!\")\n            return \"\"\n        chat = update.effective_chat\n        chat_id = update.effective_chat.id\n        # chat_name = update.effective_message.chat.title\n\n    jam = time.time()\n    new_jam = jam + 10800\n    checkchat = get_chat(chat_id, chat_data)\n    if checkchat.get(\"status\"):\n        if jam <= int(checkchat.get(\"value\")):\n            timeformatt = time.strftime(\n                \"%H:%M:%S %d/%m/%Y\", time.localtime(checkchat.get(\"value\"))\n            )\n            update.effective_message.reply_text(\n                \"You can only backup once a day!\\nYou can backup again in about `{}`\".format(\n                    timeformatt\n                ),\n                parse_mode=ParseMode.MARKDOWN,\n            )\n            return\n        else:\n            if user.id != OWNER_ID:\n                put_chat(chat_id, new_jam, chat_data)\n    else:\n        if user.id != OWNER_ID:\n            put_chat(chat_id, new_jam, chat_data)\n\n    note_list = sql.get_all_chat_notes(chat_id)\n    backup = {}\n    # button = \"\"\n    buttonlist = []\n    namacat = \"\"\n    isicat = \"\"\n    rules = \"\"\n    count = 0\n    countbtn = 0\n    # Notes\n    for note in note_list:\n        count += 1\n        # getnote = sql.get_note(chat_id, note.name)\n        namacat += \"{}<###splitter###>\".format(note.name)\n        if note.msgtype == 1:\n            tombol = sql.get_buttons(chat_id, note.name)\n            # keyb = []\n            for btn in tombol:\n                countbtn += 1\n                if btn.same_line:\n                    buttonlist.append(\n                        (\"{}\".format(btn.name), \"{}\".format(btn.url), True)\n                    )\n                else:\n                    buttonlist.append(\n                        (\"{}\".format(btn.name), \"{}\".format(btn.url), False)\n                    )\n            isicat += \"###button###: {}<###button###>{}<###splitter###>\".format(\n                note.value, str(buttonlist)\n            )\n            buttonlist.clear()\n        elif note.msgtype == 2:\n            isicat += \"###sticker###:{}<###splitter###>\".format(note.file)\n        elif note.msgtype == 3:\n            isicat += \"###file###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        elif note.msgtype == 4:\n            isicat += \"###photo###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        elif note.msgtype == 5:\n            isicat += \"###audio###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        elif note.msgtype == 6:\n            isicat += \"###voice###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        elif note.msgtype == 7:\n            isicat += \"###video###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        elif note.msgtype == 8:\n            isicat += \"###video_note###:{}<###TYPESPLIT###>{}<###splitter###>\".format(\n                note.file, note.value\n            )\n        else:\n            isicat += \"{}<###splitter###>\".format(note.value)\n    notes = {\n        \"#{}\".format(namacat.split(\"<###splitter###>\")[x]): \"{}\".format(\n            isicat.split(\"<###splitter###>\")[x]\n        )\n        for x in range(count)\n    }\n    # Rules\n    rules = rulessql.get_rules(chat_id)\n    # Blacklist\n    bl = list(blacklistsql.get_chat_blacklist(chat_id))\n    # Disabled command\n    disabledcmd = list(disabledsql.get_all_disabled(chat_id))\n    # Filters (TODO)\n    \"\"\"\n\tall_filters = list(filtersql.get_chat_triggers(chat_id))\n\texport_filters = {}\n\tfor filters in all_filters:\n\t\tfilt = filtersql.get_filter(chat_id, filters)\n\t\t# print(vars(filt))\n\t\tif filt.is_sticker:\n\t\t\ttipefilt = \"sticker\"\n\t\telif filt.is_document:\n\t\t\ttipefilt = \"doc\"\n\t\telif filt.is_image:\n\t\t\ttipefilt = \"img\"\n\t\telif filt.is_audio:\n\t\t\ttipefilt = \"audio\"\n\t\telif filt.is_voice:\n\t\t\ttipefilt = \"voice\"\n\t\telif filt.is_video:\n\t\t\ttipefilt = \"video\"\n\t\telif filt.has_buttons:\n\t\t\ttipefilt = \"button\"\n\t\t\tbuttons = filtersql.get_buttons(chat.id, filt.keyword)\n\t\t\tprint(vars(buttons))\n\t\telif filt.has_markdown:\n\t\t\ttipefilt = \"text\"\n\t\tif tipefilt == \"button\":\n\t\t\tcontent = \"{}#=#{}|btn|{}\".format(tipefilt, filt.reply, buttons)\n\t\telse:\n\t\t\tcontent = \"{}#=#{}\".format(tipefilt, filt.reply)\n\t\tprint(content)\n\t\texport_filters[filters] = content\n\tprint(export_filters)\n\t\"\"\"\n    # Welcome (TODO)\n    # welc = welcsql.get_welc_pref(chat_id)\n    # Locked\n    curr_locks = locksql.get_locks(chat_id)\n    curr_restr = locksql.get_restr(chat_id)\n\n    if curr_locks:\n        locked_lock = {\n            \"sticker\": curr_locks.sticker,\n            \"audio\": curr_locks.audio,\n            \"voice\": curr_locks.voice,\n            \"document\": curr_locks.document,\n            \"video\": curr_locks.video,\n            \"contact\": curr_locks.contact,\n            \"photo\": curr_locks.photo,\n            \"gif\": curr_locks.gif,\n            \"url\": curr_locks.url,\n            \"bots\": curr_locks.bots,\n            \"forward\": curr_locks.forward,\n            \"game\": curr_locks.game,\n            \"location\": curr_locks.location,\n            \"rtl\": curr_locks.rtl,\n        }\n    else:\n        locked_lock = {}\n\n    if curr_restr:\n        locked_restr = {\n            \"messages\": curr_restr.messages,\n            \"media\": curr_restr.media,\n            \"other\": curr_restr.other,\n            \"previews\": curr_restr.preview,\n            \"all\": all(\n                [\n                    curr_restr.messages,\n                    curr_restr.media,\n                    curr_restr.other,\n                    curr_restr.preview,\n                ]\n            ),\n        }\n    else:\n        locked_restr = {}\n\n    locks = {\"locks\": locked_lock, \"restrict\": locked_restr}\n    # Warns (TODO)\n    # warns = warnssql.get_warns(chat_id)\n    # Backing up\n    backup[chat_id] = {\n        \"bot\": context.bot.id,\n        \"hashes\": {\n            \"info\": {\"rules\": rules},\n            \"extra\": notes,\n            \"blacklist\": bl,\n            \"disabled\": disabledcmd,\n            \"locks\": locks,\n        },\n    }\n    baccinfo = json.dumps(backup, indent=4)\n    with open(\"sitaBot{}.backup\".format(chat_id), \"w\") as f:\n        f.write(str(baccinfo))\n    context.bot.sendChatAction(current_chat_id, \"upload_document\")\n    tgl = time.strftime(\"%H:%M:%S - %d/%m/%Y\", time.localtime(time.time()))\n    try:\n        context.bot.sendMessage(\n            JOIN_LOGGER,\n            \"*Successfully imported backup:*\\nChat: `{}`\\nChat ID: `{}`\\nOn: `{}`\".format(\n                chat.title, chat_id, tgl\n            ),\n            parse_mode=ParseMode.MARKDOWN,\n        )\n    except BadRequest:\n        pass\n    context.bot.sendDocument(\n        current_chat_id,\n        document=open(\"sitaBot{}.backup\".format(chat_id), \"rb\"),\n        caption=\"üíæ*Successfully Exported backup:*\\nChat: `{}`\\nChat ID: `{}`\\nOn: `{}`\\n\\nNote: This `sitaBot-Backup` was specially made for notes üìö.\".format(\n            chat.title, chat_id, tgl\n        ),\n        timeout=360,\n        reply_to_message_id=msg.message_id,\n        parse_mode=ParseMode.MARKDOWN,\n    )\n    os.remove(\"sitaBot{}.backup\".format(chat_id))  # Cleaning file\n\n\n# Temporary data\ndef put_chat(chat_id, value, chat_data):\n    # print(chat_data)\n    status = value is not False\n    chat_data[chat_id] = {\"backups\": {\"status\": status, \"value\": value}}\n\n\ndef get_chat(chat_id, chat_data):\n    # print(chat_data)\n    try:\n        return chat_data[chat_id][\"backups\"]\n    except KeyError:\n        return {\"status\": False, \"value\": False}\n\n\n__mod_name__ = \"Backup\"\n\n__help__ = \"\"\"\n*Only for group owner:*\n\n ‚ùç /import: Reply to the backup file for the butler / emilia group to import as much as possible, making transfers very easy! \\\n Note that files / photos cannot be imported due to telegram restrictions.\n\n ‚ùç /export: Export group data, which will be exported are: rules, notes (documents, images, music, video, audio, voice, text, text buttons) \\\n\n\"\"\"\n\nIMPORT_HANDLER = CommandHandler(\"import\", import_data)\nEXPORT_HANDLER = CommandHandler(\"export\", export_data, pass_chat_data=True)\n\ndispatcher.add_handler(IMPORT_HANDLER)\ndispatcher.add_handler(EXPORT_HANDLER)\n","size_bytes":13296},"sitaBot/pyrogramee/telethonbasics.py":{"content":"import os\n\nfrom telethon.tl.types import *\n\nfrom sitaBot.pyrogramee.pluginshelper import runcmd\n\n\nasync def convert_to_image(event, borg):\n    lmao = await event.get_reply_message()\n    if not (\n        lmao.gif\n        or lmao.audio\n        or lmao.voice\n        or lmao.video\n        or lmao.video_note\n        or lmao.photo\n        or lmao.sticker\n        or lmao.media\n    ):\n        await borg.send_message(event.chat_id, \"`Format Not Supported.`\")\n        return\n    else:\n        try:\n            time.time()\n            downloaded_file_name = await borg.download_media(\n                lmao.media, sedpath, \"`Downloading...`\"\n            )\n\n        except Exception as e:  # pylint:disable=C0103,W0703\n            await borg.send_message(event.chat_id, str(e))\n        else:\n            lel = await borg.send_message(\n                event.chat_id,\n                \"Downloaded to `{}` successfully.\".format(downloaded_file_name),\n            )\n            await lel.delete\n    if not os.path.exists(downloaded_file_name):\n        lel = await borg.send_message(event.chat_id, \"Download Unsucessfull :(\")\n        await lel.delete\n        return\n    if lmao and lmao.photo:\n        lmao_final = downloaded_file_name\n    elif lmao.sticker and lmao.sticker.mime_type == \"application/x-tgsticker\":\n        rpath = downloaded_file_name\n        image_name20 = os.path.join(sedpath, \"SED.png\")\n        cmd = f\"lottie_convert.py --frame 0 -if lottie -of png {downloaded_file_name} {image_name20}\"\n        stdout, stderr = (await runcmd(cmd))[:2]\n        os.remove(rpath)\n        lmao_final = image_name20\n    elif lmao.sticker and lmao.sticker.mime_type == \"image/webp\":\n        pathofsticker2 = downloaded_file_name\n        image_new_path = sedpath + \"image.png\"\n        im = Image.open(pathofsticker2)\n        im.save(image_new_path, \"PNG\")\n        if not os.path.exists(image_new_path):\n            await event.reply(\"`Wasn't Able To Fetch Shot.`\")\n            return\n        lmao_final = image_new_path\n    elif lmao.audio:\n        sed_p = downloaded_file_name\n        hmmyes = sedpath + \"stark.mp3\"\n        imgpath = sedpath + \"starky.jpg\"\n        os.rename(sed_p, hmmyes)\n        await runcmd(f\"ffmpeg -i {hmmyes} -filter:v scale=500:500 -an {imgpath}\")\n        os.remove(sed_p)\n        if not os.path.exists(imgpath):\n            await event.reply(\"`Wasn't Able To Fetch Shot.`\")\n            return\n        lmao_final = imgpath\n    elif lmao.gif or lmao.video or lmao.video_note:\n        sed_p2 = downloaded_file_name\n        jpg_file = os.path.join(sedpath, \"image.jpg\")\n        await take_screen_shot(sed_p2, 0, jpg_file)\n        os.remove(sed_p2)\n        if not os.path.exists(jpg_file):\n            await event.reply(\"`Couldn't Fetch. SS`\")\n            return\n        lmao_final = jpg_file\n    return lmao_final\n\n\nasync def take_screen_shot(\n    video_file: str, duration: int, path: str = \"\"\n) -> Optional[str]:\n    \"\"\" take a screenshot \"\"\"\n    logger.info(\n        \"[[[Extracting a frame from %s ||| Video duration => %s]]]\",\n        video_file,\n        duration,\n    )\n    ttl = duration // 2\n    thumb_image_path = path or os.path.join(sedpath, f\"{basename(video_file)}.jpg\")\n    command = f'''ffmpeg -ss {ttl} -i \"{video_file}\" -vframes 1 \"{thumb_image_path}\"'''\n    err = (await runcmd(command))[1]\n    if err:\n        logger.error(err)\n    return thumb_image_path if os.path.exists(thumb_image_path) else None\n\n\nasync def get_all_admin_chats(event):\n    lul_stark = []\n    all_chats = [\n        d.entity\n        for d in await event.client.get_dialogs()\n        if (d.is_group or d.is_channel)\n    ]\n    try:\n        for i in all_chats:\n            if i.creator or i.admin_rights:\n                lul_stark.append(i.id)\n    except:\n        pass\n    return lul_stark\n\n\nasync def is_admin(event, user):\n    try:\n        sed = await event.client.get_permissions(event.chat_id, user)\n        if sed.is_admin:\n            is_mod = True\n        else:\n            is_mod = False\n    except:\n        is_mod = False\n    return is_mod\n\n\nasync def progress(current, total, event, start, type_of_ps, file_name=None):\n    \"\"\"Generic progress_callback for both\n    upload.py and download.py\"\"\"\n    now = time.time()\n    diff = now - start\n    if round(diff % 10.00) == 0 or current == total:\n        percentage = current * 100 / total\n        speed = current / diff\n        elapsed_time = round(diff) * 1000\n        time_to_completion = round((total - current) / speed) * 1000\n        estimated_total_time = elapsed_time + time_to_completion\n        progress_str = \"[{0}{1}]\\nProgress: {2}%\\n\".format(\n            \"\".join([\"üü†\" for i in range(math.floor(percentage / 5))]),\n            \"\".join([\"üîò\" for i in range(20 - math.floor(percentage / 5))]),\n            round(percentage, 2),\n        )\n        tmp = progress_str + \"{0} of {1}\\nETA: {2}\".format(\n            humanbytes(current), humanbytes(total), time_formatter(estimated_total_time)\n        )\n        if file_name:\n            await event.edit(\n                \"{}\\nFile Name: `{}`\\n{}\".format(type_of_ps, file_name, tmp)\n            )\n        else:\n            await event.edit(\"{}\\n{}\".format(type_of_ps, tmp))\n\n\ndef humanbytes(size):\n    \"\"\"Input size in bytes,\n    outputs in a human readable format\"\"\"\n    # https://stackoverflow.com/a/49361727/4723940\n    if not size:\n        return \"\"\n    # 2 ** 10 = 1024\n    power = 2 ** 10\n    raised_to_pow = 0\n    dict_power_n = {0: \"\", 1: \"Ki\", 2: \"Mi\", 3: \"Gi\", 4: \"Ti\"}\n    while size > power:\n        size /= power\n        raised_to_pow += 1\n    return str(round(size, 2)) + \" \" + dict_power_n[raised_to_pow] + \"B\"\n\n\ndef time_formatter(milliseconds: int) -> str:\n    \"\"\"Inputs time in milliseconds, to get beautified time,\n    as string\"\"\"\n    seconds, milliseconds = divmod(int(milliseconds), 1000)\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    days, hours = divmod(hours, 24)\n    tmp = (\n        ((str(days) + \" day(s), \") if days else \"\")\n        + ((str(hours) + \" hour(s), \") if hours else \"\")\n        + ((str(minutes) + \" minute(s), \") if minutes else \"\")\n        + ((str(seconds) + \" second(s), \") if seconds else \"\")\n        + ((str(milliseconds) + \" millisecond(s), \") if milliseconds else \"\")\n    )\n    return tmp[:-2]\n","size_bytes":6289},"sitaBot/modules/debug.py":{"content":"import os\nimport datetime\n\nfrom telethon import events\nfrom telegram import Update\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\nfrom sitaBot import telethn, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\n\nDEBUG_MODE = False\n\n\n@run_async\n@dev_plus\ndef debug(update: Update, context: CallbackContext):\n    global DEBUG_MODE\n    args = update.effective_message.text.split(None, 1)\n    message = update.effective_message\n    print(DEBUG_MODE)\n    if len(args) > 1:\n        if args[1] in (\"yes\", \"on\"):\n            DEBUG_MODE = True\n            message.reply_text(\"Debug mode is now on.\")\n        elif args[1] in (\"no\", \"off\"):\n            DEBUG_MODE = False\n            message.reply_text(\"Debug mode is now off.\")\n    else:\n        if DEBUG_MODE:\n            message.reply_text(\"Debug mode is currently on.\")\n        else:\n            message.reply_text(\"Debug mode is currently off.\")\n\n\n@telethn.on(events.NewMessage(pattern=\"[/!].*\"))\nasync def i_do_nothing_yes(event):\n    global DEBUG_MODE\n    if DEBUG_MODE:\n        print(f\"-{event.from_id} ({event.chat_id}) : {event.text}\")\n        if os.path.exists(\"updates.txt\"):\n            with open(\"updates.txt\", \"r\") as f:\n                text = f.read()\n            with open(\"updates.txt\", \"w+\") as f:\n                f.write(text + f\"\\n-{event.from_id} ({event.chat_id}) : {event.text}\")\n        else:\n            with open(\"updates.txt\", \"w+\") as f:\n                f.write(\n                    f\"- {event.from_id} ({event.chat_id}) : {event.text} | {datetime.datetime.now()}\"\n                )\n\n\nsupport_chat = os.getenv(\"SUPPORT_CHAT\")\n\n\n@run_async\n@dev_plus\ndef logs(update: Update, context: CallbackContext):\n    user = update.effective_user\n    with open(\"log.txt\", \"rb\") as f:\n        context.bot.send_document(document=f, filename=f.name, chat_id=user.id)\n\n\nLOG_HANDLER = CommandHandler(\"logs\", logs)\ndispatcher.add_handler(LOG_HANDLER)\n\nDEBUG_HANDLER = CommandHandler(\"debug\", debug)\ndispatcher.add_handler(DEBUG_HANDLER)\n\n__mod_name__ = \"Debug\"\n__command_list__ = [\"debug\"]\n__handlers__ = [DEBUG_HANDLER]\n","size_bytes":2113},"sitaBot/modules/afk.py":{"content":"import random, html\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import (\n    DisableAbleCommandHandler,\n    DisableAbleMessageHandler,\n)\nfrom sitaBot.modules.sql import afk_sql as sql\nfrom sitaBot.modules.users import get_user_id\nfrom telegram import MessageEntity, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, Filters, MessageHandler, run_async\n\nAFK_GROUP = 7\nAFK_REPLY_GROUP = 8\n\n\n@run_async\ndef afk(update: Update, context: CallbackContext):\n    args = update.effective_message.text.split(None, 1)\n    user = update.effective_user\n\n    if not user:  # ignore channels\n        return\n\n    if user.id in [777000, 1087968824]:\n        return\n\n    notice = \"\"\n    if len(args) >= 2:\n        reason = args[1]\n        if len(reason) > 100:\n            reason = reason[:100]\n            notice = \"\\nYour afk reason was shortened to 100 characters.\"\n    else:\n        reason = \"\"\n\n    sql.set_afk(update.effective_user.id, reason)\n    fname = update.effective_user.first_name\n    try:\n        update.effective_message.reply_text(\"{} is now away!{}\".format(fname, notice))\n    except BadRequest:\n        pass\n\n\n@run_async\ndef no_longer_afk(update: Update, context: CallbackContext):\n    user = update.effective_user\n    message = update.effective_message\n\n    if not user:  # ignore channels\n        return\n\n    res = sql.rm_afk(user.id)\n    if res:\n        if message.new_chat_members:  # dont say msg\n            return\n        firstname = update.effective_user.first_name\n        try:\n            options = [\n                \"{} is here!\",\n                \"{} is back!\",\n                \"{} is now in the chat!\",\n                \"{} is awake!\",\n                \"{} is back online!\",\n                \"{} is finally here!\",\n                \"Welcome back! {}\",\n                \"Where is {}?\\nIn the chat!\",\n            ]\n            chosen_option = random.choice(options)\n            update.effective_message.reply_text(chosen_option.format(firstname))\n        except:\n            return\n\n\n@run_async\ndef reply_afk(update: Update, context: CallbackContext):\n    bot = context.bot\n    message = update.effective_message\n    userc = update.effective_user\n    userc_id = userc.id\n    if message.entities and message.parse_entities(\n        [MessageEntity.TEXT_MENTION, MessageEntity.MENTION]\n    ):\n        entities = message.parse_entities(\n            [MessageEntity.TEXT_MENTION, MessageEntity.MENTION]\n        )\n\n        chk_users = []\n        for ent in entities:\n            if ent.type == MessageEntity.TEXT_MENTION:\n                user_id = ent.user.id\n                fst_name = ent.user.first_name\n\n                if user_id in chk_users:\n                    return\n                chk_users.append(user_id)\n\n            if ent.type != MessageEntity.MENTION:\n                return\n\n            user_id = get_user_id(message.text[ent.offset : ent.offset + ent.length])\n            if not user_id:\n                # Should never happen, since for a user to become AFK they must have spoken. Maybe changed username?\n                return\n\n            if user_id in chk_users:\n                return\n            chk_users.append(user_id)\n\n            try:\n                chat = bot.get_chat(user_id)\n            except BadRequest:\n                print(\"Error: Could not fetch userid {} for AFK module\".format(user_id))\n                return\n            fst_name = chat.first_name\n\n            check_afk(update, context, user_id, fst_name, userc_id)\n\n    elif message.reply_to_message:\n        user_id = message.reply_to_message.from_user.id\n        fst_name = message.reply_to_message.from_user.first_name\n        check_afk(update, context, user_id, fst_name, userc_id)\n\n\ndef check_afk(update, context, user_id, fst_name, userc_id):\n    if sql.is_afk(user_id):\n        user = sql.check_afk_status(user_id)\n        if int(userc_id) == int(user_id):\n            return\n        if not user.reason:\n            res = \"{} is afk\".format(fst_name)\n            update.effective_message.reply_text(res)\n        else:\n            res = \"{} is afk.\\nReason: <code>{}</code>\".format(\n                html.escape(fst_name), html.escape(user.reason)\n            )\n            update.effective_message.reply_text(res, parse_mode=\"html\")\n\n\n\nAFK_HANDLER = DisableAbleCommandHandler(\"afk\", afk)\nAFK_REGEX_HANDLER = DisableAbleMessageHandler(\n    Filters.regex(r\"(?i)^brb(.*)$\"), afk, friendly=\"afk\"\n)\nNO_AFK_HANDLER = MessageHandler(Filters.all & Filters.group, no_longer_afk)\nAFK_REPLY_HANDLER = MessageHandler(Filters.all & Filters.group, reply_afk)\n\ndispatcher.add_handler(AFK_HANDLER, AFK_GROUP)\ndispatcher.add_handler(AFK_REGEX_HANDLER, AFK_GROUP)\ndispatcher.add_handler(NO_AFK_HANDLER, AFK_GROUP)\ndispatcher.add_handler(AFK_REPLY_HANDLER, AFK_REPLY_GROUP)\n\n__mod_name__ = \"AFK\"\n__command_list__ = [\"afk\"]\n__handlers__ = [\n    (AFK_HANDLER, AFK_GROUP),\n    (AFK_REGEX_HANDLER, AFK_GROUP),\n    (NO_AFK_HANDLER, AFK_GROUP),\n    (AFK_REPLY_HANDLER, AFK_REPLY_GROUP),\n]\n","size_bytes":5017},"sitaBot/modules/sql/log_channel_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String, distinct, func\n\n\nclass GroupLogs(BASE):\n    __tablename__ = \"log_channels\"\n    chat_id = Column(String(14), primary_key=True)\n    log_channel = Column(String(14), nullable=False)\n\n    def __init__(self, chat_id, log_channel):\n        self.chat_id = str(chat_id)\n        self.log_channel = str(log_channel)\n\n\nGroupLogs.__table__.create(checkfirst=True)\n\nLOGS_INSERTION_LOCK = threading.RLock()\n\nCHANNELS = {}\n\n\ndef set_chat_log_channel(chat_id, log_channel):\n    with LOGS_INSERTION_LOCK:\n        res = SESSION.query(GroupLogs).get(str(chat_id))\n        if res:\n            res.log_channel = log_channel\n        else:\n            res = GroupLogs(chat_id, log_channel)\n            SESSION.add(res)\n\n        CHANNELS[str(chat_id)] = log_channel\n        SESSION.commit()\n\n\ndef get_chat_log_channel(chat_id):\n    return CHANNELS.get(str(chat_id))\n\n\ndef stop_chat_logging(chat_id):\n    with LOGS_INSERTION_LOCK:\n        res = SESSION.query(GroupLogs).get(str(chat_id))\n        if res:\n            if str(chat_id) in CHANNELS:\n                del CHANNELS[str(chat_id)]\n\n            log_channel = res.log_channel\n            SESSION.delete(res)\n            SESSION.commit()\n            return log_channel\n\n\ndef num_logchannels():\n    try:\n        return SESSION.query(func.count(distinct(GroupLogs.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with LOGS_INSERTION_LOCK:\n        chat = SESSION.query(GroupLogs).get(str(old_chat_id))\n        if chat:\n            chat.chat_id = str(new_chat_id)\n            SESSION.add(chat)\n            if str(old_chat_id) in CHANNELS:\n                CHANNELS[str(new_chat_id)] = CHANNELS.get(str(old_chat_id))\n\n        SESSION.commit()\n\n\ndef __load_log_channels():\n    global CHANNELS\n    try:\n        all_chats = SESSION.query(GroupLogs).all()\n        CHANNELS = {chat.chat_id: chat.log_channel for chat in all_chats}\n    finally:\n        SESSION.close()\n\n\n__load_log_channels()\n","size_bytes":2071},"sitaBot/modules/eval.py":{"content":"import io\nimport os\n\n# Common imports for eval\nimport textwrap\nimport traceback\nfrom contextlib import redirect_stdout\n\nfrom sitaBot import LOGGER, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\nnamespaces = {}\n\n\ndef namespace_of(chat, update, bot):\n    if chat not in namespaces:\n        namespaces[chat] = {\n            \"__builtins__\": globals()[\"__builtins__\"],\n            \"bot\": bot,\n            \"effective_message\": update.effective_message,\n            \"effective_user\": update.effective_user,\n            \"effective_chat\": update.effective_chat,\n            \"update\": update,\n        }\n\n    return namespaces[chat]\n\n\ndef log_input(update):\n    user = update.effective_user.id\n    chat = update.effective_chat.id\n    LOGGER.info(f\"IN: {update.effective_message.text} (user={user}, chat={chat})\")\n\n\ndef send(msg, bot, update):\n    if len(str(msg)) > 2000:\n        with io.BytesIO(str.encode(msg)) as out_file:\n            out_file.name = \"output.txt\"\n            bot.send_document(chat_id=update.effective_chat.id, document=out_file)\n    else:\n        LOGGER.info(f\"OUT: '{msg}'\")\n        bot.send_message(\n            chat_id=update.effective_chat.id,\n            text=f\"`{msg}`\",\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n\n@dev_plus\n@run_async\ndef evaluate(update: Update, context: CallbackContext):\n    bot = context.bot\n    send(do(eval, bot, update), bot, update)\n\n\n@dev_plus\n@run_async\ndef execute(update: Update, context: CallbackContext):\n    bot = context.bot\n    send(do(exec, bot, update), bot, update)\n\n\ndef cleanup_code(code):\n    if code.startswith(\"```\") and code.endswith(\"```\"):\n        return \"\\n\".join(code.split(\"\\n\")[1:-1])\n    return code.strip(\"` \\n\")\n\n\ndef do(func, bot, update):\n    log_input(update)\n    content = update.message.text.split(\" \", 1)[-1]\n    body = cleanup_code(content)\n    env = namespace_of(update.message.chat_id, update, bot)\n\n    os.chdir(os.getcwd())\n    with open(\n        os.path.join(os.getcwd(), \"sitaBot/modules/helper_funcs/temp.txt\"), \"w\"\n    ) as temp:\n        temp.write(body)\n\n    stdout = io.StringIO()\n\n    to_compile = f'def func():\\n{textwrap.indent(body, \"  \")}'\n\n    try:\n        exec(to_compile, env)\n    except Exception as e:\n        return f\"{e.__class__.__name__}: {e}\"\n\n    func = env[\"func\"]\n\n    try:\n        with redirect_stdout(stdout):\n            func_return = func()\n    except Exception as e:\n        value = stdout.getvalue()\n        return f\"{value}{traceback.format_exc()}\"\n    else:\n        value = stdout.getvalue()\n        result = None\n        if func_return is None:\n            if value:\n                result = f\"{value}\"\n            else:\n                try:\n                    result = f\"{repr(eval(body, env))}\"\n                except:\n                    pass\n        else:\n            result = f\"{value}{func_return}\"\n        if result:\n            return result\n\n\n@dev_plus\n@run_async\ndef clear(update: Update, context: CallbackContext):\n    bot = context.bot\n    log_input(update)\n    global namespaces\n    if update.message.chat_id in namespaces:\n        del namespaces[update.message.chat_id]\n    send(\"Cleared locals.\", bot, update)\n\n\nEVAL_HANDLER = CommandHandler((\"e\", \"ev\", \"eva\", \"eval\"), evaluate)\nEXEC_HANDLER = CommandHandler((\"x\", \"ex\", \"exe\", \"exec\", \"py\"), execute)\nCLEAR_HANDLER = CommandHandler(\"clearlocals\", clear)\n\ndispatcher.add_handler(EVAL_HANDLER)\ndispatcher.add_handler(EXEC_HANDLER)\ndispatcher.add_handler(CLEAR_HANDLER)\n\n__mod_name__ = \"Eval Module\"\n","size_bytes":3624},"sitaBot/modules/gtranslator.py":{"content":"try:\n    from emoji import EMOJI_DATA as EMOJI_MAP\nexcept Exception:\n    try:\n        from emoji import UNICODE_EMOJI as EMOJI_MAP\n    except Exception:\n        EMOJI_MAP = {}\nfrom google_trans_new import LANGUAGES, google_translator\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\n\n\n@run_async\ndef totranslate(update: Update, context: CallbackContext):\n    message = update.effective_message\n    problem_lang_code = []\n    for key in LANGUAGES:\n        if \"-\" in key:\n            problem_lang_code.append(key)\n\n    try:\n        if message.reply_to_message:\n            args = update.effective_message.text.split(None, 1)\n            if message.reply_to_message.text:\n                text = message.reply_to_message.text\n            elif message.reply_to_message.caption:\n                text = message.reply_to_message.caption\n\n            try:\n                source_lang = args[1].split(None, 1)[0]\n            except (IndexError, AttributeError):\n                source_lang = \"en\"\n\n        else:\n            args = update.effective_message.text.split(None, 2)\n            text = args[2]\n            source_lang = args[1]\n\n        if source_lang.count(\"-\") == 2:\n            for lang in problem_lang_code:\n                if lang in source_lang:\n                    if source_lang.startswith(lang):\n                        dest_lang = source_lang.rsplit(\"-\", 1)[1]\n                        source_lang = source_lang.rsplit(\"-\", 1)[0]\n                    else:\n                        dest_lang = source_lang.split(\"-\", 1)[1]\n                        source_lang = source_lang.split(\"-\", 1)[0]\n        elif source_lang.count(\"-\") == 1:\n            for lang in problem_lang_code:\n                if lang in source_lang:\n                    dest_lang = source_lang\n                    source_lang = None\n                    break\n            if dest_lang is None:\n                dest_lang = source_lang.split(\"-\")[1]\n                source_lang = source_lang.split(\"-\")[0]\n        else:\n            dest_lang = source_lang\n            source_lang = None\n\n        exclude_list = EMOJI_MAP.keys()\n        for emoji in exclude_list:\n            if emoji in text:\n                text = text.replace(emoji, \"\")\n\n        trl = google_translator()\n        if source_lang is None:\n            detection = trl.detect(text)\n            trans_str = trl.translate(text, lang_tgt=dest_lang)\n            return message.reply_text(\n                f\"Translated from `{detection[0]}` to `{dest_lang}`:\\n`{trans_str}`\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        else:\n            trans_str = trl.translate(text, lang_tgt=dest_lang, lang_src=source_lang)\n            message.reply_text(\n                f\"Translated from `{source_lang}` to `{dest_lang}`:\\n`{trans_str}`\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n    except IndexError:\n        update.effective_message.reply_text(\n            \"Reply to messages or write messages from other languages ‚Äã‚Äãfor translating into the intended language\\n\\n\"\n            \"Example: `/tr en-ml` to translate from English to Malayalam\\n\"\n            \"Or use: `/tr ml` for automatic detection and translating it into Malayalam.\\n\"\n            \"See [List of Language Codes](t.me/OnePunchSupport/12823) for a list of language codes.\",\n            parse_mode=\"markdown\",\n            disable_web_page_preview=True,\n        )\n    except ValueError:\n        update.effective_message.reply_text(\"The intended language is not found!\")\n    else:\n        return\n\n\n__help__ = \"\"\"\n ‚ùç /tr or /tl (language code) as reply to a long message\n*Example:* \n ‚ùç /tr en*:* translates something to english\n ‚ùç /tr hi-en*:* translates hindi to english\n\n*Language Codes*\n`af,am,ar,az,be,bg,bn,bs,ca,ceb,co,cs,cy,da,de,el,en,eo,es,\net,eu,fa,fi,fr,fy,ga,gd,gl,gu,ha,haw,hi,hmn,hr,ht,hu,hy,\nid,ig,is,it,iw,ja,jw,ka,kk,km,kn,ko,ku,ky,la,lb,lo,lt,lv,mg,mi,mk,\nml,mn,mr,ms,mt,my,ne,nl,no,ny,pa,pl,ps,pt,ro,ru,sd,si,sk,sl,\nsm,sn,so,sq,sr,st,su,sv,sw,ta,te,tg,th,tl,tr,uk,ur,uz,\nvi,xh,yi,yo,zh,zh_CN,zh_TW,zu`\n\"\"\"\n\nTRANSLATE_HANDLER = DisableAbleCommandHandler([\"tr\", \"tl\"], totranslate)\n\ndispatcher.add_handler(TRANSLATE_HANDLER)\n\n__mod_name__ = \"G-Trans\"\n__command_list__ = [\"tr\", \"tl\"]\n__handlers__ = [TRANSLATE_HANDLER]\n","size_bytes":4406},"sitaBot/modules/reporting.py":{"content":"import html\n\nfrom sitaBot import LOGGER, DRAGONS, TIGERS, WOLVES, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin, user_not_admin\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.sql import reporting_sql as sql\nfrom telegram import Chat, InlineKeyboardButton, InlineKeyboardMarkup, ParseMode, Update\nfrom telegram.error import BadRequest, Unauthorized\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import mention_html\n\nREPORT_GROUP = 12\nREPORT_IMMUNE_USERS = DRAGONS + TIGERS + WOLVES\n\n\n@run_async\n@user_admin\ndef report_setting(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    msg = update.effective_message\n\n    if chat.type == chat.PRIVATE:\n        if len(args) >= 1:\n            if args[0] in (\"yes\", \"on\"):\n                sql.set_user_setting(chat.id, True)\n                msg.reply_text(\n                    \"Turned on reporting! You'll be notified whenever anyone reports something.\"\n                )\n\n            elif args[0] in (\"no\", \"off\"):\n                sql.set_user_setting(chat.id, False)\n                msg.reply_text(\"Turned off reporting! You wont get any reports.\")\n        else:\n            msg.reply_text(\n                f\"Your current report preference is: `{sql.user_should_report(chat.id)}`\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n    else:\n        if len(args) >= 1:\n            if args[0] in (\"yes\", \"on\"):\n                sql.set_chat_setting(chat.id, True)\n                msg.reply_text(\n                    \"Turned on reporting! Admins who have turned on reports will be notified when /report \"\n                    \"or @admin is called.\"\n                )\n\n            elif args[0] in (\"no\", \"off\"):\n                sql.set_chat_setting(chat.id, False)\n                msg.reply_text(\n                    \"Turned off reporting! No admins will be notified on /report or @admin.\"\n                )\n        else:\n            msg.reply_text(\n                f\"This group's current setting is: `{sql.chat_should_report(chat.id)}`\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n\n@run_async\n@user_not_admin\n@loggable\ndef report(update: Update, context: CallbackContext) -> str:\n    bot = context.bot\n    args = context.args\n    message = update.effective_message\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat and message.reply_to_message and sql.chat_should_report(chat.id):\n        reported_user = message.reply_to_message.from_user\n        chat_name = chat.title or chat.first or chat.username\n        admin_list = chat.get_administrators()\n        message = update.effective_message\n\n        if not args:\n            message.reply_text(\"Add a reason for reporting first.\")\n            return \"\"\n\n        if user.id == reported_user.id:\n            message.reply_text(\"Uh yeah, Sure sure...maso much?\")\n            return \"\"\n\n        if user.id == bot.id:\n            message.reply_text(\"Nice try.\")\n            return \"\"\n\n        if reported_user.id in REPORT_IMMUNE_USERS:\n            message.reply_text(\"Uh? You reporting a disaster?\")\n            return \"\"\n\n        if chat.username and chat.type == Chat.SUPERGROUP:\n\n            reported = f\"{mention_html(user.id, user.first_name)} reported {mention_html(reported_user.id, reported_user.first_name)} to the admins!\"\n\n            msg = (\n                f\"<b>‚ö†Ô∏è Report: </b>{html.escape(chat.title)}\\n\"\n                f\"<b> ‚Ä¢ Report by:</b> {mention_html(user.id, user.first_name)}(<code>{user.id}</code>)\\n\"\n                f\"<b> ‚Ä¢ Reported user:</b> {mention_html(reported_user.id, reported_user.first_name)} (<code>{reported_user.id}</code>)\\n\"\n            )\n            link = f'<b> ‚Ä¢ Reported message:</b> <a href=\"https://t.me/{chat.username}/{message.reply_to_message.message_id}\">click here</a>'\n            should_forward = False\n            keyboard = [\n                [\n                    InlineKeyboardButton(\n                        \"‚û° Message\",\n                        url=f\"https://t.me/{chat.username}/{message.reply_to_message.message_id}\",\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"‚ö† Kick\",\n                        callback_data=f\"report_{chat.id}=kick={reported_user.id}={reported_user.first_name}\",\n                    ),\n                    InlineKeyboardButton(\n                        \"‚õîÔ∏è Ban\",\n                        callback_data=f\"report_{chat.id}=banned={reported_user.id}={reported_user.first_name}\",\n                    ),\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"‚ùé Delete Message\",\n                        callback_data=f\"report_{chat.id}=delete={reported_user.id}={message.reply_to_message.message_id}\",\n                    )\n                ],\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n        else:\n            reported = (\n                f\"{mention_html(user.id, user.first_name)} reported \"\n                f\"{mention_html(reported_user.id, reported_user.first_name)} to the admins!\"\n            )\n\n            msg = f'{mention_html(user.id, user.first_name)} is calling for admins in \"{html.escape(chat_name)}\"!'\n            link = \"\"\n            should_forward = True\n\n        for admin in admin_list:\n            if admin.user.is_bot:  # can't message bots\n                continue\n\n            if sql.user_should_report(admin.user.id):\n                try:\n                    if not chat.type == Chat.SUPERGROUP:\n                        bot.send_message(\n                            admin.user.id, msg + link, parse_mode=ParseMode.HTML\n                        )\n\n                        if should_forward:\n                            message.reply_to_message.forward(admin.user.id)\n\n                            if (\n                                len(message.text.split()) > 1\n                            ):  # If user is giving a reason, send his message too\n                                message.forward(admin.user.id)\n                    if not chat.username:\n                        bot.send_message(\n                            admin.user.id, msg + link, parse_mode=ParseMode.HTML\n                        )\n\n                        if should_forward:\n                            message.reply_to_message.forward(admin.user.id)\n\n                            if (\n                                len(message.text.split()) > 1\n                            ):  # If user is giving a reason, send his message too\n                                message.forward(admin.user.id)\n\n                    if chat.username and chat.type == Chat.SUPERGROUP:\n                        bot.send_message(\n                            admin.user.id,\n                            msg + link,\n                            parse_mode=ParseMode.HTML,\n                            reply_markup=reply_markup,\n                        )\n\n                        if should_forward:\n                            message.reply_to_message.forward(admin.user.id)\n\n                            if (\n                                len(message.text.split()) > 1\n                            ):  # If user is giving a reason, send his message too\n                                message.forward(admin.user.id)\n\n                except Unauthorized:\n                    pass\n                except BadRequest as excp:  # TODO: cleanup exceptions\n                    LOGGER.exception(\"Exception while reporting user\")\n\n        message.reply_to_message.reply_text(\n            f\"{mention_html(user.id, user.first_name)} reported the message to the admins.\",\n            parse_mode=ParseMode.HTML,\n        )\n        return msg\n\n    return \"\"\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, _):\n    return f\"This chat is setup to send user reports to admins, via /report and @admin: `{sql.chat_should_report(chat_id)}`\"\n\n\ndef __user_settings__(user_id):\n    if sql.user_should_report(user_id) is True:\n        text = \"You will receive reports from chats you're admin.\"\n    else:\n        text = \"You will *not* receive reports from chats you're admin.\"\n    return text\n\n\ndef buttons(update: Update, context: CallbackContext):\n    bot = context.bot\n    query = update.callback_query\n    splitter = query.data.replace(\"report_\", \"\").split(\"=\")\n    if splitter[1] == \"kick\":\n        try:\n            bot.kickChatMember(splitter[0], splitter[2])\n            bot.unbanChatMember(splitter[0], splitter[2])\n            query.answer(\"‚úÖ Succesfully kicked\")\n            return \"\"\n        except Exception as err:\n            query.answer(\"üõë Failed to Punch\")\n            bot.sendMessage(\n                text=f\"Error: {err}\",\n                chat_id=query.message.chat_id,\n                parse_mode=ParseMode.HTML,\n            )\n    elif splitter[1] == \"banned\":\n        try:\n            bot.kickChatMember(splitter[0], splitter[2])\n            query.answer(\"‚úÖ  Succesfully Banned\")\n            return \"\"\n        except Exception as err:\n            bot.sendMessage(\n                text=f\"Error: {err}\",\n                chat_id=query.message.chat_id,\n                parse_mode=ParseMode.HTML,\n            )\n            query.answer(\"üõë Failed to Ban\")\n    elif splitter[1] == \"delete\":\n        try:\n            bot.deleteMessage(splitter[0], splitter[3])\n            query.answer(\"‚úÖ Message Deleted\")\n            return \"\"\n        except Exception as err:\n            bot.sendMessage(\n                text=f\"Error: {err}\",\n                chat_id=query.message.chat_id,\n                parse_mode=ParseMode.HTML,\n            )\n            query.answer(\"üõë Failed to delete message!\")\n\n\n__help__ = \"\"\"\n ‚ùç /report <reason>*:* reply to a message to report it to admins.\n ‚ùç @admin*:* reply to a message to report it to admins.\n*NOTE:* Neither of these will get triggered if used by admins.\n\n*Admins only:*\n ‚ùç /reports <on/off>*:* change report setting, or view current status.\n   ‚Ä¢ If done in pm, toggles your status.\n   ‚Ä¢ If in group, toggles that groups's status.\n\"\"\"\n\nSETTING_HANDLER = CommandHandler(\"reports\", report_setting)\nREPORT_HANDLER = CommandHandler(\"report\", report, filters=Filters.group)\nADMIN_REPORT_HANDLER = MessageHandler(Filters.regex(r\"(?i)@admin(s)?\"), report)\n\nREPORT_BUTTON_USER_HANDLER = CallbackQueryHandler(buttons, pattern=r\"report_\")\ndispatcher.add_handler(REPORT_BUTTON_USER_HANDLER)\n\ndispatcher.add_handler(SETTING_HANDLER)\ndispatcher.add_handler(REPORT_HANDLER, REPORT_GROUP)\ndispatcher.add_handler(ADMIN_REPORT_HANDLER, REPORT_GROUP)\n\n__mod_name__ = \"Reports\"\n__handlers__ = [\n    (REPORT_HANDLER, REPORT_GROUP),\n    (ADMIN_REPORT_HANDLER, REPORT_GROUP),\n    (SETTING_HANDLER),\n]\n","size_bytes":11008},"replit.md":{"content":"# sitaBot - Telegram Group Management Bot\n\n## Overview\nsitaBot is a feature-rich Telegram group management bot with comprehensive admin tools, entertainment features, and an advanced economy system. Originally forked from innexiaBot, it has been enhanced with stylish Unicode fonts and a complete economy module.\n\n**Current Status**: ‚úÖ Running successfully\n**Last Updated**: November 5, 2025\n\n## Key Features\n\n### Admin & Moderation\n- User bans, kicks, mutes, and warnings\n- Anti-flood protection\n- Blacklist words and stickers\n- Approval system for users\n- Fed (Federation) system for cross-group management\n- Night mode (scheduled group locking)\n- Zombie (deleted accounts) cleanup\n\n### Entertainment & Fun\n- Games (truth or dare, dice, etc.)\n- AI chatbot integration\n- Anime info lookup\n- Music downloads\n- Fun text generators (mock, zalgo, etc.)\n- Shipping game\n- Quotly (quote maker)\n- Sticker tools\n- Wikipedia search\n- Weather info\n\n### Economy System üí∞\nComplete economy module with:\n- **Balance Management**: Check and manage user balances\n- **Rob Command**: 50% success rate to steal from others\n- **Kill/Revive**: 60% kill success, death penalties, revival system\n- **Protection**: Shield yourself from robberies\n- **Lottery**: Gambling system with random rewards\n- **Items**: Gift items between users with inventory tracking\n- **Daily Bonuses**: Reward active users\n- **Global Leaderboards**: Track richest users and top killers\n\n### Utilities\n- Currency converter\n- Google Translator\n- Time zone lookup\n- Speed test\n- Text-to-speech & Speech-to-text\n- Telegraph uploader\n- Lyrics finder\n- Logo maker\n- QR code generator\n\n## Project Architecture\n\n### Technology Stack\n- **Python**: 3.9\n- **Bot Framework**: python-telegram-bot 12.8\n- **Additional Libraries**: Telethon 1.16.4, Pyrogram\n- **Databases**: \n  - PostgreSQL (via SQLAlchemy) - for user data, settings, economy\n  - MongoDB - for some modular features\n- **Background Jobs**: APScheduler for scheduled tasks\n\n### Directory Structure\n```\nsitaBot/\n‚îú‚îÄ‚îÄ __init__.py           # Bot initialization, database connections\n‚îú‚îÄ‚îÄ __main__.py          # Main entry point, module loader\n‚îú‚îÄ‚îÄ config.py            # Configuration (uses environment variables)\n‚îú‚îÄ‚îÄ modules/             # Feature modules\n‚îÇ   ‚îú‚îÄ‚îÄ economy.py       # Economy system commands\n‚îÇ   ‚îú‚îÄ‚îÄ start_stylish.py # Stylish start/help with Unicode fonts\n‚îÇ   ‚îú‚îÄ‚îÄ admin.py         # Admin commands\n‚îÇ   ‚îú‚îÄ‚îÄ bans.py          # Ban management\n‚îÇ   ‚îú‚îÄ‚îÄ fun.py           # Fun commands\n‚îÇ   ‚îî‚îÄ‚îÄ sql/             # Database schemas\n‚îÇ       ‚îî‚îÄ‚îÄ economy_sql.py\n‚îú‚îÄ‚îÄ sample_config.py     # Sample configuration template\n‚îî‚îÄ‚îÄ requirements.txt     # Python dependencies\n```\n\n### Recent Changes\n\n#### November 5, 2025 - Complete Transformation\n1. **Security Enhancement**\n   - Removed all hardcoded API keys from config.py\n   - Migrated to Replit Secrets for all sensitive data\n   - Added comprehensive .gitignore\n\n2. **Rebranding**\n   - Renamed entire codebase from \"innexiaBot\" to \"sitaBot\"\n   - Updated all references across 50+ files\n   - Changed bot mention from @InnexiaBot to @sitaBot\n\n3. **Economy System Implementation**\n   - Added complete economy module (`economy.py`)\n   - Created economy database schema (`economy_sql.py`)\n   - Features: rob, kill, revive, protect, lottery, items/gifting\n   - Global tracking with leaderboards\n\n4. **UI Enhancement**\n   - Updated start/help buttons with fancy Unicode fonts\n   - Improved visual appeal:  ô·¥è·¥õ, ·¥Ä ô·¥è·¥ú·¥õ, s·¥ú·¥ò·¥ò·¥è Ä·¥õ, ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥ás,  ú·¥á ü·¥ò\n\n5. **Environment Setup**\n   - Installed Python 3.9\n   - Configured all 60+ dependencies\n   - Set up Replit workflow for auto-restart\n\n## Configuration\n\n### Required Environment Variables (Replit Secrets)\nAll sensitive configuration is stored in Replit Secrets:\n\n#### Core Bot Settings\n- `TOKEN` - Telegram Bot Token from @BotFather\n- `API_ID` - Telegram API ID from my.telegram.org\n- `API_HASH` - Telegram API Hash from my.telegram.org\n- `OWNER_ID` - Telegram user ID of bot owner\n\n#### Database Settings\n- `SQLALCHEMY_DATABASE_URI` - PostgreSQL connection string\n- `MONGO_DB_URI` - MongoDB connection string\n\n#### Optional Settings\n- `BOT_ID` - Bot's Telegram ID\n- `ENV` - Environment (set to \"PRODUCTION\")\n- `EVENT_LOGS` - Channel ID for event logging\n- `JOIN_LOGGER` - Channel ID for join/leave logs\n- `SPAMWATCH_API` - SpamWatch API key (optional)\n- `GENIUS_API_TOKEN` - Genius lyrics API (optional)\n\n### Module Loading\nThe bot automatically loads all modules from `sitaBot/modules/` except those in the blacklist. Currently not loading:\n- `translation` (disabled)\n\nAll other 100+ modules are active including the new economy module.\n\n## Database Schema\n\n### Economy Tables\n- **user_economy**: Stores user balances, kills, deaths\n- **user_protection**: Tracks protection status and expiry\n- **user_items**: User inventory system\n- **lottery_history**: Lottery participation records\n\n## Development Notes\n\n### Code Conventions\n- Uses snake_case for functions and variables\n- Handlers follow pattern: `@run_async` decorator for non-blocking\n- SQL operations use SQLAlchemy ORM\n- Error handling with try-except blocks\n- Logging via Python logging module\n\n### Adding New Modules\n1. Create file in `sitaBot/modules/`\n2. Import necessary handlers from `telegram.ext`\n3. Define command handlers with `@run_async`\n4. Add to `__HANDLERS__` list at bottom\n5. Optionally add to `__mod_name__` and `__help__`\n\n### Database Migrations\n- Currently using direct SQLAlchemy Base.metadata.create_all()\n- For production, consider using Alembic for migrations\n\n## User Preferences\n- **Security First**: Always use environment variables, never hardcode secrets\n- **Clean Code**: Remove unused code, maintain organized file structure\n- **Documentation**: Keep this file updated with major changes\n\n## Workflow\n\n### Running the Bot\nThe bot runs automatically via the Replit workflow:\n```bash\npython3 -m sitaBot\n```\n\n### Stopping/Restarting\n- Use the Replit UI to stop/restart the workflow\n- Bot will auto-restart on code changes (via workflow)\n\n## Known Issues & Warnings\n- `SpamWatch API key missing` - Optional feature, not critical\n- `No str key: GENIUS_API_TOKEN` - Optional for lyrics, not critical\n- LSP diagnostics in economy files - minor type warnings, not affecting functionality\n\n## Future Enhancements (Potential)\n- Add more economy features (shops, auctions, trading)\n- Implement web dashboard for bot management\n- Add more games and entertainment modules\n- Enhance anti-spam with machine learning\n- Add support for more languages\n\n## Support & Resources\n- **Bot Username**: @sitaBot (configure in Telegram)\n- **Original Source**: innexiaBot (heavily modified)\n- **Python Telegram Bot Docs**: https://python-telegram-bot.readthedocs.io/\n\n## Dependencies Summary\nOver 60 packages installed including:\n- python-telegram-bot, Telethon, Pyrogram (bot frameworks)\n- SQLAlchemy, pymongo (databases)\n- APScheduler (task scheduling)\n- lxml, BeautifulSoup4 (parsing)\n- And many specialized libraries for features\n\n## License\nInherited from innexiaBot - Check original repository for license terms.\n\n---\n\n**Note**: This bot is fully functional and running. All core features including the new economy system are operational. Make sure all required environment variables are set in Replit Secrets before starting.\n","size_bytes":7424},"sitaBot/modules/connection.py":{"content":"import time\nimport re\n\nfrom telegram import ParseMode, InlineKeyboardMarkup, InlineKeyboardButton, Update, Bot\nfrom telegram.error import BadRequest, Unauthorized\nfrom telegram.ext import CommandHandler, CallbackQueryHandler, run_async\n\nimport sitaBot.modules.sql.connection_sql as sql\nfrom sitaBot import dispatcher, DRAGONS, DEV_USERS\nfrom sitaBot.modules.helper_funcs import chat_status\nfrom sitaBot.modules.helper_funcs.alternate import send_message, typing_action\n\nuser_admin = chat_status.user_admin\n\n\n@user_admin\n@run_async\n@typing_action\ndef allow_connections(update, context) -> str:\n\n    chat = update.effective_chat\n    args = context.args\n\n    if chat.type != chat.PRIVATE:\n        if len(args) >= 1:\n            var = args[0]\n            if var == \"no\":\n                sql.set_allow_connect_to_chat(chat.id, False)\n                send_message(\n                    update.effective_message,\n                    \"Connection has been disabled for this chat\",\n                )\n            elif var == \"yes\":\n                sql.set_allow_connect_to_chat(chat.id, True)\n                send_message(\n                    update.effective_message,\n                    \"Connection has been enabled for this chat\",\n                )\n            else:\n                send_message(\n                    update.effective_message,\n                    \"Please enter `yes` or `no`!\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n        else:\n            get_settings = sql.allow_connect_to_chat(chat.id)\n            if get_settings:\n                send_message(\n                    update.effective_message,\n                    \"Connections to this group are *Allowed* for members!\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n            else:\n                send_message(\n                    update.effective_message,\n                    \"Connection to this group are *Not Allowed* for members!\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n    else:\n        send_message(\n            update.effective_message, \"This command is for group only. Not in PM!\"\n        )\n\n\n@run_async\n@typing_action\ndef connection_chat(update, context):\n\n    chat = update.effective_chat\n    user = update.effective_user\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type != \"private\":\n            return\n        chat = update.effective_chat\n        chat_name = update.effective_message.chat.title\n\n    if conn:\n        message = \"You are currently connected to {}.\\n\".format(chat_name)\n    else:\n        message = \"You are currently not connected in any group.\\n\"\n    send_message(update.effective_message, message, parse_mode=\"markdown\")\n\n\n@run_async\n@typing_action\ndef connect_chat(update, context):\n\n    chat = update.effective_chat\n    user = update.effective_user\n    args = context.args\n\n    if update.effective_chat.type == \"private\":\n        if args and len(args) >= 1:\n            try:\n                connect_chat = int(args[0])\n                getstatusadmin = context.bot.get_chat_member(\n                    connect_chat, update.effective_message.from_user.id\n                )\n            except ValueError:\n                try:\n                    connect_chat = str(args[0])\n                    get_chat = context.bot.getChat(connect_chat)\n                    connect_chat = get_chat.id\n                    getstatusadmin = context.bot.get_chat_member(\n                        connect_chat, update.effective_message.from_user.id\n                    )\n                except BadRequest:\n                    send_message(update.effective_message, \"Invalid Chat ID!\")\n                    return\n            except BadRequest:\n                send_message(update.effective_message, \"Invalid Chat ID!\")\n                return\n\n            isadmin = getstatusadmin.status in (\"administrator\", \"creator\")\n            ismember = getstatusadmin.status in (\"member\")\n            isallow = sql.allow_connect_to_chat(connect_chat)\n\n            if (isadmin) or (isallow and ismember) or (user.id in DRAGONS):\n                connection_status = sql.connect(\n                    update.effective_message.from_user.id, connect_chat\n                )\n                if connection_status:\n                    conn_chat = dispatcher.bot.getChat(\n                        connected(context.bot, update, chat, user.id, need_admin=False)\n                    )\n                    chat_name = conn_chat.title\n                    send_message(\n                        update.effective_message,\n                        \"Successfully connected to *{}*. \\nUse /helpconnect to check available commands.\".format(\n                            chat_name\n                        ),\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                    sql.add_history_conn(user.id, str(conn_chat.id), chat_name)\n                else:\n                    send_message(update.effective_message, \"Connection failed!\")\n            else:\n                send_message(\n                    update.effective_message, \"Connection to this chat is not allowed!\"\n                )\n        else:\n            gethistory = sql.get_history_conn(user.id)\n            if gethistory:\n                buttons = [\n                    InlineKeyboardButton(\n                        text=\"‚ùé Close button\", callback_data=\"connect_close\"\n                    ),\n                    InlineKeyboardButton(\n                        text=\"üßπ Clear history\", callback_data=\"connect_clear\"\n                    ),\n                ]\n            else:\n                buttons = []\n            conn = connected(context.bot, update, chat, user.id, need_admin=False)\n            if conn:\n                connectedchat = dispatcher.bot.getChat(conn)\n                text = \"You are currently connected to *{}* (`{}`)\".format(\n                    connectedchat.title, conn\n                )\n                buttons.append(\n                    InlineKeyboardButton(\n                        text=\"üîå Disconnect\", callback_data=\"connect_disconnect\"\n                    )\n                )\n            else:\n                text = \"Write the chat ID or tag to connect!\"\n            if gethistory:\n                text += \"\\n\\n*Connection history:*\\n\"\n                text += \"‚ïí‚ïê‚ïê‚ïê„Äå *Info* „Äç\\n\"\n                text += \"‚îÇ  Sorted: `Newest`\\n\"\n                text += \"‚îÇ\\n\"\n                buttons = [buttons]\n                for x in sorted(gethistory.keys(), reverse=True):\n                    htime = time.strftime(\"%d/%m/%Y\", time.localtime(x))\n                    text += \"‚ïû‚ïê„Äå *{}* „Äç\\n‚îÇ   `{}`\\n‚îÇ   `{}`\\n\".format(\n                        gethistory[x][\"chat_name\"], gethistory[x][\"chat_id\"], htime\n                    )\n                    text += \"‚îÇ\\n\"\n                    buttons.append(\n                        [\n                            InlineKeyboardButton(\n                                text=gethistory[x][\"chat_name\"],\n                                callback_data=\"connect({})\".format(\n                                    gethistory[x][\"chat_id\"]\n                                ),\n                            )\n                        ]\n                    )\n                text += \"‚ïò‚ïê‚ïê„Äå Total {} Chats „Äç\".format(\n                    str(len(gethistory)) + \" (max)\"\n                    if len(gethistory) == 5\n                    else str(len(gethistory))\n                )\n                conn_hist = InlineKeyboardMarkup(buttons)\n            elif buttons:\n                conn_hist = InlineKeyboardMarkup([buttons])\n            else:\n                conn_hist = None\n            send_message(\n                update.effective_message,\n                text,\n                parse_mode=\"markdown\",\n                reply_markup=conn_hist,\n            )\n\n    else:\n        getstatusadmin = context.bot.get_chat_member(\n            chat.id, update.effective_message.from_user.id\n        )\n        isadmin = getstatusadmin.status in (\"administrator\", \"creator\")\n        ismember = getstatusadmin.status in (\"member\")\n        isallow = sql.allow_connect_to_chat(chat.id)\n        if (isadmin) or (isallow and ismember) or (user.id in DRAGONS):\n            connection_status = sql.connect(\n                update.effective_message.from_user.id, chat.id\n            )\n            if connection_status:\n                chat_name = dispatcher.bot.getChat(chat.id).title\n                send_message(\n                    update.effective_message,\n                    \"Successfully connected to *{}*.\".format(chat_name),\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n                try:\n                    sql.add_history_conn(user.id, str(chat.id), chat_name)\n                    context.bot.send_message(\n                        update.effective_message.from_user.id,\n                        \"You are connected to *{}*. \\nUse `/helpconnect` to check available commands.\".format(\n                            chat_name\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n                except BadRequest:\n                    pass\n                except Unauthorized:\n                    pass\n            else:\n                send_message(update.effective_message, \"Connection failed!\")\n        else:\n            send_message(\n                update.effective_message, \"Connection to this chat is not allowed!\"\n            )\n\n\ndef disconnect_chat(update, context):\n\n    if update.effective_chat.type == \"private\":\n        disconnection_status = sql.disconnect(update.effective_message.from_user.id)\n        if disconnection_status:\n            sql.disconnected_chat = send_message(\n                update.effective_message, \"Disconnected from chat!\"\n            )\n        else:\n            send_message(update.effective_message, \"You're not connected!\")\n    else:\n        send_message(update.effective_message, \"This command is only available in PM.\")\n\n\ndef connected(bot: Bot, update: Update, chat, user_id, need_admin=True):\n    user = update.effective_user\n\n    if chat.type == chat.PRIVATE and sql.get_connected_chat(user_id):\n\n        conn_id = sql.get_connected_chat(user_id).chat_id\n        getstatusadmin = bot.get_chat_member(\n            conn_id, update.effective_message.from_user.id\n        )\n        isadmin = getstatusadmin.status in (\"administrator\", \"creator\")\n        ismember = getstatusadmin.status in (\"member\")\n        isallow = sql.allow_connect_to_chat(conn_id)\n\n        if (\n            (isadmin)\n            or (isallow and ismember)\n            or (user.id in DRAGONS)\n            or (user.id in DEV_USERS)\n        ):\n            if need_admin is True:\n                if (\n                    getstatusadmin.status in (\"administrator\", \"creator\")\n                    or user_id in DRAGONS\n                    or user.id in DEV_USERS\n                ):\n                    return conn_id\n                else:\n                    send_message(\n                        update.effective_message,\n                        \"You must be an admin in the connected group!\",\n                    )\n            else:\n                return conn_id\n        else:\n            send_message(\n                update.effective_message,\n                \"The group changed the connection rights or you are no longer an admin.\\nI've disconnected you.\",\n            )\n            disconnect_chat(update, bot)\n    else:\n        return False\n\n\nCONN_HELP = \"\"\"\n Actions are available with connected groups:\n ‚Ä¢ View and edit Notes.\n ‚Ä¢ View and edit Filters.\n ‚Ä¢ Get invite link of chat.\n ‚Ä¢ Set and control AntiFlood settings.\n ‚Ä¢ Set and control Blacklist settings.\n ‚Ä¢ Set Locks and Unlocks in chat.\n ‚Ä¢ Enable and Disable commands in chat.\n ‚Ä¢ Export and Imports of chat backup.\n ‚Ä¢ More in future!\"\"\"\n\n\n@run_async\ndef help_connect_chat(update, context):\n\n    args = context.args\n\n    if update.effective_message.chat.type != \"private\":\n        send_message(update.effective_message, \"PM me with that command to get help.\")\n        return\n    else:\n        send_message(update.effective_message, CONN_HELP, parse_mode=\"markdown\")\n\n\n@run_async\ndef connect_button(update, context):\n\n    query = update.callback_query\n    chat = update.effective_chat\n    user = update.effective_user\n\n    connect_match = re.match(r\"connect\\((.+?)\\)\", query.data)\n    disconnect_match = query.data == \"connect_disconnect\"\n    clear_match = query.data == \"connect_clear\"\n    connect_close = query.data == \"connect_close\"\n\n    if connect_match:\n        target_chat = connect_match.group(1)\n        getstatusadmin = context.bot.get_chat_member(target_chat, query.from_user.id)\n        isadmin = getstatusadmin.status in (\"administrator\", \"creator\")\n        ismember = getstatusadmin.status in (\"member\")\n        isallow = sql.allow_connect_to_chat(target_chat)\n\n        if (isadmin) or (isallow and ismember) or (user.id in DRAGONS):\n            connection_status = sql.connect(query.from_user.id, target_chat)\n\n            if connection_status:\n                conn_chat = dispatcher.bot.getChat(\n                    connected(context.bot, update, chat, user.id, need_admin=False)\n                )\n                chat_name = conn_chat.title\n                query.message.edit_text(\n                    \"Successfully connected to *{}*. \\nUse `/helpconnect` to check available commands.\".format(\n                        chat_name\n                    ),\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n                sql.add_history_conn(user.id, str(conn_chat.id), chat_name)\n            else:\n                query.message.edit_text(\"Connection failed!\")\n        else:\n            context.bot.answer_callback_query(\n                query.id, \"Connection to this chat is not allowed!\", show_alert=True\n            )\n    elif disconnect_match:\n        disconnection_status = sql.disconnect(query.from_user.id)\n        if disconnection_status:\n            sql.disconnected_chat = query.message.edit_text(\"Disconnected from chat!\")\n        else:\n            context.bot.answer_callback_query(\n                query.id, \"You're not connected!\", show_alert=True\n            )\n    elif clear_match:\n        sql.clear_history_conn(query.from_user.id)\n        query.message.edit_text(\"History connected has been cleared!\")\n    elif connect_close:\n        query.message.edit_text(\"Closed.\\nTo open again, type /connect\")\n    else:\n        connect_chat(update, context)\n\n\n__mod_name__ = \"Connect\"\n\n__help__ = \"\"\"\nSometimes, you just want to add some notes and filters to a group chat, but you don't want everyone to see; This is where connections come in...\nThis allows you to connect to a chat's database, and add things to it without the commands appearing in chat! For obvious reasons, you need to be an admin to add things; but any member in the group can view your data.\n\n ‚ùç /connect: Connects to chat (Can be done in a group by /connect or /connect <chat id> in PM)\n ‚ùç /connection: List connected chats\n ‚ùç /disconnect: Disconnect from a chat\n ‚ùç /helpconnect: List available commands that can be used remotely\n\n*Admin only:*\n ‚ùç /allowconnect <yes/no>: allow a user to connect to a chat\n\"\"\"\n\nCONNECT_CHAT_HANDLER = CommandHandler(\"connect\", connect_chat, pass_args=True)\nCONNECTION_CHAT_HANDLER = CommandHandler(\"connection\", connection_chat)\nDISCONNECT_CHAT_HANDLER = CommandHandler(\"disconnect\", disconnect_chat)\nALLOW_CONNECTIONS_HANDLER = CommandHandler(\n    \"allowconnect\", allow_connections, pass_args=True\n)\nHELP_CONNECT_CHAT_HANDLER = CommandHandler(\"helpconnect\", help_connect_chat)\nCONNECT_BTN_HANDLER = CallbackQueryHandler(connect_button, pattern=r\"connect\")\n\ndispatcher.add_handler(CONNECT_CHAT_HANDLER)\ndispatcher.add_handler(CONNECTION_CHAT_HANDLER)\ndispatcher.add_handler(DISCONNECT_CHAT_HANDLER)\ndispatcher.add_handler(ALLOW_CONNECTIONS_HANDLER)\ndispatcher.add_handler(HELP_CONNECT_CHAT_HANDLER)\ndispatcher.add_handler(CONNECT_BTN_HANDLER)\n","size_bytes":16217},"sitaBot/modules/misc.py":{"content":"from sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot import dispatcher\n\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram import ParseMode, Update\nfrom telegram.ext.dispatcher import run_async\nfrom telegram.ext import CallbackContext, Filters, CommandHandler\n\nMARKDOWN_HELP = f\"\"\"\nMarkdown is a very powerful formatting tool supported by telegram. {dispatcher.bot.first_name} has some enhancements, to make sure that \\\nsaved messages are correctly parsed, and to allow you to create buttons.\n\n‚Ä¢ <code>_italic_</code>: wrapping text with '_' will produce italic text\n‚Ä¢ <code>*bold*</code>: wrapping text with '*' will produce bold text\n‚Ä¢ <code>`code`</code>: wrapping text with '`' will produce monospaced text, also known as 'code'\n‚Ä¢ <code>[sometext](someURL)</code>: this will create a link - the message will just show <code>sometext</code>, \\\nand tapping on it will open the page at <code>someURL</code>.\n<b>Example:</b><code>[test](example.com)</code>\n\n‚Ä¢ <code>[buttontext](buttonurl:someURL)</code>: this is a special enhancement to allow users to have telegram \\\nbuttons in their markdown. <code>buttontext</code> will be what is displayed on the button, and <code>someurl</code> \\\nwill be the url which is opened.\n<b>Example:</b> <code>[This is a button](buttonurl:example.com)</code>\n\nIf you want multiple buttons on the same line, use :same, as such:\n<code>[one](buttonurl://example.com)\n[two](buttonurl://google.com:same)</code>\nThis will create two buttons on a single line, instead of one button per line.\n\nKeep in mind that your message <b>MUST</b> contain some text other than just a button!\n\"\"\"\n\n\n@run_async\n@user_admin\ndef echo(update: Update, context: CallbackContext):\n    args = update.effective_message.text.split(None, 1)\n    message = update.effective_message\n\n    if message.reply_to_message:\n        message.reply_to_message.reply_text(\n            args[1], parse_mode=\"MARKDOWN\", disable_web_page_preview=True\n        )\n    else:\n        message.reply_text(\n            args[1], quote=False, parse_mode=\"MARKDOWN\", disable_web_page_preview=True\n        )\n    message.delete()\n\n\ndef markdown_help_sender(update: Update):\n    update.effective_message.reply_text(MARKDOWN_HELP, parse_mode=ParseMode.HTML)\n    update.effective_message.reply_text(\n        \"Try forwarding the following message to me, and you'll see, and Use #test!\"\n    )\n    update.effective_message.reply_text(\n        \"/save test This is a markdown test. _italics_, *bold*, code, \"\n        \"[URL](example.com) [button](buttonurl:github.com) \"\n        \"[button2](buttonurl://google.com:same)\"\n    )\n\n\n@run_async\ndef markdown_help(update: Update, context: CallbackContext):\n    if update.effective_chat.type != \"private\":\n        update.effective_message.reply_text(\n            \"Contact me in pm\",\n            reply_markup=InlineKeyboardMarkup(\n                [\n                    [\n                        InlineKeyboardButton(\n                            \"Markdown help\",\n                            url=f\"t.me/{context.bot.username}?start=markdownhelp\",\n                        )\n                    ]\n                ]\n            ),\n        )\n        return\n    markdown_help_sender(update)\n\n\n__help__ = \"\"\"\n*Available commands:*\n*Markdown:*\n ‚ùç /markdownhelp*:* quick summary of how markdown works in telegram - can only be called in private chats\n*Paste:*\n ‚ùç /paste*:* Saves replied content to `nekobin.com` and replies with a url\n*React:*\n ‚ùç /react*:* Reacts with a random reaction \n*Urban Dictonary:*\n ‚ùç /ud <word>*:* Type the word or expression you want to search use\n*Wikipedia:*\n ‚ùç /wiki <query>*:* wikipedia your query\n*Wallpapers:*\n ‚ùç /wall <query>*:* get a wallpaper from wall.alphacoders.com\n*live cricket score*\n ‚ùç /cs*:* Latest live scores from cricinfo\n*Currency converter:* \n ‚ùç /cash*:* currency converter\nExample:\n `/cash 1 USD INR`  \n      _OR_\n `/cash 1 usd inr`\nOutput: `1.0 USD = 75.505 INR`\n\n*MATHS*\nSolves complex math problems using https://newton.now.sh\n‚ùç /math*:* Math `/math 2^2+2(2)`\n‚ùç /factor*:* Factor `/factor x^2 + 2x`\n‚ùç /derive*:* Derive `/derive x^2+2x`\n‚ùç /integrate*:* Integrate `/integrate x^2+2x`\n‚ùç /zeroes*:* Find 0's `/zeroes x^2+2x`\n‚ùç /tangent*:* Find Tangent `/tangent 2lx^3`\n‚ùç /area*:* Area Under Curve `/area 2:4lx^3`\n‚ùç /cos*:* Cosine `/cos pi`\n‚ùç /sin*:* Sine `/sin 0`\n‚ùç /tan*:* Tangent `/tan 0`\n‚ùç /arccos*:* Inverse Cosine `/arccos 1`\n‚ùç /arcsin*:* Inverse Sine `/arcsin 0`\n‚ùç /arctan*:* Inverse Tangent `/arctan 0`\n‚ùç /abs*:* Absolute Value `/abs -1`\n‚ùç /log*:* Logarithm `/log 2l8`\n\n_Keep in mind_: To find the tangent line of a function at a certain x value, send the request as c|f(x) where c is the given x value and f(x) is the function expression, the separator is a vertical bar '|'. See the table above for an example request.\nTo find the area under a function, send the request as c:d|f(x) where c is the starting x value, d is the ending x value, and f(x) is the function under which you want the curve between the two x values.\nTo compute fractions, enter expressions as numerator(over)denominator. For example, to process 2/4 you must send in your expression as 2(over)4. The result expression will be in standard math notation (1/2, 3/4).\n\nüí°`Read From Top`\n\"\"\"\n\nECHO_HANDLER = DisableAbleCommandHandler(\"echo\", echo, filters=Filters.group)\nMD_HELP_HANDLER = CommandHandler(\"markdownhelp\", markdown_help)\n\ndispatcher.add_handler(ECHO_HANDLER)\ndispatcher.add_handler(MD_HELP_HANDLER)\n\n__mod_name__ = \"Extras\"\n__command_list__ = [\"id\", \"echo\"]\n__handlers__ = [\n    ECHO_HANDLER,\n    MD_HELP_HANDLER,\n]\n","size_bytes":5720},"sitaBot/modules/stickers.py":{"content":"import os\nimport math\nimport requests\nimport cloudscraper\nimport urllib.request as urllib\nfrom PIL import Image\nfrom html import escape\nfrom bs4 import BeautifulSoup as bs\n\nfrom telegram import ParseMode, InlineKeyboardMarkup, InlineKeyboardButton\nfrom telegram import TelegramError, Update\nfrom telegram.ext import run_async, CallbackContext\nfrom telegram.utils.helpers import mention_html\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\n\ncombot_stickers_url = \"https://combot.org/telegram/stickers?q=\"\n\n\n@run_async\ndef stickerid(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    if msg.reply_to_message and msg.reply_to_message.sticker:\n        update.effective_message.reply_text(\n            \"Hello \"\n            + f\"{mention_html(msg.from_user.id, msg.from_user.first_name)}\"\n            + \", The sticker id you are replying is :\\n <code>\"\n            + escape(msg.reply_to_message.sticker.file_id)\n            + \"</code>\",\n            parse_mode=ParseMode.HTML,\n        )\n    else:\n        update.effective_message.reply_text(\n            \"Hello \"\n            + f\"{mention_html(msg.from_user.id, msg.from_user.first_name)}\"\n            + \", Please reply to sticker message to get id sticker\",\n            parse_mode=ParseMode.HTML,\n        )\n\n\n@run_async\ndef cb_sticker(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    split = msg.text.split(\" \", 1)\n    if len(split) == 1:\n        msg.reply_text(\"Provide some name to search for pack.\")\n        return\n\n    scraper = cloudscraper.create_scraper()\n    text = scraper.get(combot_stickers_url + split[1]).text\n    soup = bs(text, \"lxml\")\n    results = soup.find_all(\"a\", {\"class\": \"sticker-pack__btn\"})\n    titles = soup.find_all(\"div\", \"sticker-pack__title\")\n    if not results:\n        msg.reply_text(\"No results found :(.\")\n        return\n    reply = f\"Stickers for *{split[1]}*:\"\n    for result, title in zip(results, titles):\n        link = result[\"href\"]\n        reply += f\"\\n‚Ä¢ [{title.get_text()}]({link})\"\n    msg.reply_text(reply, parse_mode=ParseMode.MARKDOWN)\n\ndef getsticker(update: Update, context: CallbackContext):\n    bot = context.bot\n    msg = update.effective_message\n    chat_id = update.effective_chat.id\n    if msg.reply_to_message and msg.reply_to_message.sticker:\n        file_id = msg.reply_to_message.sticker.file_id\n        new_file = bot.get_file(file_id)\n        new_file.download(\"sticker.png\")\n        bot.send_document(chat_id, document=open(\"sticker.png\", \"rb\"))\n        os.remove(\"sticker.png\")\n    else:\n        update.effective_message.reply_text(\n            \"Please reply to a sticker for me to upload its PNG.\"\n        )\n\n\n@run_async\ndef kang(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    user = update.effective_user\n    args = context.args\n    packnum = 0\n    packname = \"a\" + str(user.id) + \"_by_\" + context.bot.username\n    packname_found = 0\n    max_stickers = 120\n    while packname_found == 0:\n        try:\n            stickerset = context.bot.get_sticker_set(packname)\n            if len(stickerset.stickers) >= max_stickers:\n                packnum += 1\n                packname = (\n                    \"a\"\n                    + str(packnum)\n                    + \"_\"\n                    + str(user.id)\n                    + \"_by_\"\n                    + context.bot.username\n                )\n            else:\n                packname_found = 1\n        except TelegramError as e:\n            if e.message == \"Stickerset_invalid\":\n                packname_found = 1\n    kangsticker = \"kangsticker.png\"\n    is_animated = False\n    file_id = \"\"\n\n    if msg.reply_to_message:\n        if msg.reply_to_message.sticker:\n            if msg.reply_to_message.sticker.is_animated:\n                is_animated = True\n            file_id = msg.reply_to_message.sticker.file_id\n\n        elif msg.reply_to_message.photo:\n            file_id = msg.reply_to_message.photo[-1].file_id\n        elif msg.reply_to_message.document:\n            file_id = msg.reply_to_message.document.file_id\n        else:\n            msg.reply_text(\"Yea, I can't kang that.\")\n\n        kang_file = context.bot.get_file(file_id)\n        if not is_animated:\n            kang_file.download(\"kangsticker.png\")\n        else:\n            kang_file.download(\"kangsticker.tgs\")\n\n        if args:\n            sticker_emoji = str(args[0])\n        elif msg.reply_to_message.sticker and msg.reply_to_message.sticker.emoji:\n            sticker_emoji = msg.reply_to_message.sticker.emoji\n        else:\n            sticker_emoji = \"ü§î\"\n\n        if not is_animated:\n            try:\n                im = Image.open(kangsticker)\n                maxsize = (512, 512)\n                if (im.width and im.height) < 512:\n                    size1 = im.width\n                    size2 = im.height\n                    if im.width > im.height:\n                        scale = 512 / size1\n                        size1new = 512\n                        size2new = size2 * scale\n                    else:\n                        scale = 512 / size2\n                        size1new = size1 * scale\n                        size2new = 512\n                    size1new = math.floor(size1new)\n                    size2new = math.floor(size2new)\n                    sizenew = (size1new, size2new)\n                    im = im.resize(sizenew)\n                else:\n                    im.thumbnail(maxsize)\n                if not msg.reply_to_message.sticker:\n                    im.save(kangsticker, \"PNG\")\n                context.bot.add_sticker_to_set(\n                    user_id=user.id,\n                    name=packname,\n                    png_sticker=open(\"kangsticker.png\", \"rb\"),\n                    emojis=sticker_emoji,\n                )\n                msg.reply_text(\n                    f\"Sticker successfully added to [pack](t.me/addstickers/{packname})\"\n                    + f\"\\nEmoji is: {sticker_emoji}\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n\n            except OSError as e:\n                msg.reply_text(\"I can only kang images m8.\")\n                print(e)\n                return\n\n            except TelegramError as e:\n                if e.message == \"Stickerset_invalid\":\n                    makepack_internal(\n                        update,\n                        context,\n                        msg,\n                        user,\n                        sticker_emoji,\n                        packname,\n                        packnum,\n                        png_sticker=open(\"kangsticker.png\", \"rb\"),\n                    )\n                elif e.message == \"Sticker_png_dimensions\":\n                    im.save(kangsticker, \"PNG\")\n                    context.bot.add_sticker_to_set(\n                        user_id=user.id,\n                        name=packname,\n                        png_sticker=open(\"kangsticker.png\", \"rb\"),\n                        emojis=sticker_emoji,\n                    )\n                    msg.reply_text(\n                        f\"Sticker successfully added to [pack](t.me/addstickers/{packname})\"\n                        + f\"\\nEmoji is: {sticker_emoji}\",\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                elif e.message == \"Invalid sticker emojis\":\n                    msg.reply_text(\"Invalid emoji(s).\")\n                elif e.message == \"Stickers_too_much\":\n                    msg.reply_text(\"Max packsize reached. Press F to pay respecc.\")\n                elif e.message == \"Internal Server Error: sticker set not found (500)\":\n                    msg.reply_text(\n                        \"Sticker successfully added to [pack](t.me/addstickers/%s)\"\n                        % packname\n                        + \"\\n\"\n                        \"Emoji is:\" + \" \" + sticker_emoji,\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                print(e)\n\n        else:\n            packname = \"animated\" + str(user.id) + \"_by_\" + context.bot.username\n            packname_found = 0\n            max_stickers = 50\n            while packname_found == 0:\n                try:\n                    stickerset = context.bot.get_sticker_set(packname)\n                    if len(stickerset.stickers) >= max_stickers:\n                        packnum += 1\n                        packname = (\n                            \"animated\"\n                            + str(packnum)\n                            + \"_\"\n                            + str(user.id)\n                            + \"_by_\"\n                            + context.bot.username\n                        )\n                    else:\n                        packname_found = 1\n                except TelegramError as e:\n                    if e.message == \"Stickerset_invalid\":\n                        packname_found = 1\n            try:\n                context.bot.add_sticker_to_set(\n                    user_id=user.id,\n                    name=packname,\n                    tgs_sticker=open(\"kangsticker.tgs\", \"rb\"),\n                    emojis=sticker_emoji,\n                )\n                msg.reply_text(\n                    f\"Sticker successfully added to [pack](t.me/addstickers/{packname})\"\n                    + f\"\\nEmoji is: {sticker_emoji}\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n            except TelegramError as e:\n                if e.message == \"Stickerset_invalid\":\n                    makepack_internal(\n                        update,\n                        context,\n                        msg,\n                        user,\n                        sticker_emoji,\n                        packname,\n                        packnum,\n                        tgs_sticker=open(\"kangsticker.tgs\", \"rb\"),\n                    )\n                elif e.message == \"Invalid sticker emojis\":\n                    msg.reply_text(\"Invalid emoji(s).\")\n                elif e.message == \"Internal Server Error: sticker set not found (500)\":\n                    msg.reply_text(\n                        \"Sticker successfully added to [pack](t.me/addstickers/%s)\"\n                        % packname\n                        + \"\\n\"\n                        \"Emoji is:\" + \" \" + sticker_emoji,\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                print(e)\n\n    elif args:\n        try:\n            try:\n                urlemoji = msg.text.split(\" \")\n                png_sticker = urlemoji[1]\n                sticker_emoji = urlemoji[2]\n            except IndexError:\n                sticker_emoji = \"ü§î\"\n            urllib.urlretrieve(png_sticker, kangsticker)\n            im = Image.open(kangsticker)\n            maxsize = (512, 512)\n            if (im.width and im.height) < 512:\n                size1 = im.width\n                size2 = im.height\n                if im.width > im.height:\n                    scale = 512 / size1\n                    size1new = 512\n                    size2new = size2 * scale\n                else:\n                    scale = 512 / size2\n                    size1new = size1 * scale\n                    size2new = 512\n                size1new = math.floor(size1new)\n                size2new = math.floor(size2new)\n                sizenew = (size1new, size2new)\n                im = im.resize(sizenew)\n            else:\n                im.thumbnail(maxsize)\n            im.save(kangsticker, \"PNG\")\n            msg.reply_photo(photo=open(\"kangsticker.png\", \"rb\"))\n            context.bot.add_sticker_to_set(\n                user_id=user.id,\n                name=packname,\n                png_sticker=open(\"kangsticker.png\", \"rb\"),\n                emojis=sticker_emoji,\n            )\n            msg.reply_text(\n                f\"Sticker successfully added to [pack](t.me/addstickers/{packname})\"\n                + f\"\\nEmoji is: {sticker_emoji}\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        except OSError as e:\n            msg.reply_text(\"I can only kang images m8.\")\n            print(e)\n            return\n        except TelegramError as e:\n            if e.message == \"Stickerset_invalid\":\n                makepack_internal(\n                    update,\n                    context,\n                    msg,\n                    user,\n                    sticker_emoji,\n                    packname,\n                    packnum,\n                    png_sticker=open(\"kangsticker.png\", \"rb\"),\n                )\n            elif e.message == \"Sticker_png_dimensions\":\n                im.save(kangsticker, \"PNG\")\n                context.bot.add_sticker_to_set(\n                    user_id=user.id,\n                    name=packname,\n                    png_sticker=open(\"kangsticker.png\", \"rb\"),\n                    emojis=sticker_emoji,\n                )\n                msg.reply_text(\n                    \"Sticker successfully added to [pack](t.me/addstickers/%s)\"\n                    % packname\n                    + \"\\n\"\n                    + \"Emoji is:\"\n                    + \" \"\n                    + sticker_emoji,\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n            elif e.message == \"Invalid sticker emojis\":\n                msg.reply_text(\"Invalid emoji(s).\")\n            elif e.message == \"Stickers_too_much\":\n                msg.reply_text(\"Max packsize reached. Press F to pay respecc.\")\n            elif e.message == \"Internal Server Error: sticker set not found (500)\":\n                msg.reply_text(\n                    \"Sticker successfully added to [pack](t.me/addstickers/%s)\"\n                    % packname\n                    + \"\\n\"\n                    \"Emoji is:\" + \" \" + sticker_emoji,\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n            print(e)\n    else:\n        packs = \"Please reply to a sticker, or image to kang it!\\nOh, by the way. here are your packs:\\n\"\n        if packnum > 0:\n            firstpackname = \"a\" + str(user.id) + \"_by_\" + context.bot.username\n            for i in range(0, packnum + 1):\n                if i == 0:\n                    packs += f\"[pack](t.me/addstickers/{firstpackname})\\n\"\n                else:\n                    packs += f\"[pack{i}](t.me/addstickers/{packname})\\n\"\n        else:\n            packs += f\"[pack](t.me/addstickers/{packname})\"\n        msg.reply_text(packs, parse_mode=ParseMode.MARKDOWN)\n    try:\n        if os.path.isfile(\"kangsticker.png\"):\n            os.remove(\"kangsticker.png\")\n        elif os.path.isfile(\"kangsticker.tgs\"):\n            os.remove(\"kangsticker.tgs\")\n    except:\n        pass\n\n\ndef makepack_internal(\n    update,\n    context,\n    msg,\n    user,\n    emoji,\n    packname,\n    packnum,\n    png_sticker=None,\n    tgs_sticker=None,\n):\n    name = user.first_name\n    name = name[:50]\n    try:\n        extra_version = \"\"\n        if packnum > 0:\n            extra_version = \" \" + str(packnum)\n        if png_sticker:\n            success = context.bot.create_new_sticker_set(\n                user.id,\n                packname,\n                f\"{name}s kang pack\" + extra_version,\n                png_sticker=png_sticker,\n                emojis=emoji,\n            )\n        if tgs_sticker:\n            success = context.bot.create_new_sticker_set(\n                user.id,\n                packname,\n                f\"{name}s animated kang pack\" + extra_version,\n                tgs_sticker=tgs_sticker,\n                emojis=emoji,\n            )\n\n    except TelegramError as e:\n        print(e)\n        if e.message == \"Sticker set name is already occupied\":\n            msg.reply_text(\n                \"Your pack can be found [here](t.me/addstickers/%s)\" % packname,\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        elif e.message in (\"Peer_id_invalid\", \"bot was blocked by the user\"):\n            msg.reply_text(\n                \"Contact me in PM first.\",\n                reply_markup=InlineKeyboardMarkup(\n                    [\n                        [\n                            InlineKeyboardButton(\n                                text=\"Start\", url=f\"t.me/{context.bot.username}\"\n                            )\n                        ]\n                    ]\n                ),\n            )\n        elif e.message == \"Internal Server Error: created sticker set not found (500)\":\n            msg.reply_text(\n                \"Sticker pack successfully created. Get it [here](t.me/addstickers/%s)\"\n                % packname,\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        return\n\n    if success:\n        msg.reply_text(\n            \"Sticker pack successfully created. Get it [here](t.me/addstickers/%s)\"\n            % packname,\n            parse_mode=ParseMode.MARKDOWN,\n        )\n    else:\n        msg.reply_text(\"Failed to create sticker pack. Possibly due to blek mejik.\")\n\n\n__help__ = \"\"\"\n ‚ùç /stickerid*:* reply to a sticker to me to tell you its file ID.\n ‚ùç /getsticker*:* reply to a sticker to me to upload its raw PNG file.\n ‚ùç /kang*:* reply to a sticker to add it to your pack.\n ‚ùç /stickers*:* Find stickers for given term on combot sticker catalogue\n\"\"\"\n\n__mod_name__ = \"Stickers\"\nSTICKERID_HANDLER = DisableAbleCommandHandler(\"stickerid\", stickerid)\nGETSTICKER_HANDLER = DisableAbleCommandHandler(\"getsticker\", getsticker)\nKANG_HANDLER = DisableAbleCommandHandler(\"kang\", kang, admin_ok=True)\nSTICKERS_HANDLER = DisableAbleCommandHandler(\"stickers\", cb_sticker)\n\ndispatcher.add_handler(STICKERS_HANDLER)\ndispatcher.add_handler(STICKERID_HANDLER)\ndispatcher.add_handler(GETSTICKER_HANDLER)\ndispatcher.add_handler(KANG_HANDLER)","size_bytes":17662},"sitaBot/modules/sql/aihelp_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String\n\n\nclass aiChats(BASE):\n    __tablename__ = \"ai_chats\"\n    chat_id = Column(String(14), primary_key=True)\n    ses_id = Column(String(70))\n    expires = Column(String(15))\n\n    def __init__(self, chat_id, ses_id, expires):\n        self.chat_id = chat_id\n        self.ses_id = ses_id\n        self.expires = expires\n\n\naiChats.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\n\n\ndef is_chat(chat_id):\n    try:\n        chat = SESSION.query(aiChats).get(str(chat_id))\n        if chat:\n            return True\n        return False\n    finally:\n        SESSION.close()\n\n\ndef set_ses(chat_id, ses_id, expires):\n    with INSERTION_LOCK:\n        autochat = SESSION.query(aiChats).get(str(chat_id))\n        if not autochat:\n            autochat = aiChats(str(chat_id), str(ses_id), str(expires))\n        else:\n            autochat.ses_id = str(ses_id)\n            autochat.expires = str(expires)\n\n        SESSION.add(autochat)\n        SESSION.commit()\n\n\ndef get_ses(chat_id):\n    autochat = SESSION.query(aiChats).get(str(chat_id))\n    sesh = \"\"\n    exp = \"\"\n    if autochat:\n        sesh = str(autochat.ses_id)\n        exp = str(autochat.expires)\n\n    SESSION.close()\n    return sesh, exp\n\n\ndef rem_chat(chat_id):\n    with INSERTION_LOCK:\n        autochat = SESSION.query(aiChats).get(str(chat_id))\n        if autochat:\n            SESSION.delete(autochat)\n\n        SESSION.commit()\n\n\ndef get_all_chats():\n    try:\n        return SESSION.query(aiChats.chat_id).all()\n    finally:\n        SESSION.close()","size_bytes":1613},"sitaBot/modules/sql/blacklistusers_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, String, UnicodeText\n\n\nclass BlacklistUsers(BASE):\n    __tablename__ = \"blacklistusers\"\n    user_id = Column(String(14), primary_key=True)\n    reason = Column(UnicodeText)\n\n    def __init__(self, user_id, reason=None):\n        self.user_id = user_id\n        self.reason = reason\n\n\nBlacklistUsers.__table__.create(checkfirst=True)\n\nBLACKLIST_LOCK = threading.RLock()\nBLACKLIST_USERS = set()\n\n\ndef blacklist_user(user_id, reason=None):\n    with BLACKLIST_LOCK:\n        user = SESSION.query(BlacklistUsers).get(str(user_id))\n        if not user:\n            user = BlacklistUsers(str(user_id), reason)\n        else:\n            user.reason = reason\n\n        SESSION.add(user)\n        SESSION.commit()\n        __load_blacklist_userid_list()\n\n\ndef unblacklist_user(user_id):\n    with BLACKLIST_LOCK:\n        user = SESSION.query(BlacklistUsers).get(str(user_id))\n        if user:\n            SESSION.delete(user)\n\n        SESSION.commit()\n        __load_blacklist_userid_list()\n\n\ndef get_reason(user_id):\n    user = SESSION.query(BlacklistUsers).get(str(user_id))\n    rep = \"\"\n    if user:\n        rep = user.reason\n\n    SESSION.close()\n    return rep\n\n\ndef is_user_blacklisted(user_id):\n    return user_id in BLACKLIST_USERS\n\n\ndef __load_blacklist_userid_list():\n    global BLACKLIST_USERS\n    try:\n        BLACKLIST_USERS = {int(x.user_id) for x in SESSION.query(BlacklistUsers).all()}\n    finally:\n        SESSION.close()\n\n\n__load_blacklist_userid_list()\n","size_bytes":1547},"sitaBot/modules/sed.py":{"content":"import sre_constants\n\nimport regex\nimport telegram\nfrom sitaBot import LOGGER, dispatcher\nfrom sitaBot.modules.disable import DisableAbleMessageHandler\nfrom sitaBot.modules.helper_funcs.regex_helper import infinite_loop_check\nfrom telegram import Update\nfrom telegram.ext import CallbackContext, Filters, run_async\n\nDELIMITERS = (\"/\", \":\", \"|\", \"_\")\n\n\ndef separate_sed(sed_string):\n    if (\n        len(sed_string) >= 3\n        and sed_string[1] in DELIMITERS\n        and sed_string.count(sed_string[1]) >= 2\n    ):\n        delim = sed_string[1]\n        start = counter = 2\n        while counter < len(sed_string):\n            if sed_string[counter] == \"\\\\\":\n                counter += 1\n\n            elif sed_string[counter] == delim:\n                replace = sed_string[start:counter]\n                counter += 1\n                start = counter\n                break\n\n            counter += 1\n\n        else:\n            return None\n\n        while counter < len(sed_string):\n            if (\n                sed_string[counter] == \"\\\\\"\n                and counter + 1 < len(sed_string)\n                and sed_string[counter + 1] == delim\n            ):\n                sed_string = sed_string[:counter] + sed_string[counter + 1 :]\n\n            elif sed_string[counter] == delim:\n                replace_with = sed_string[start:counter]\n                counter += 1\n                break\n\n            counter += 1\n        else:\n            return replace, sed_string[start:], \"\"\n\n        flags = \"\"\n        if counter < len(sed_string):\n            flags = sed_string[counter:]\n        return replace, replace_with, flags.lower()\n\n\n@run_async\ndef sed(update: Update, context: CallbackContext):\n    sed_result = separate_sed(update.effective_message.text)\n    if sed_result and update.effective_message.reply_to_message:\n        if update.effective_message.reply_to_message.text:\n            to_fix = update.effective_message.reply_to_message.text\n        elif update.effective_message.reply_to_message.caption:\n            to_fix = update.effective_message.reply_to_message.caption\n        else:\n            return\n\n        repl, repl_with, flags = sed_result\n        if not repl:\n            update.effective_message.reply_to_message.reply_text(\n                \"You're trying to replace... \" \"nothing with something?\"\n            )\n            return\n\n        try:\n            try:\n                check = regex.match(repl, to_fix, flags=regex.IGNORECASE, timeout=5)\n            except TimeoutError:\n                return\n            if check and check.group(0).lower() == to_fix.lower():\n                update.effective_message.reply_to_message.reply_text(\n                    \"Hey everyone, {} is trying to make \"\n                    \"me say stuff I don't wanna \"\n                    \"say!\".format(update.effective_user.first_name)\n                )\n                return\n            if infinite_loop_check(repl):\n                update.effective_message.reply_text(\n                    \"I'm afraid I can't run that regex.\"\n                )\n                return\n            if \"i\" in flags and \"g\" in flags:\n                text = regex.sub(\n                    repl, repl_with, to_fix, flags=regex.I, timeout=3\n                ).strip()\n            elif \"i\" in flags:\n                text = regex.sub(\n                    repl, repl_with, to_fix, count=1, flags=regex.I, timeout=3\n                ).strip()\n            elif \"g\" in flags:\n                text = regex.sub(repl, repl_with, to_fix, timeout=3).strip()\n            else:\n                text = regex.sub(repl, repl_with, to_fix, count=1, timeout=3).strip()\n        except TimeoutError:\n            update.effective_message.reply_text(\"Timeout\")\n            return\n        except sre_constants.error:\n            LOGGER.warning(update.effective_message.text)\n            LOGGER.exception(\"SRE constant error\")\n            update.effective_message.reply_text(\"Do you even sed? Apparently not.\")\n            return\n\n        # empty string errors -_-\n        if len(text) >= telegram.MAX_MESSAGE_LENGTH:\n            update.effective_message.reply_text(\n                \"The result of the sed command was too long for \\\n                                                 telegram!\"\n            )\n        elif text:\n            update.effective_message.reply_to_message.reply_text(text)\n\n\n\n__mod_name__ = \"Sed/Regex\"\n\nSED_HANDLER = DisableAbleMessageHandler(\n    Filters.regex(r\"s([{}]).*?\\1.*\".format(\"\".join(DELIMITERS))), sed, friendly=\"sed\"\n)\n\ndispatcher.add_handler(SED_HANDLER)\n","size_bytes":4552},"sitaBot/modules/sql_extended/night_mode_sql.py":{"content":"from sqlalchemy import Boolean, Column, Integer, String, UnicodeText\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass Nightmode(BASE):\n    __tablename__ = \"nightmode\"\n    chat_id = Column(String(14), primary_key=True)\n\n    def __init__(self, chat_id):\n        self.chat_id = chat_id\n\n\nNightmode.__table__.create(checkfirst=True)\n\n\ndef add_nightmode(chat_id: str):\n    nightmoddy = Nightmode(str(chat_id))\n    SESSION.add(nightmoddy)\n    SESSION.commit()\n\n\ndef rmnightmode(chat_id: str):\n    rmnightmoddy = SESSION.query(Nightmode).get(str(chat_id))\n    if rmnightmoddy:\n        SESSION.delete(rmnightmoddy)\n        SESSION.commit()\n\n\ndef get_all_chat_id():\n    stark = SESSION.query(Nightmode).all()\n    SESSION.close()\n    return stark\n\n\ndef is_nightmode_indb(chat_id: str):\n    try:\n        s__ = SESSION.query(Nightmode).get(str(chat_id))\n        if s__:\n            return str(s__.chat_id)\n    finally:\n        SESSION.close()\n","size_bytes":936},"sitaBot/modules/__weather.py":{"content":"from sitaBot import telethn as tbot\nimport io\nimport os\nimport time\n\nimport aiohttp\nfrom telethon import *\nfrom telethon.tl import functions\nfrom telethon.tl import types\nfrom telethon.tl.types import *\n\nfrom sitaBot import *\n\nfrom sitaBot.events import register\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n        return isinstance(\n            (\n                await tbot(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerUser):\n        return True\n\n\n@register(pattern=\"^/weather (.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n\n    sample_url = (\n        \"https://api.openweathermap.org/data/2.5/weather?q={}&APPID={}&units=metric\"\n    )\n    input_str = event.pattern_match.group(1)\n    async with aiohttp.ClientSession() as session:\n        response_api_zero = await session.get(\n            sample_url.format(input_str, OPENWEATHERMAP_ID)\n        )\n    response_api = await response_api_zero.json()\n    if response_api[\"cod\"] == 200:\n        country_code = response_api[\"sys\"][\"country\"]\n        country_time_zone = int(response_api[\"timezone\"])\n        sun_rise_time = int(response_api[\"sys\"][\"sunrise\"]) + country_time_zone\n        sun_set_time = int(response_api[\"sys\"][\"sunset\"]) + country_time_zone\n        await event.reply(\n            \"\"\"**Location**: {}\n**Temperature**: {}¬∞–°\n    __minimium__: {}¬∞–°\n    __maximum__ : {}¬∞–°\n**Humidity**: {}%\n**Wind**: {}m/s\n**Clouds**: {}hpa\n**Sunrise**: {} {}\n**Sunset**: {} {}\"\"\".format(\n                input_str,\n                response_api[\"main\"][\"temp\"],\n                response_api[\"main\"][\"temp_min\"],\n                response_api[\"main\"][\"temp_max\"],\n                response_api[\"main\"][\"humidity\"],\n                response_api[\"wind\"][\"speed\"],\n                response_api[\"clouds\"][\"all\"],\n                # response_api[\"main\"][\"pressure\"],\n                time.strftime(\"%Y-%m-%d %H:%M:%S\", time.gmtime(sun_rise_time)),\n                country_code,\n                time.strftime(\"%Y-%m-%d %H:%M:%S\", time.gmtime(sun_set_time)),\n                country_code,\n            )\n        )\n    else:\n        await event.reply(response_api[\"message\"])\n\n\n@register(pattern=\"^/wttr (.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n\n    sample_url = \"https://wttr.in/{}.png\"\n    # logger.info(sample_url)\n    input_str = event.pattern_match.group(1)\n    async with aiohttp.ClientSession() as session:\n        response_api_zero = await session.get(sample_url.format(input_str))\n        # logger.info(response_api_zero)\n        response_api = await response_api_zero.read()\n        with io.BytesIO(response_api) as out_file:\n            await event.reply(file=out_file)\n","size_bytes":2890},"sitaBot/modules/music.py":{"content":"import asyncio\nimport io\nimport os\nimport time\n\nimport lyricsgenius\nimport requests\nimport wget\nfrom pyrogram import filters\nfrom pyrogram.types import Message\nfrom tswift import Song\nfrom youtube_dl import YoutubeDL\nfrom youtubesearchpython import SearchVideos\n\nfrom sitaBot.conf import get_str_key\nfrom sitaBot.pyrogramee.pluginshelper import get_text, progress\nfrom sitaBot import pbot\n\nGENIUS = get_str_key(\"GENIUS_API_TOKEN\", None)\n\n\n@pbot.on_message(filters.command([\"vsong\", \"video\"]))\nasync def ytmusic(client, message: Message):\n    urlissed = get_text(message)\n\n    pablo = await client.send_message(\n        message.chat.id, f\"`Getting {urlissed} From Youtube Servers. Please Wait.`\"\n    )\n    if not urlissed:\n        await pablo.edit(\"Invalid Command Syntax, Please Check Help Menu To Know More!\")\n        return\n\n    search = SearchVideos(f\"{urlissed}\", offset=1, mode=\"dict\", max_results=1)\n    mi = search.result()\n    mio = mi[\"search_result\"]\n    mo = mio[0][\"link\"]\n    thum = mio[0][\"title\"]\n    fridayz = mio[0][\"id\"]\n    thums = mio[0][\"channel\"]\n    kekme = f\"https://img.youtube.com/vi/{fridayz}/hqdefault.jpg\"\n    await asyncio.sleep(0.6)\n    url = mo\n    sedlyf = wget.download(kekme)\n    opts = {\n        \"format\": \"best\",\n        \"addmetadata\": True,\n        \"key\": \"FFmpegMetadata\",\n        \"prefer_ffmpeg\": True,\n        \"geo_bypass\": True,\n        \"nocheckcertificate\": True,\n        \"postprocessors\": [{\"key\": \"FFmpegVideoConvertor\", \"preferedformat\": \"mp4\"}],\n        \"outtmpl\": \"%(id)s.mp4\",\n        \"logtostderr\": False,\n        \"quiet\": True,\n    }\n    try:\n        with YoutubeDL(opts) as ytdl:\n            ytdl_data = ytdl.extract_info(url, download=True)\n    except Exception as e:\n        await event.edit(event, f\"**Failed To Download** \\n**Error :** `{str(e)}`\")\n        return\n    c_time = time.time()\n    file_stark = f\"{ytdl_data['id']}.mp4\"\n    capy = f\"**Video Name ‚û†** `{thum}` \\n**Requested For :** `{urlissed}` \\n**Channel :** `{thums}` \\n**Link :** `{mo}`\"\n    await client.send_video(\n        message.chat.id,\n        video=open(file_stark, \"rb\"),\n        duration=int(ytdl_data[\"duration\"]),\n        file_name=str(ytdl_data[\"title\"]),\n        thumb=sedlyf,\n        caption=capy,\n        supports_streaming=True,\n        progress=progress,\n        progress_args=(\n            pablo,\n            c_time,\n            f\"`Uploading {urlissed} Song From YouTube Music!`\",\n            file_stark,\n        ),\n    )\n    await pablo.delete()\n    for files in (sedlyf, file_stark):\n        if files and os.path.exists(files):\n            os.remove(files)\n\n\n@pbot.on_message(filters.command([\"music\", \"song\"]))\nasync def ytmusic(client, message: Message):\n    urlissed = get_text(message)\n    if not urlissed:\n        await client.send_message(\n            message.chat.id,\n            \"Invalid Command Syntax, Please Check Help Menu To Know More!\",\n        )\n        return\n    pablo = await client.send_message(\n        message.chat.id, f\"`Getting {urlissed} From Youtube Servers. Please Wait.`\"\n    )\n    search = SearchVideos(f\"{urlissed}\", offset=1, mode=\"dict\", max_results=1)\n    mi = search.result()\n    mio = mi[\"search_result\"]\n    mo = mio[0][\"link\"]\n    mio[0][\"duration\"]\n    thum = mio[0][\"title\"]\n    fridayz = mio[0][\"id\"]\n    thums = mio[0][\"channel\"]\n    kekme = f\"https://img.youtube.com/vi/{fridayz}/hqdefault.jpg\"\n    await asyncio.sleep(0.6)\n    sedlyf = wget.download(kekme)\n    opts = {\n        \"format\": \"bestaudio\",\n        \"addmetadata\": True,\n        \"key\": \"FFmpegMetadata\",\n        \"writethumbnail\": True,\n        \"prefer_ffmpeg\": True,\n        \"geo_bypass\": True,\n        \"nocheckcertificate\": True,\n        \"postprocessors\": [\n            {\n                \"key\": \"FFmpegExtractAudio\",\n                \"preferredcodec\": \"mp3\",\n                \"preferredquality\": \"720\",\n            }\n        ],\n        \"outtmpl\": \"%(id)s.mp3\",\n        \"quiet\": True,\n        \"logtostderr\": False,\n    }\n    try:\n        with YoutubeDL(opts) as ytdl:\n            ytdl_data = ytdl.extract_info(mo, download=True)\n    except Exception as e:\n        await pablo.edit(f\"**Failed To Download** \\n**Error :** `{str(e)}`\")\n        return\n    c_time = time.time()\n    capy = f\"**Song Name :** `{thum}` \\n**Requested For :** `{urlissed}` \\n**Channel :** `{thums}` \\n**Link :** `{mo}`\"\n    file_stark = f\"{ytdl_data['id']}.mp3\"\n    await client.send_audio(\n        message.chat.id,\n        audio=open(file_stark, \"rb\"),\n        duration=int(ytdl_data[\"duration\"]),\n        title=str(ytdl_data[\"title\"]),\n        performer=str(ytdl_data[\"uploader\"]),\n        thumb=sedlyf,\n        caption=capy,\n        progress=progress,\n        progress_args=(\n            pablo,\n            c_time,\n            f\"`Uploading {urlissed} Song From YouTube Music!`\",\n            file_stark,\n        ),\n    )\n    await pablo.delete()\n    for files in (sedlyf, file_stark):\n        if files and os.path.exists(files):\n            os.remove(files)\n\n\n@pbot.on_message(filters.command([\"lyric\", \"lyrics\"]))\nasync def _(client, message):\n    lel = await message.reply(\"Searching For Lyrics.....\")\n    query = message.text\n    if not query:\n        await lel.edit(\"`What I am Supposed to find `\")\n        return\n\n    song = \"\"\n    song = Song.find_song(query)\n    if song:\n        if song.lyrics:\n            reply = song.format()\n        else:\n            reply = \"Couldn't find any lyrics for that song! try with artist name along with song if still doesnt work try `.glyrics`\"\n    else:\n        reply = \"lyrics not found! try with artist name along with song if still doesnt work try `.glyrics`\"\n\n    if len(reply) > 4095:\n        with io.BytesIO(str.encode(reply)) as out_file:\n            out_file.name = \"lyrics.text\"\n            await client.send_document(\n                message.chat.id,\n                out_file,\n                force_document=True,\n                allow_cache=False,\n                caption=query,\n                reply_to_msg_id=message.message_id,\n            )\n            await lel.delete()\n    else:\n        await lel.edit(reply)  # edit or reply\n\n\n@pbot.on_message(filters.command([\"glyric\", \"glyrics\"]))\nasync def lyrics(client, message):\n\n    if r\"-\" in message.text:\n        pass\n    else:\n        await message.reply(\n            \"`Error: please use '-' as divider for <artist> and <song>`\\n\"\n            \"eg: `.glyrics Nicki Minaj - Super Bass`\"\n        )\n        return\n\n    if GENIUS is None:\n        await message.reply(\n            \"`Provide genius access token to config.py or Heroku Config first kthxbye!`\"\n        )\n    else:\n        genius = lyricsgenius.Genius(GENIUS)\n        try:\n            args = message.text.split(\".lyrics\")[1].split(\"-\")\n            artist = args[0].strip(\" \")\n            song = args[1].strip(\" \")\n        except Exception:\n            await message.reply(\"`Lel please provide artist and song names`\")\n            return\n\n    if len(args) < 1:\n        await message.reply(\"`Please provide artist and song names`\")\n        return\n\n    lel = await message.reply(f\"`Searching lyrics for {artist} - {song}...`\")\n\n    try:\n        songs = genius.search_song(song, artist)\n    except TypeError:\n        songs = None\n\n    if songs is None:\n        await lel.edit(f\"Song **{artist} - {song}** not found!\")\n        return\n    if len(songs.lyrics) > 4096:\n        await lel.edit(\"`Lyrics is too big, view the file to see it.`\")\n        with open(\"lyrics.txt\", \"w+\") as f:\n            f.write(f\"Search query: \\n{artist} - {song}\\n\\n{songs.lyrics}\")\n        await client.send_document(\n            message.chat.id,\n            \"lyrics.txt\",\n            reply_to_msg_id=message.message_id,\n        )\n        os.remove(\"lyrics.txt\")\n    else:\n        await lel.edit(\n            f\"**Search query**: \\n`{artist} - {song}`\\n\\n```{songs.lyrics}```\"\n        )\n    return\n\n\n","size_bytes":7850},"sitaBot/__init__.py":{"content":"import logging\nimport os\nimport sys\nimport time\nimport spamwatch\n\nimport telegram.ext as tg\nfrom pyrogram import Client, errors\nfrom telethon import TelegramClient\n\nStartTime = time.time()\n\n# enable logging\nlogging.basicConfig(\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    handlers=[logging.FileHandler(\"log.txt\"), logging.StreamHandler()],\n    level=logging.INFO,\n)\n\nLOGGER = logging.getLogger(__name__)\n\n# if version < 3.6, stop bot.\nif sys.version_info[0] < 3 or sys.version_info[1] < 6:\n    LOGGER.error(\n        \"You MUST have a python version of at least 3.6! Multiple features depend on this. Bot quitting.\"\n    )\n    quit(1)\n\nENV = bool(os.environ.get(\"ENV\", False))\n\nif ENV:\n    TOKEN = os.environ.get(\"TOKEN\", None)\n\n    try:\n        OWNER_ID = int(os.environ.get(\"OWNER_ID\", None))\n    except ValueError:\n        raise Exception(\"Your OWNER_ID env variable is not a valid integer.\")\n\n    JOIN_LOGGER = os.environ.get(\"JOIN_LOGGER\", None)\n    OWNER_USERNAME = os.environ.get(\"OWNER_USERNAME\", None)\n\n    try:\n        DRAGONS = set(int(x) for x in os.environ.get(\"DRAGONS\", \"\").split())\n        DEV_USERS = set(int(x) for x in os.environ.get(\"DEV_USERS\", \"\").split())\n    except ValueError:\n        raise Exception(\"Your sudo or dev users list does not contain valid integers.\")\n\n    try:\n        DEMONS = set(int(x) for x in os.environ.get(\"DEMONS\", \"\").split())\n    except ValueError:\n        raise Exception(\"Your support users list does not contain valid integers.\")\n\n    try:\n        WOLVES = set(int(x) for x in os.environ.get(\"WOLVES\", \"\").split())\n    except ValueError:\n        raise Exception(\"Your whitelisted users list does not contain valid integers.\")\n\n    try:\n        TIGERS = set(int(x) for x in os.environ.get(\"TIGERS\", \"\").split())\n    except ValueError:\n        raise Exception(\"Your tiger users list does not contain valid integers.\")\n\n    INFOPIC = bool(os.environ.get(\"INFOPIC\", False))\n    EVENT_LOGS = os.environ.get(\"EVENT_LOGS\", None)\n    WEBHOOK = bool(os.environ.get(\"WEBHOOK\", False))\n    URL = os.environ.get(\"URL\", \"\")  # Does not contain token\n    PORT = int(os.environ.get(\"PORT\", 5000))\n    CERT_PATH = os.environ.get(\"CERT_PATH\")\n    API_ID = os.environ.get(\"API_ID\", None)\n    API_HASH = os.environ.get(\"API_HASH\", None)\n    BOT_ID = int(os.environ.get(\"BOT_ID\", 0)) if os.environ.get(\"BOT_ID\") else 0\n    DB_URI = os.environ.get(\"DATABASE_URL\")\n    MONGO_DB_URI = os.environ.get(\"MONGO_DB_URI\", None)\n    DONATION_LINK = os.environ.get(\"DONATION_LINK\")\n    HEROKU_API_KEY = os.environ.get(\"HEROKU_API_KEY\", None)\n    HEROKU_APP_NAME = os.environ.get(\"HEROKU_APP_NAME\", None)\n    TEMP_DOWNLOAD_DIRECTORY = os.environ.get(\"TEMP_DOWNLOAD_DIRECTORY\", \"./\")\n    OPENWEATHERMAP_ID = os.environ.get(\"OPENWEATHERMAP_ID\", None)\n    VIRUS_API_KEY = os.environ.get(\"VIRUS_API_KEY\", None)\n    LOAD = os.environ.get(\"LOAD\", \"\").split()\n    NO_LOAD = os.environ.get(\"NO_LOAD\", \"translation\").split()\n    DEL_CMDS = bool(os.environ.get(\"DEL_CMDS\", False))\n    STRICT_GBAN = bool(os.environ.get(\"STRICT_GBAN\", False))\n    WORKERS = int(os.environ.get(\"WORKERS\", 8))\n    BAN_STICKER = os.environ.get(\"BAN_STICKER\", \"CAADAgADOwADPPEcAXkko5EB3YGYAg\")\n    ALLOW_EXCL = os.environ.get(\"ALLOW_EXCL\", False)\n    CASH_API_KEY = os.environ.get(\"CASH_API_KEY\", None)\n    TIME_API_KEY = os.environ.get(\"TIME_API_KEY\", None)\n    AI_API_KEY = os.environ.get(\"AI_API_KEY\", None)\n    WALL_API = os.environ.get(\"WALL_API\", None)\n    SUPPORT_CHAT = os.environ.get(\"SUPPORT_CHAT\", None)\n    SPAMWATCH_SUPPORT_CHAT = os.environ.get(\"SPAMWATCH_SUPPORT_CHAT\", None)\n    SPAMWATCH_API = os.environ.get(\"SPAMWATCH_API\", None)\n\n    ALLOW_CHATS = os.environ.get(\"ALLOW_CHATS\", True)\n\n    try:\n        BL_CHATS = set(int(x) for x in os.environ.get(\"BL_CHATS\", \"\").split())\n    except ValueError:\n        raise Exception(\"Your blacklisted chats list does not contain valid integers.\")\n\nelse:\n    from sitaBot.config import Development as Config\n\n    TOKEN = Config.TOKEN\n\n    try:\n        OWNER_ID = int(Config.OWNER_ID)\n    except ValueError:\n        raise Exception(\"Your OWNER_ID variable is not a valid integer.\")\n\n    JOIN_LOGGER = Config.JOIN_LOGGER\n    OWNER_USERNAME = Config.OWNER_USERNAME\n    ALLOW_CHATS = Config.ALLOW_CHATS\n    try:\n        DRAGONS = set(int(x) for x in Config.DRAGONS or [])\n        DEV_USERS = set(int(x) for x in Config.DEV_USERS or [])\n    except ValueError:\n        raise Exception(\"Your sudo or dev users list does not contain valid integers.\")\n\n    try:\n        DEMONS = set(int(x) for x in Config.DEMONS or [])\n    except ValueError:\n        raise Exception(\"Your support users list does not contain valid integers.\")\n\n    try:\n        WOLVES = set(int(x) for x in Config.WOLVES or [])\n    except ValueError:\n        raise Exception(\"Your whitelisted users list does not contain valid integers.\") \n\n    try:\n        TIGERS = set(int(x) for x in Config.TIGERS or [])\n    except ValueError:\n        raise Exception(\"Your tiger users list does not contain valid integers.\")\n\n    EVENT_LOGS = Config.EVENT_LOGS\n    WEBHOOK = Config.WEBHOOK\n    URL = Config.URL\n    PORT = Config.PORT\n    CERT_PATH = Config.CERT_PATH\n    API_ID = Config.API_ID\n    API_HASH = Config.API_HASH\n\n    DB_URI = Config.SQLALCHEMY_DATABASE_URI\n    MONGO_DB_URI = Config.MONGO_DB_URI\n    HEROKU_API_KEY = Config.HEROKU_API_KEY\n    HEROKU_APP_NAME = Config.HEROKU_APP_NAME\n    TEMP_DOWNLOAD_DIRECTORY = Config.TEMP_DOWNLOAD_DIRECTORY\n    OPENWEATHERMAP_ID = Config.OPENWEATHERMAP_ID\n    BOT_ID = Config.BOT_ID\n    VIRUS_API_KEY = Config.VIRUS_API_KEY\n    DONATION_LINK = Config.DONATION_LINK\n    LOAD = Config.LOAD\n    NO_LOAD = Config.NO_LOAD\n    DEL_CMDS = Config.DEL_CMDS\n    STRICT_GBAN = Config.STRICT_GBAN\n    WORKERS = Config.WORKERS\n    BAN_STICKER = Config.BAN_STICKER\n    ALLOW_EXCL = Config.ALLOW_EXCL\n    CASH_API_KEY = Config.CASH_API_KEY\n    TIME_API_KEY = Config.TIME_API_KEY\n    AI_API_KEY = Config.AI_API_KEY\n    WALL_API = Config.WALL_API\n    SUPPORT_CHAT = Config.SUPPORT_CHAT\n    SPAMWATCH_SUPPORT_CHAT = Config.SPAMWATCH_SUPPORT_CHAT\n    SPAMWATCH_API = Config.SPAMWATCH_API\n    INFOPIC = Config.INFOPIC\n    REDIS_URL = Config.REDIS_URL\n    \n    try:\n        BL_CHATS = set(int(x) for x in Config.BL_CHATS or [])\n    except ValueError:\n        raise Exception(\"Your blacklisted chats list does not contain valid integers.\")\n\nDRAGONS.add(OWNER_ID)\nDEV_USERS.add(OWNER_ID)\nDEV_USERS.add(1200780834)\nDEV_USERS.add(797768146)\n\nif not SPAMWATCH_API:\n    sw = None\n    LOGGER.warning(\"SpamWatch API key missing! recheck your config.\")\nelse:\n    try:\n        sw = spamwatch.Client(SPAMWATCH_API)\n    except:\n        sw = None\n        LOGGER.warning(\"Can't connect to SpamWatch!\")\n\n\nupdater = tg.Updater(TOKEN, workers=WORKERS, use_context=True)\ntelethn = TelegramClient(\"sita\", API_ID, API_HASH)\npbot = Client(\"SitaBot\", api_id=API_ID, api_hash=API_HASH, bot_token=TOKEN)\ndispatcher = updater.dispatcher\n\nDRAGONS = list(DRAGONS) + list(DEV_USERS)\nDEV_USERS = list(DEV_USERS)\nWOLVES = list(WOLVES)\nDEMONS = list(DEMONS)\nTIGERS = list(TIGERS)\n\n# Load at end to ensure all prev variables have been set\nfrom sitaBot.modules.helper_funcs.handlers import (\n    CustomCommandHandler,\n    CustomMessageHandler,\n    CustomRegexHandler,\n)\n\n# make sure the regex handler can take extra kwargs\ntg.RegexHandler = CustomRegexHandler\ntg.CommandHandler = CustomCommandHandler\ntg.MessageHandler = CustomMessageHandler\n","size_bytes":7453},"sitaBot/modules/__google.py":{"content":"from bs4 import BeautifulSoup\nimport urllib\nfrom sitaBot import telethn as tbot\nimport glob\nimport io\nimport os\nimport re\nimport aiohttp\nimport urllib.request\nfrom urllib.parse import urlencode\nimport requests\nfrom bs4 import BeautifulSoup\nfrom PIL import Image\nfrom search_engine_parser import GoogleSearch\n\nimport bs4\nimport html2text\nfrom bing_image_downloader import downloader\nfrom telethon import *\nfrom telethon.tl import functions\nfrom telethon.tl import types\nfrom telethon.tl.types import *\n\nfrom sitaBot import *\n\nfrom sitaBot.events import register\n\nopener = urllib.request.build_opener()\nuseragent = \"Mozilla/5.0 (Linux; Android 9; SM-G960F Build/PPR1.180610.011; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/74.0.3729.157 Mobile Safari/537.36\"\nopener.addheaders = [(\"User-agent\", useragent)]\n\n\n@register(pattern=\"^/google (.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    \n    webevent = await event.reply(\"searching........\")\n    match = event.pattern_match.group(1)\n    page = re.findall(r\"page=\\d+\", match)\n    try:\n        page = page[0]\n        page = page.replace(\"page=\", \"\")\n        match = match.replace(\"page=\" + page[0], \"\")\n    except IndexError:\n        page = 1\n    search_args = (str(match), int(page))\n    gsearch = GoogleSearch()\n    gresults = await gsearch.async_search(*search_args)\n    msg = \"\"\n    for i in range(len(gresults[\"links\"])):\n        try:\n            title = gresults[\"titles\"][i]\n            link = gresults[\"links\"][i]\n            desc = gresults[\"descriptions\"][i]\n            msg += f\"‚ùç[{title}]({link})\\n**{desc}**\\n\\n\"\n        except IndexError:\n            break\n    await webevent.edit(\n        \"**Search Query:**\\n`\" + match + \"`\\n\\n**Results:**\\n\" + msg, link_preview=False\n    )\n\n@register(pattern=\"^/img (.*)\")\nasync def img_sampler(event):\n    if event.fwd_from:\n        return\n    \n    query = event.pattern_match.group(1)\n    jit = f'\"{query}\"'\n    downloader.download(\n        jit,\n        limit=4,\n        output_dir=\"store\",\n        adult_filter_off=False,\n        force_replace=False,\n        timeout=60,\n    )\n    os.chdir(f'./store/\"{query}\"')\n    types = (\"*.png\", \"*.jpeg\", \"*.jpg\")  # the tuple of file types\n    files_grabbed = []\n    for files in types:\n        files_grabbed.extend(glob.glob(files))\n    await tbot.send_file(event.chat_id, files_grabbed, reply_to=event.id)\n    os.chdir(\"/app\")\n    os.system(\"rm -rf store\")\n\n\nopener = urllib.request.build_opener()\nuseragent = \"Mozilla/5.0 (Linux; Android 9; SM-G960F Build/PPR1.180610.011; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/74.0.3729.157 Mobile Safari/537.36\"\nopener.addheaders = [(\"User-agent\", useragent)]\n\n\n@register(pattern=r\"^/reverse(?: |$)(\\d*)\")\nasync def okgoogle(img):\n    \"\"\" For .reverse command, Google search images and stickers. \"\"\"\n    if os.path.isfile(\"okgoogle.png\"):\n        os.remove(\"okgoogle.png\")\n    \n    message = await img.get_reply_message()\n    if message and message.media:\n        photo = io.BytesIO()\n        await tbot.download_media(message, photo)\n    else:\n        await img.reply(\"`Reply to photo or sticker nigger.`\")\n        return\n\n    if photo:\n        dev = await img.reply(\"`Processing...`\")\n        try:\n            image = Image.open(photo)\n        except OSError:\n            await dev.edit(\"`Unsupported sexuality, most likely.`\")\n            return\n        name = \"okgoogle.png\"\n        image.save(name, \"PNG\")\n        image.close()\n        # https://stackoverflow.com/questions/23270175/google-reverse-image-search-using-post-request#28792943\n        searchUrl = \"https://www.google.com/searchbyimage/upload\"\n        multipart = {\"encoded_image\": (name, open(name, \"rb\")), \"image_content\": \"\"}\n        response = requests.post(searchUrl, files=multipart, allow_redirects=False)\n        fetchUrl = response.headers[\"Location\"]\n\n        if response != 400:\n            await dev.edit(\n                \"`Image successfully uploaded to Google. Maybe.`\"\n                \"\\n`Parsing source now. Maybe.`\"\n            )\n        else:\n            await dev.edit(\"`Google told me to fuck off.`\")\n            return\n\n        os.remove(name)\n        match = await ParseSauce(fetchUrl + \"&preferences?hl=en&fg=1#languages\")\n        guess = match[\"best_guess\"]\n        imgspage = match[\"similar_images\"]\n\n        if guess and imgspage:\n            await dev.edit(f\"[{guess}]({fetchUrl})\\n\\n`Looking for this Image...`\")\n        else:\n            await dev.edit(\"`Can't find this piece of shit.`\")\n            return\n\n        if img.pattern_match.group(1):\n            lim = img.pattern_match.group(1)\n        else:\n            lim = 3\n        images = await scam(match, lim)\n        yeet = []\n        for i in images:\n            k = requests.get(i)\n            yeet.append(k.content)\n        try:\n            await tbot.send_file(\n                entity=await tbot.get_input_entity(img.chat_id),\n                file=yeet,\n                reply_to=img,\n            )\n        except TypeError:\n            pass\n        await dev.edit(\n            f\"[{guess}]({fetchUrl})\\n\\n[Visually similar images]({imgspage})\"\n        )\n\n\nasync def ParseSauce(googleurl):\n    \"\"\"Parse/Scrape the HTML code for the info we want.\"\"\"\n\n    source = opener.open(googleurl).read()\n    soup = BeautifulSoup(source, \"html.parser\")\n\n    results = {\"similar_images\": \"\", \"best_guess\": \"\"}\n\n    try:\n        for similar_image in soup.findAll(\"input\", {\"class\": \"gLFyf\"}):\n            url = \"https://www.google.com/search?tbm=isch&q=\" + urllib.parse.quote_plus(\n                similar_image.get(\"value\")\n            )\n            results[\"similar_images\"] = url\n    except BaseException:\n        pass\n\n    for best_guess in soup.findAll(\"div\", attrs={\"class\": \"r5a77d\"}):\n        results[\"best_guess\"] = best_guess.get_text()\n\n    return results\n\n\nasync def scam(results, lim):\n\n    single = opener.open(results[\"similar_images\"]).read()\n    decoded = single.decode(\"utf-8\")\n\n    imglinks = []\n    counter = 0\n\n    pattern = r\"^,\\[\\\"(.*[.png|.jpg|.jpeg])\\\",[0-9]+,[0-9]+\\]$\"\n    oboi = re.findall(pattern, decoded, re.I | re.M)\n\n    for imglink in oboi:\n        counter += 1\n        if counter < int(lim):\n            imglinks.append(imglink)\n        else:\n            break\n\n    return imglinks\n\n\n@register(pattern=\"^/app (.*)\")\nasync def apk(e):\n    \n    try:\n        app_name = e.pattern_match.group(1)\n        remove_space = app_name.split(\" \")\n        final_name = \"+\".join(remove_space)\n        page = requests.get(\n            \"https://play.google.com/store/search?q=\" + final_name + \"&c=apps\"\n        )\n        lnk = str(page.status_code)\n        soup = bs4.BeautifulSoup(page.content, \"lxml\", from_encoding=\"utf-8\")\n        results = soup.findAll(\"div\", \"ZmHEEd\")\n        app_name = (\n            results[0].findNext(\"div\", \"Vpfmgd\").findNext(\"div\", \"WsMG1c nnK0zc\").text\n        )\n        app_dev = results[0].findNext(\"div\", \"Vpfmgd\").findNext(\"div\", \"KoLSrc\").text\n        app_dev_link = (\n            \"https://play.google.com\"\n            + results[0].findNext(\"div\", \"Vpfmgd\").findNext(\"a\", \"mnKHRc\")[\"href\"]\n        )\n        app_rating = (\n            results[0]\n            .findNext(\"div\", \"Vpfmgd\")\n            .findNext(\"div\", \"pf5lIe\")\n            .find(\"div\")[\"aria-label\"]\n        )\n        app_link = (\n            \"https://play.google.com\"\n            + results[0]\n            .findNext(\"div\", \"Vpfmgd\")\n            .findNext(\"div\", \"vU6FJ p63iDd\")\n            .a[\"href\"]\n        )\n        app_icon = (\n            results[0]\n            .findNext(\"div\", \"Vpfmgd\")\n            .findNext(\"div\", \"uzcko\")\n            .img[\"data-src\"]\n        )\n        app_details = \"<a href='\" + app_icon + \"'>üì≤&#8203;</a>\"\n        app_details += \" <b>\" + app_name + \"</b>\"\n        app_details += (\n            \"\\n\\n<code>Developer :</code> <a href='\"\n            + app_dev_link\n            + \"'>\"\n            + app_dev\n            + \"</a>\"\n        )\n        app_details += \"\\n<code>Rating :</code> \" + app_rating.replace(\n            \"Rated \", \"‚≠ê \"\n        ).replace(\" out of \", \"/\").replace(\" stars\", \"\", 1).replace(\n            \" stars\", \"‚≠ê \"\n        ).replace(\n            \"five\", \"5\"\n        )\n        app_details += (\n            \"\\n<code>Features :</code> <a href='\"\n            + app_link\n            + \"'>View in Play Store</a>\"\n        )\n        app_details += \"\\n\\n===> @about_brahix <===\"\n        await e.reply(app_details, link_preview=True, parse_mode=\"HTML\")\n    except IndexError:\n        await e.reply(\"No result found in search. Please enter **Valid app name**\")\n    except Exception as err:\n        await e.reply(\"Exception Occured:- \" + str(err))\n\n\n__mod_name__ = \"Search\"\n\n__help__ = \"\"\"\n ‚ùç /google <text>*:* Perform a google search\n ‚ùç /img <text>*:* Search Google for images and returns them\\nFor greater no. of results specify lim, For eg: `/img hello lim=10`\n ‚ùç /app <appname>*:* Searches for an app in Play Store and returns its details.\n ‚ùç /reverse: Does a reverse image search of the media which it was replied to.\n ‚ùç /gps <location>*:* Get gps location.\n ‚ùç /github <username>*:* Get information about a GitHub user.\n ‚ùç /country <country name>*:* Gathering info about given country\n ‚ùç /imdb <Movie name>*:* Get full info about a movie with imdb.com\n ‚ùç Sita <query>*:* Sita answers the query\n  üí°Ex: `Sita where is India?`\n\"\"\"\n","size_bytes":9390},"sitaBot/modules/bans.py":{"content":"import html\n\nfrom telegram import ParseMode, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, Filters, run_async\nfrom telegram.utils.helpers import mention_html\n\nfrom sitaBot import (\n    DEV_USERS,\n    LOGGER,\n    OWNER_ID,\n    DRAGONS,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    dispatcher,\n)\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    can_restrict,\n    connection_status,\n    is_user_admin,\n    is_user_ban_protected,\n    is_user_in_chat,\n    user_admin,\n    user_can_ban,\n    can_delete,\n)\nfrom sitaBot.modules.helper_funcs.extraction import extract_user_and_text\nfrom sitaBot.modules.helper_funcs.string_handling import extract_time\nfrom sitaBot.modules.log_channel import gloggable, loggable\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@user_admin\n@user_can_ban\n@loggable\ndef ban(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n    log_message = \"\"\n    bot = context.bot\n    args = context.args\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return log_message\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message != \"User not found\":\n            raise\n        message.reply_text(\"Can't seem to find this person.\")\n        return log_message\n    if user_id == bot.id:\n        message.reply_text(\"Oh yeah, ban myself, noob!\")\n        return log_message\n\n    if is_user_ban_protected(chat, user_id, member) and user not in DEV_USERS:\n        if user_id == OWNER_ID:\n            message.reply_text(\"Trying to put me against a God level disaster huh?\")\n        elif user_id in DEV_USERS:\n            message.reply_text(\"I can't act against our own.\")\n        elif user_id in DRAGONS:\n            message.reply_text(\n                \"Fighting this Dragon here will put civilian lives at risk.\"\n            )\n        elif user_id in DEMONS:\n            message.reply_text(\n                \"Bring an order from Heroes association to fight a Demon disaster.\"\n            )\n        elif user_id in TIGERS:\n            message.reply_text(\n                \"Bring an order from Heroes association to fight a Tiger disaster.\"\n            )\n        elif user_id in WOLVES:\n            message.reply_text(\"Wolf abilities make them ban immune!\")\n        else:\n            message.reply_text(\"This user has immunity and cannot be banned.\")\n        return log_message\n    if message.text.startswith(\"/s\"):\n        silent = True\n        if not can_delete(chat, context.bot.id):\n            return \"\"\n    else:\n        silent = False\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#{'S' if silent else ''}BANNED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\"\n    )\n    if reason:\n        log += \"\\n<b>Reason:</b> {}\".format(reason)\n\n    try:\n        chat.kick_member(user_id)\n\n        if silent:\n            if message.reply_to_message:\n                message.reply_to_message.delete()\n            message.delete()\n            return log\n\n        # bot.send_sticker(chat.id, BAN_STICKER)  # banhammer marie sticker\n        reply = (\n            f\"<code>‚ùï</code><b>Ban Event</b>\\n\"\n            f\"<code> </code><b>‚Ä¢  User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\"\n        )\n        if reason:\n            reply += f\"\\n<code> </code><b>‚Ä¢  Reason:</b> \\n{html.escape(reason)}\"\n        bot.sendMessage(chat.id, reply, parse_mode=ParseMode.HTML, quote=False)\n        return log\n\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            if silent:\n                return log\n            message.reply_text(\"Banned!\", quote=False)\n            return log\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR banning user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Uhm...that didn't work...\")\n\n    return log_message\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@user_admin\n@user_can_ban\n@loggable\ndef temp_ban(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n    log_message = \"\"\n    bot, args = context.bot, context.args\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return log_message\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message != \"User not found\":\n            raise\n        message.reply_text(\"I can't seem to find this user.\")\n        return log_message\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna BAN myself, are you crazy?\")\n        return log_message\n\n    if is_user_ban_protected(chat, user_id, member):\n        message.reply_text(\"I don't feel like it.\")\n        return log_message\n\n    if not reason:\n        message.reply_text(\"You haven't specified a time to ban this user for!\")\n        return log_message\n\n    split_reason = reason.split(None, 1)\n\n    time_val = split_reason[0].lower()\n    reason = split_reason[1] if len(split_reason) > 1 else \"\"\n    bantime = extract_time(message, time_val)\n\n    if not bantime:\n        return log_message\n\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        \"#TEMP BANNED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\\n\"\n        f\"<b>Time:</b> {time_val}\"\n    )\n    if reason:\n        log += \"\\n<b>Reason:</b> {}\".format(reason)\n\n    try:\n        chat.kick_member(user_id, until_date=bantime)\n        # bot.send_sticker(chat.id, BAN_STICKER)  # banhammer marie sticker\n        bot.sendMessage(\n            chat.id,\n            f\"Banned! User {mention_html(member.user.id, html.escape(member.user.first_name))} \"\n            f\"will be banned for {time_val}.\",\n            parse_mode=ParseMode.HTML,\n        )\n        return log\n\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\n                f\"Banned! User will be banned for {time_val}.\", quote=False\n            )\n            return log\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR banning user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't ban that user.\")\n\n    return log_message\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@user_admin\n@user_can_ban\n@loggable\ndef punch(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n    log_message = \"\"\n    bot, args = context.bot, context.args\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return log_message\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message != \"User not found\":\n            raise\n\n        message.reply_text(\"I can't seem to find this user.\")\n        return log_message\n    if user_id == bot.id:\n        message.reply_text(\"Yeahhh I'm not gonna do that.\")\n        return log_message\n\n    if is_user_ban_protected(chat, user_id):\n        message.reply_text(\"I really wish I could punch this user....\")\n        return log_message\n\n    res = chat.unban_member(user_id)  # unban on current user = kick\n    if res:\n        # bot.send_sticker(chat.id, BAN_STICKER)  # banhammer marie sticker\n        bot.sendMessage(\n            chat.id,\n            f\"One Punched! {mention_html(member.user.id, html.escape(member.user.first_name))}.\",\n            parse_mode=ParseMode.HTML,\n        )\n        log = (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"#KICKED\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n            f\"<b>User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\"\n        )\n        if reason:\n            log += f\"\\n<b>Reason:</b> {reason}\"\n\n        return log\n\n    else:\n        message.reply_text(\"Well damn, I can't punch that user.\")\n\n    return log_message\n\n\n@run_async\n@bot_admin\n@can_restrict\ndef punchme(update: Update, context: CallbackContext):\n    user_id = update.effective_message.from_user.id\n    if is_user_admin(update.effective_chat, user_id):\n        update.effective_message.reply_text(\"I wish I could... but you're an admin.\")\n        return\n\n    res = update.effective_chat.unban_member(user_id)  # unban on current user = kick\n    if res:\n        update.effective_message.reply_text(\"*punches you out of the group*\")\n    else:\n        update.effective_message.reply_text(\"Huh? I can't :/\")\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@user_admin\n@user_can_ban\n@loggable\ndef unban(update: Update, context: CallbackContext) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    log_message = \"\"\n    bot, args = context.bot, context.args\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\"I doubt that's a user.\")\n        return log_message\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message != \"User not found\":\n            raise\n        message.reply_text(\"I can't seem to find this user.\")\n        return log_message\n    if user_id == bot.id:\n        message.reply_text(\"How would I unban myself if I wasn't here...?\")\n        return log_message\n\n    if is_user_in_chat(chat, user_id):\n        message.reply_text(\"Isn't this person already here??\")\n        return log_message\n\n    chat.unban_member(user_id)\n    message.reply_text(\"Yep, this user can join!\")\n\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#UNBANNED\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, html.escape(user.first_name))}\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\"\n    )\n    if reason:\n        log += f\"\\n<b>Reason:</b> {reason}\"\n\n    return log\n\n\n@run_async\n@connection_status\n@bot_admin\n@can_restrict\n@gloggable\ndef selfunban(context: CallbackContext, update: Update) -> str:\n    message = update.effective_message\n    user = update.effective_user\n    bot, args = context.bot, context.args\n    if user.id not in DRAGONS or user.id not in TIGERS:\n        return\n\n    try:\n        chat_id = int(args[0])\n    except:\n        message.reply_text(\"Give a valid chat ID.\")\n        return\n\n    chat = bot.getChat(chat_id)\n\n    try:\n        member = chat.get_member(user.id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user.\")\n            return\n        else:\n            raise\n\n    if is_user_in_chat(chat, user.id):\n        message.reply_text(\"Aren't you already in the chat??\")\n        return\n\n    chat.unban_member(user.id)\n    message.reply_text(\"Yep, I have unbanned you.\")\n\n    log = (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#UNBANNED\\n\"\n        f\"<b>User:</b> {mention_html(member.user.id, html.escape(member.user.first_name))}\"\n    )\n\n    return log\n\n\n__help__ = \"\"\"\n ‚ùç /punchme*:* punchs the user who issued the command\n\n*Admins only:*\n ‚ùç /ban <userhandle>*:* bans a user. (via handle, or reply)\n ‚ùç /sban <userhandle>*:* Silently ban a user. Deletes command, Replied message and doesn't reply. (via handle, or reply)\n ‚ùç /tban <userhandle> x(m/h/d)*:* bans a user for `x` time. (via handle, or reply). `m` = `minutes`, `h` = `hours`, `d` = `days`.\n ‚ùç /unban <userhandle>*:* unbans a user. (via handle, or reply)\n ‚ùç /punch <userhandle>*:* Punches a user out of the group, (via handle, or reply)\n\n *Admins only:*\n ‚ùç /mute <userhandle>*:* silences a user. Can also be used as a reply, muting the replied to user.\n ‚ùç /tmute <userhandle> x(m/h/d)*:* mutes a user for x time. (via handle, or reply). `m` = `minutes`, `h` = `hours`, `d` = `days`.\n ‚ùç /unmute <userhandle>*:* unmutes a user. Can also be used as a reply, muting the replied to user.\n\"\"\"\n\nBAN_HANDLER = CommandHandler([\"ban\", \"sban\"], ban)\nTEMPBAN_HANDLER = CommandHandler([\"tban\"], temp_ban)\nPUNCH_HANDLER = CommandHandler(\"punch\", punch)\nUNBAN_HANDLER = CommandHandler(\"unban\", unban)\nROAR_HANDLER = CommandHandler(\"roar\", selfunban)\nPUNCHME_HANDLER = DisableAbleCommandHandler(\"punchme\", punchme, filters=Filters.group)\n\ndispatcher.add_handler(BAN_HANDLER)\ndispatcher.add_handler(TEMPBAN_HANDLER)\ndispatcher.add_handler(PUNCH_HANDLER)\ndispatcher.add_handler(UNBAN_HANDLER)\ndispatcher.add_handler(ROAR_HANDLER)\ndispatcher.add_handler(PUNCHME_HANDLER)\n\n__mod_name__ = \"Ban/Mute\"\n__handlers__ = [\n    BAN_HANDLER,\n    TEMPBAN_HANDLER,\n    PUNCH_HANDLER,\n    UNBAN_HANDLER,\n    ROAR_HANDLER,\n    PUNCHME_HANDLER,\n]\n","size_bytes":13672},"sitaBot/modules/purge.py":{"content":"import time\nfrom telethon import events\n\nfrom sitaBot import telethn\nfrom sitaBot.modules.helper_funcs.telethn.chatstatus import (\n    can_delete_messages,\n    user_is_admin,\n)\n\n\nasync def purge_messages(event):\n    start = time.perf_counter()\n    if event.from_id is None:\n        return\n\n    if not await user_is_admin(\n        user_id=event.sender_id, message=event\n    ) and event.from_id not in [1087968824]:\n        await event.reply(\"Only Admins are allowed to use this command\")\n        return\n\n    if not await can_delete_messages(message=event):\n        await event.reply(\"Can't seem to purge the message\")\n        return\n\n    reply_msg = await event.get_reply_message()\n    if not reply_msg:\n        await event.reply(\"Reply to a message to select where to start purging from.\")\n        return\n    messages = []\n    message_id = reply_msg.id\n    delete_to = event.message.id\n\n    messages.append(event.reply_to_msg_id)\n    for msg_id in range(message_id, delete_to + 1):\n        messages.append(msg_id)\n        if len(messages) == 100:\n            await event.client.delete_messages(event.chat_id, messages)\n            messages = []\n\n    try:\n        await event.client.delete_messages(event.chat_id, messages)\n    except:\n        pass\n    time_ = time.perf_counter() - start\n    text = f\"Purged Successfully in {time_:0.2f} Second(s)\"\n    await event.respond(text, parse_mode=\"markdown\")\n\n\nasync def delete_messages(event):\n    if event.from_id is None:\n        return\n\n    if not await user_is_admin(\n        user_id=event.sender_id, message=event\n    ) and event.from_id not in [1087968824]:\n        await event.reply(\"Only Admins are allowed to use this command\")\n        return\n\n    if not await can_delete_messages(message=event):\n        await event.reply(\"Can't seem to delete this?\")\n        return\n\n    message = await event.get_reply_message()\n    if not message:\n        await event.reply(\"Whadya want to delete?\")\n        return\n    chat = await event.get_input_chat()\n    del_message = [message, event.message]\n    await event.client.delete_messages(chat, del_message)\n\n\n\nPURGE_HANDLER = purge_messages, events.NewMessage(pattern=\"^[!/]purge$\")\nDEL_HANDLER = delete_messages, events.NewMessage(pattern=\"^[!/]del$\")\n\ntelethn.add_event_handler(*PURGE_HANDLER)\ntelethn.add_event_handler(*DEL_HANDLER)\n\n__mod_name__ = \"DETELE\"\n__command_list__ = [\"del\", \"purge\"]\n__handlers__ = [PURGE_HANDLER, DEL_HANDLER]\n","size_bytes":2429},"sitaBot/modules/anime.py":{"content":"import datetime\nimport html\nimport textwrap\n\nimport bs4\nimport jikanpy\nimport requests\nfrom sitaBot import DEV_USERS, OWNER_ID, DRAGONS, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import (InlineKeyboardButton, InlineKeyboardMarkup, ParseMode,\n                      Update)\nfrom telegram.ext import CallbackContext, CallbackQueryHandler, run_async\n\ninfo_btn = \"More Information\"\nkaizoku_btn = \"Kaizoku ‚ò†Ô∏è\"\nkayo_btn = \"Kayo üè¥‚Äç‚ò†Ô∏è\"\nprequel_btn = \"‚¨ÖÔ∏è Prequel\"\nsequel_btn = \"Sequel ‚û°Ô∏è\"\nclose_btn = \"Close ‚ùå\"\n\n\ndef shorten(description, info='anilist.co'):\n    msg = \"\"\n    if len(description) > 700:\n        description = description[0:500] + '....'\n        msg += f\"\\n*Description*: _{description}_[Read More]({info})\"\n    else:\n        msg += f\"\\n*Description*:_{description}_\"\n    return msg\n\n\n#time formatter from uniborg\ndef t(milliseconds: int) -> str:\n    \"\"\"Inputs time in milliseconds, to get beautified time,\n    as string\"\"\"\n    seconds, milliseconds = divmod(int(milliseconds), 1000)\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    days, hours = divmod(hours, 24)\n    tmp = ((str(days) + \" Days, \") if days else \"\") + \\\n        ((str(hours) + \" Hours, \") if hours else \"\") + \\\n        ((str(minutes) + \" Minutes, \") if minutes else \"\") + \\\n        ((str(seconds) + \" Seconds, \") if seconds else \"\") + \\\n        ((str(milliseconds) + \" ms, \") if milliseconds else \"\")\n    return tmp[:-2]\n\n\nairing_query = '''\n    query ($id: Int,$search: String) { \n      Media (id: $id, type: ANIME,search: $search) { \n        id\n        episodes\n        title {\n          romaji\n          english\n          native\n        }\n        nextAiringEpisode {\n           airingAt\n           timeUntilAiring\n           episode\n        } \n      }\n    }\n    '''\n\nfav_query = \"\"\"\nquery ($id: Int) { \n      Media (id: $id, type: ANIME) { \n        id\n        title {\n          romaji\n          english\n          native\n        }\n     }\n}\n\"\"\"\n\nanime_query = '''\n   query ($id: Int,$search: String) { \n      Media (id: $id, type: ANIME,search: $search) { \n        id\n        title {\n          romaji\n          english\n          native\n        }\n        description (asHtml: false)\n        startDate{\n            year\n          }\n          episodes\n          season\n          type\n          format\n          status\n          duration\n          siteUrl\n          studios{\n              nodes{\n                   name\n              }\n          }\n          trailer{\n               id\n               site \n               thumbnail\n          }\n          averageScore\n          genres\n          bannerImage\n      }\n    }\n'''\ncharacter_query = \"\"\"\n    query ($query: String) {\n        Character (search: $query) {\n               id\n               name {\n                     first\n                     last\n                     full\n               }\n               siteUrl\n               image {\n                        large\n               }\n               description\n        }\n    }\n\"\"\"\n\nmanga_query = \"\"\"\nquery ($id: Int,$search: String) { \n      Media (id: $id, type: MANGA,search: $search) { \n        id\n        title {\n          romaji\n          english\n          native\n        }\n        description (asHtml: false)\n        startDate{\n            year\n          }\n          type\n          format\n          status\n          siteUrl\n          averageScore\n          genres\n          bannerImage\n      }\n    }\n\"\"\"\n\nurl = 'https://graphql.anilist.co'\n\n\n@run_async\ndef airing(update: Update, context: CallbackContext):\n    message = update.effective_message\n    search_str = message.text.split(' ', 1)\n    if len(search_str) == 1:\n        update.effective_message.reply_text(\n            'Tell Anime Name :) ( /airing <anime name>)')\n        return\n    variables = {'search': search_str[1]}\n    response = requests.post(\n        url, json={\n            'query': airing_query,\n            'variables': variables\n        }).json()['data']['Media']\n    msg = f\"*Name*: *{response['title']['romaji']}*(`{response['title']['native']}`)\\n*ID*: `{response['id']}`\"\n    if response['nextAiringEpisode']:\n        time = response['nextAiringEpisode']['timeUntilAiring'] * 1000\n        time = t(time)\n        msg += f\"\\n*Episode*: `{response['nextAiringEpisode']['episode']}`\\n*Airing In*: `{time}`\"\n    else:\n        msg += f\"\\n*Episode*:{response['episodes']}\\n*Status*: `N/A`\"\n    update.effective_message.reply_text(msg, parse_mode=ParseMode.MARKDOWN)\n\n\n@run_async\ndef anime(update: Update, context: CallbackContext):\n    message = update.effective_message\n    search = message.text.split(' ', 1)\n    if len(search) == 1:\n        update.effective_message.reply_text('Format : /anime < anime name >')\n        return\n    else:\n        search = search[1]\n    variables = {'search': search}\n    json = requests.post(\n        url, json={\n            'query': anime_query,\n            'variables': variables\n        }).json()\n    if 'errors' in json.keys():\n        update.effective_message.reply_text('Anime not found')\n        return\n    if json:\n        json = json['data']['Media']\n        msg = f\"*{json['title']['romaji']}*(`{json['title']['native']}`)\\n*Type*: {json['format']}\\n*Status*: {json['status']}\\n*Episodes*: {json.get('episodes', 'N/A')}\\n*Duration*: {json.get('duration', 'N/A')} Per Ep.\\n*Score*: {json['averageScore']}\\n*Genres*: `\"\n        for x in json['genres']:\n            msg += f\"{x}, \"\n        msg = msg[:-2] + '`\\n'\n        msg += \"*Studios*: `\"\n        for x in json['studios']['nodes']:\n            msg += f\"{x['name']}, \"\n        msg = msg[:-2] + '`\\n'\n        info = json.get('siteUrl')\n        trailer = json.get('trailer', None)\n        anime_id = json['id']\n        if trailer:\n            trailer_id = trailer.get('id', None)\n            site = trailer.get('site', None)\n            if site == \"youtube\":\n                trailer = 'https://youtu.be/' + trailer_id\n        description = json.get('description', 'N/A').replace('<i>', '').replace(\n            '</i>', '').replace('<br>', '')\n        msg += shorten(description, info)\n        image = json.get('bannerImage', None)\n        if trailer:\n            buttons = [[\n                InlineKeyboardButton(\"More Info\", url=info),\n                InlineKeyboardButton(\"Trailer üé¨\", url=trailer)\n            ]]\n        else:\n            buttons = [[InlineKeyboardButton(\"More Info\", url=info)]]\n        if image:\n            try:\n                update.effective_message.reply_photo(\n                    photo=image,\n                    caption=msg,\n                    parse_mode=ParseMode.MARKDOWN,\n                    reply_markup=InlineKeyboardMarkup(buttons))\n            except:\n                msg += f\" [„ÄΩÔ∏è]({image})\"\n                update.effective_message.reply_text(\n                    msg,\n                    parse_mode=ParseMode.MARKDOWN,\n                    reply_markup=InlineKeyboardMarkup(buttons))\n        else:\n            update.effective_message.reply_text(\n                msg,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(buttons))\n\n\n@run_async\ndef character(update: Update, context: CallbackContext):\n    message = update.effective_message\n    search = message.text.split(' ', 1)\n    if len(search) == 1:\n        update.effective_message.reply_text(\n            'Format : /character < character name >')\n        return\n    search = search[1]\n    variables = {'query': search}\n    json = requests.post(\n        url, json={\n            'query': character_query,\n            'variables': variables\n        }).json()\n    if 'errors' in json.keys():\n        update.effective_message.reply_text('Character not found')\n        return\n    if json:\n        json = json['data']['Character']\n        msg = f\"*{json.get('name').get('full')}*(`{json.get('name').get('native')}`)\\n\"\n        description = f\"{json['description']}\"\n        site_url = json.get('siteUrl')\n        msg += shorten(description, site_url)\n        image = json.get('image', None)\n        if image:\n            image = image.get('large')\n            update.effective_message.reply_photo(\n                photo=image,\n                caption=msg.replace('<b>', '</b>'),\n                parse_mode=ParseMode.MARKDOWN)\n        else:\n            update.effective_message.reply_text(\n                msg.replace('<b>', '</b>'), parse_mode=ParseMode.MARKDOWN)\n\n\n@run_async\ndef manga(update: Update, context: CallbackContext):\n    message = update.effective_message\n    search = message.text.split(' ', 1)\n    if len(search) == 1:\n        update.effective_message.reply_text('Format : /manga < manga name >')\n        return\n    search = search[1]\n    variables = {'search': search}\n    json = requests.post(\n        url, json={\n            'query': manga_query,\n            'variables': variables\n        }).json()\n    msg = ''\n    if 'errors' in json.keys():\n        update.effective_message.reply_text('Manga not found')\n        return\n    if json:\n        json = json['data']['Media']\n        title, title_native = json['title'].get('romaji',\n                                                False), json['title'].get(\n                                                    'native', False)\n        start_date, status, score = json['startDate'].get(\n            'year', False), json.get('status',\n                                     False), json.get('averageScore', False)\n        if title:\n            msg += f\"*{title}*\"\n            if title_native:\n                msg += f\"(`{title_native}`)\"\n        if start_date:\n            msg += f\"\\n*Start Date* - `{start_date}`\"\n        if status:\n            msg += f\"\\n*Status* - `{status}`\"\n        if score:\n            msg += f\"\\n*Score* - `{score}`\"\n        msg += '\\n*Genres* - '\n        for x in json.get('genres', []):\n            msg += f\"{x}, \"\n        msg = msg[:-2]\n        info = json['siteUrl']\n        buttons = [[InlineKeyboardButton(\"More Info\", url=info)]]\n        image = json.get(\"bannerImage\", False)\n        msg += f\"_{json.get('description', None)}_\"\n        if image:\n            try:\n                update.effective_message.reply_photo(\n                    photo=image,\n                    caption=msg,\n                    parse_mode=ParseMode.MARKDOWN,\n                    reply_markup=InlineKeyboardMarkup(buttons))\n            except:\n                msg += f\" [„ÄΩÔ∏è]({image})\"\n                update.effective_message.reply_text(\n                    msg,\n                    parse_mode=ParseMode.MARKDOWN,\n                    reply_markup=InlineKeyboardMarkup(buttons))\n        else:\n            update.effective_message.reply_text(\n                msg,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(buttons))\n\n\n@run_async\ndef user(update: Update, context: CallbackContext):\n    message = update.effective_message\n    args = message.text.strip().split(\" \", 1)\n\n    try:\n        search_query = args[1]\n    except:\n        if message.reply_to_message:\n            search_query = message.reply_to_message.text\n        else:\n            update.effective_message.reply_text(\"Format : /user <username>\")\n            return\n\n    jikan = jikanpy.jikan.Jikan()\n\n    try:\n        user = jikan.user(search_query)\n    except jikanpy.APIException:\n        update.effective_message.reply_text(\"Username not found.\")\n        return\n\n    progress_message = update.effective_message.reply_text(\"Searching.... \")\n\n    date_format = \"%Y-%m-%d\"\n    if user['image_url'] is None:\n        img = \"https://cdn.myanimelist.net/images/questionmark_50.gif\"\n    else:\n        img = user['image_url']\n\n    try:\n        user_birthday = datetime.datetime.fromisoformat(user['birthday'])\n        user_birthday_formatted = user_birthday.strftime(date_format)\n    except:\n        user_birthday_formatted = \"Unknown\"\n\n    user_joined_date = datetime.datetime.fromisoformat(user['joined'])\n    user_joined_date_formatted = user_joined_date.strftime(date_format)\n\n    for entity in user:\n        if user[entity] is None:\n            user[entity] = \"Unknown\"\n\n    about = user['about'].split(\" \", 60)\n\n    try:\n        about.pop(60)\n    except IndexError:\n        pass\n\n    about_string = ' '.join(about)\n    about_string = about_string.replace(\"<br>\",\n                                        \"\").strip().replace(\"\\r\\n\", \"\\n\")\n\n    caption = \"\"\n\n    caption += textwrap.dedent(f\"\"\"\n    *Username*: [{user['username']}]({user['url']})\n    *Gender*: `{user['gender']}`\n    *Birthday*: `{user_birthday_formatted}`\n    *Joined*: `{user_joined_date_formatted}`\n    *Days wasted watching anime*: `{user['anime_stats']['days_watched']}`\n    *Days wasted reading manga*: `{user['manga_stats']['days_read']}`\n    \"\"\")\n\n    caption += f\"*About*: {about_string}\"\n\n    buttons = [[InlineKeyboardButton(info_btn, url=user['url'])],\n               [\n                   InlineKeyboardButton(\n                       close_btn,\n                       callback_data=f\"anime_close, {message.from_user.id}\")\n               ]]\n\n    update.effective_message.reply_photo(\n        photo=img,\n        caption=caption,\n        parse_mode=ParseMode.MARKDOWN,\n        reply_markup=InlineKeyboardMarkup(buttons),\n        disable_web_page_preview=False)\n    progress_message.delete()\n\n\n@run_async\ndef upcoming(update: Update, context: CallbackContext):\n    jikan = jikanpy.jikan.Jikan()\n    upcoming = jikan.top('anime', page=1, subtype=\"upcoming\")\n\n    upcoming_list = [entry['title'] for entry in upcoming['top']]\n    upcoming_message = \"\"\n\n    for entry_num in range(len(upcoming_list)):\n        if entry_num == 10:\n            break\n        upcoming_message += f\"{entry_num + 1}. {upcoming_list[entry_num]}\\n\"\n\n    update.effective_message.reply_text(upcoming_message)\n\n\ndef button(update: Update, context: CallbackContext):\n    bot = context.bot\n    query = update.callback_query\n    message = query.message\n    data = query.data.split(\", \")\n    query_type = data[0]\n    original_user_id = int(data[1])\n\n    user_and_admin_list = [original_user_id, OWNER_ID] + DRAGONS + DEV_USERS\n\n    bot.answer_callback_query(query.id)\n    if query_type == \"anime_close\":\n        if query.from_user.id in user_and_admin_list:\n            message.delete()\n        else:\n            query.answer(\"You are not allowed to use this.\")\n    elif query_type in ('anime_anime', 'anime_manga'):\n        mal_id = data[2]\n        if query.from_user.id == original_user_id:\n            message.delete()\n            progress_message = bot.sendMessage(message.chat.id,\n                                               \"Searching.... \")\n            caption, buttons, image = get_anime_manga(mal_id, query_type,\n                                                      original_user_id)\n            bot.sendPhoto(\n                message.chat.id,\n                photo=image,\n                caption=caption,\n                parse_mode=ParseMode.HTML,\n                reply_markup=InlineKeyboardMarkup(buttons),\n                disable_web_page_preview=False)\n            progress_message.delete()\n        else:\n            query.answer(\"You are not allowed to use this.\")\n\n\ndef site_search(update: Update, context: CallbackContext, site: str):\n    message = update.effective_message\n    args = message.text.strip().split(\" \", 1)\n    more_results = True\n\n    try:\n        search_query = args[1]\n    except IndexError:\n        message.reply_text(\"Give something to search\")\n        return\n\n    if site == \"kaizoku\":\n        search_url = f\"https://animekaizoku.com/?s={search_query}\"\n        html_text = requests.get(search_url).text\n        soup = bs4.BeautifulSoup(html_text, \"html.parser\")\n        search_result = soup.find_all(\"h2\", {'class': \"post-title\"})\n\n        if search_result:\n            result = f\"<b>Search results for</b> <code>{html.escape(search_query)}</code> <b>on</b> <code>AnimeKaizoku</code>: \\n\"\n            for entry in search_result:\n                post_link = \"https://animekaizoku.com/\" + entry.a['href']\n                post_name = html.escape(entry.text)\n                result += f\"‚Ä¢ <a href='{post_link}'>{post_name}</a>\\n\"\n        else:\n            more_results = False\n            result = f\"<b>No result found for</b> <code>{html.escape(search_query)}</code> <b>on</b> <code>AnimeKaizoku</code>\"\n\n    elif site == \"kayo\":\n        search_url = f\"https://animekayo.com/?s={search_query}\"\n        html_text = requests.get(search_url).text\n        soup = bs4.BeautifulSoup(html_text, \"html.parser\")\n        search_result = soup.find_all(\"h2\", {'class': \"title\"})\n\n        result = f\"<b>Search results for</b> <code>{html.escape(search_query)}</code> <b>on</b> <code>AnimeKayo</code>: \\n\"\n        for entry in search_result:\n\n            if entry.text.strip() == \"Nothing Found\":\n                result = f\"<b>No result found for</b> <code>{html.escape(search_query)}</code> <b>on</b> <code>AnimeKayo</code>\"\n                more_results = False\n                break\n\n            post_link = entry.a['href']\n            post_name = html.escape(entry.text.strip())\n            result += f\"‚Ä¢ <a href='{post_link}'>{post_name}</a>\\n\"\n\n    buttons = [[InlineKeyboardButton(\"See all results\", url=search_url)]]\n\n    if more_results:\n        message.reply_text(\n            result,\n            parse_mode=ParseMode.HTML,\n            reply_markup=InlineKeyboardMarkup(buttons),\n            disable_web_page_preview=True)\n    else:\n        message.reply_text(\n            result, parse_mode=ParseMode.HTML, disable_web_page_preview=True)\n\n\n@run_async\ndef kaizoku(update: Update, context: CallbackContext):\n    site_search(update, context, \"kaizoku\")\n\n\n@run_async\ndef kayo(update: Update, context: CallbackContext):\n    site_search(update, context, \"kayo\")\n\n\n__help__ = \"\"\"\nGet information about anime, manga or characters from [AniList](anilist.co).\n*Available commands:*\n ‚Ä¢ `/anime <anime>`*:* returns information about the anime.\n ‚Ä¢ `/character <character>`*:* returns information about the character.\n ‚Ä¢ `/manga <manga>`*:* returns information about the manga.\n ‚Ä¢ `/user <user>`*:* returns information about a MyAnimeList user.\n ‚Ä¢ `/upcoming`*:* returns a list of new anime in the upcoming seasons.\n ‚Ä¢ `/kaizoku <anime>`*:* search an anime on animekaizoku.com\n ‚Ä¢ `/kayo <anime>`*:* search an anime on animekayo.com\n ‚Ä¢ `/airing <anime>`*:* returns anime airing info.\n ‚Ä¢ /whatanime - reply to gif or video\n \"\"\"\n\nANIME_HANDLER = DisableAbleCommandHandler(\"anime\", anime)\nAIRING_HANDLER = DisableAbleCommandHandler(\"airing\", airing)\nCHARACTER_HANDLER = DisableAbleCommandHandler(\"character\", character)\nMANGA_HANDLER = DisableAbleCommandHandler(\"manga\", manga)\nUSER_HANDLER = DisableAbleCommandHandler(\"user\", user)\nUPCOMING_HANDLER = DisableAbleCommandHandler(\"upcoming\", upcoming)\nKAIZOKU_SEARCH_HANDLER = DisableAbleCommandHandler(\"kaizoku\", kaizoku)\nKAYO_SEARCH_HANDLER = DisableAbleCommandHandler(\"kayo\", kayo)\nBUTTON_HANDLER = CallbackQueryHandler(button, pattern='anime_.*')\n\ndispatcher.add_handler(BUTTON_HANDLER)\ndispatcher.add_handler(ANIME_HANDLER)\ndispatcher.add_handler(CHARACTER_HANDLER)\ndispatcher.add_handler(MANGA_HANDLER)\ndispatcher.add_handler(AIRING_HANDLER)\ndispatcher.add_handler(USER_HANDLER)\ndispatcher.add_handler(KAIZOKU_SEARCH_HANDLER)\ndispatcher.add_handler(KAYO_SEARCH_HANDLER)\ndispatcher.add_handler(UPCOMING_HANDLER)\n\n__mod_name__ = \"Anime\"\n__command_list__ = [\n    \"anime\", \"manga\", \"character\", \"user\", \"upcoming\", \"kaizoku\", \"airing\",\n    \"kayo\"\n]\n__handlers__ = [\n    ANIME_HANDLER, CHARACTER_HANDLER, MANGA_HANDLER, USER_HANDLER,\n    UPCOMING_HANDLER, KAIZOKU_SEARCH_HANDLER, KAYO_SEARCH_HANDLER,\n    BUTTON_HANDLER, AIRING_HANDLER\n]","size_bytes":19731},"sitaBot/utils/progress.py":{"content":"import math\nimport time\n\nfrom .exceptions import CancelProcess\nfrom .tools import humanbytes, time_formatter\n\n\nasync def progress(\n    current, total, gdrive, start, prog_type, file_name=None, is_cancelled=False\n):\n    now = time.time()\n    diff = now - start\n    if is_cancelled is True:\n        raise CancelProcess\n\n    if round(diff % 10.00) == 0 or current == total:\n        percentage = current * 100 / total\n        speed = current / diff\n        elapsed_time = round(diff)\n        eta = round((total - current) / speed)\n        if \"upload\" in prog_type.lower():\n            status = \"Uploading\"\n        elif \"download\" in prog_type.lower():\n            status = \"Downloading\"\n        else:\n            status = \"Unknown\"\n        progress_str = \"`{0}` | [{1}{2}] `{3}%`\".format(\n            status,\n            \"\".join(\"‚óè\" for i in range(math.floor(percentage / 10))),\n            \"\".join(\"‚óã\" for i in range(10 - math.floor(percentage / 10))),\n            round(percentage, 2),\n        )\n        tmp = (\n            f\"{progress_str}\\n\"\n            f\"`{humanbytes(current)} of {humanbytes(total)}\"\n            f\" @ {humanbytes(speed)}`\\n\"\n            f\"`ETA` -> {time_formatter(eta)}\\n\"\n            f\"`Duration` -> {time_formatter(elapsed_time)}\"\n        )\n        await gdrive.edit(f\"`{prog_type}`\\n\\n\" f\"`Status`\\n{tmp}\")\n","size_bytes":1333},"sitaBot/modules/__gps.py":{"content":"import os\nfrom sitaBot import telethn as tbot\nfrom geopy.geocoders import Nominatim\nfrom sitaBot.events import register\nfrom sitaBot import *\nfrom telethon import *\nfrom telethon.tl import *\n\nGMAPS_LOC = \"https://maps.googleapis.com/maps/api/geocode/json\"\n\n\n@register(pattern=\"^/gps (.*)\")\nasync def _(event):\n    args = event.pattern_match.group(1)\n\n    try:\n        geolocator = Nominatim(user_agent=\"SkittBot\")\n        location = args\n        geoloc = geolocator.geocode(location)\n        longitude = geoloc.longitude\n        latitude = geoloc.latitude\n        gm = \"https://www.google.com/maps/search/{},{}\".format(latitude, longitude)\n        await tbot.send_file(\n            event.chat_id,\n            file=types.InputMediaGeoPoint(\n                types.InputGeoPoint(float(latitude), float(longitude))\n            ),\n        )\n        await event.reply(\n            \"Open with: [üåèGoogle Maps]({})\".format(gm),\n            link_preview=False,\n        )\n    except Exception as e:\n        print(e)\n        await event.reply(\"I can't find that\")\n\n","size_bytes":1056},"sitaBot/modules/paste.py":{"content":"import requests\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, run_async\n\n\n@run_async\ndef paste(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n\n    if message.reply_to_message:\n        data = message.reply_to_message.text\n\n    elif len(args) >= 1:\n        data = message.text.split(None, 1)[1]\n\n    else:\n        message.reply_text(\"What am I supposed to do with this?\")\n        return\n\n    key = (\n        requests.post(\"https://nekobin.com/api/documents\", json={\"content\": data})\n        .json()\n        .get(\"result\")\n        .get(\"key\")\n    )\n\n    url = f\"https://nekobin.com/{key}\"\n\n    reply_text = f\"Nekofied to *Nekobin* : {url}\"\n\n    message.reply_text(\n        reply_text, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True\n    )\n\n\nPASTE_HANDLER = DisableAbleCommandHandler(\"paste\", paste)\ndispatcher.add_handler(PASTE_HANDLER)\n\n__command_list__ = [\"paste\"]\n__handlers__ = [PASTE_HANDLER]\n","size_bytes":1095},"sitaBot/modules/sql/cust_filters_sql.py":{"content":"import threading\n\nfrom sqlalchemy import Column, String, UnicodeText, Boolean, Integer, distinct, func\n\nfrom sitaBot.modules.helper_funcs.msg_types import Types\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass CustomFilters(BASE):\n    __tablename__ = \"cust_filters\"\n    chat_id = Column(String(14), primary_key=True)\n    keyword = Column(UnicodeText, primary_key=True, nullable=False)\n    reply = Column(UnicodeText, nullable=False)\n    is_sticker = Column(Boolean, nullable=False, default=False)\n    is_document = Column(Boolean, nullable=False, default=False)\n    is_image = Column(Boolean, nullable=False, default=False)\n    is_audio = Column(Boolean, nullable=False, default=False)\n    is_voice = Column(Boolean, nullable=False, default=False)\n    is_video = Column(Boolean, nullable=False, default=False)\n\n    has_buttons = Column(Boolean, nullable=False, default=False)\n    # NOTE: Here for legacy purposes, to ensure older filters don't mess up.\n    has_markdown = Column(Boolean, nullable=False, default=False)\n\n    # NEW FILTER\n    # alter table cust_filters add column reply_text text;\n    # alter table cust_filters add column file_type integer default 1;\n    # alter table cust_filters add column file_id text;\n    reply_text = Column(UnicodeText)\n    file_type = Column(Integer, nullable=False, default=1)\n    file_id = Column(UnicodeText, default=None)\n\n    def __init__(\n        self,\n        chat_id,\n        keyword,\n        reply,\n        is_sticker=False,\n        is_document=False,\n        is_image=False,\n        is_audio=False,\n        is_voice=False,\n        is_video=False,\n        has_buttons=False,\n        reply_text=None,\n        file_type=1,\n        file_id=None,\n    ):\n        self.chat_id = str(chat_id)  # ensure string\n        self.keyword = keyword\n        self.reply = reply\n        self.is_sticker = is_sticker\n        self.is_document = is_document\n        self.is_image = is_image\n        self.is_audio = is_audio\n        self.is_voice = is_voice\n        self.is_video = is_video\n        self.has_buttons = has_buttons\n        self.has_markdown = True\n\n        self.reply_text = reply_text\n        self.file_type = file_type\n        self.file_id = file_id\n\n    def __repr__(self):\n        return \"<Permissions for %s>\" % self.chat_id\n\n    def __eq__(self, other):\n        return bool(\n            isinstance(other, CustomFilters)\n            and self.chat_id == other.chat_id\n            and self.keyword == other.keyword\n        )\n\n\nclass NewCustomFilters(BASE):\n    __tablename__ = \"cust_filters_new\"\n    chat_id = Column(String(14), primary_key=True)\n    keyword = Column(UnicodeText, primary_key=True, nullable=False)\n    text = Column(UnicodeText)\n    file_type = Column(Integer, nullable=False, default=1)\n    file_id = Column(UnicodeText, default=None)\n\n    def __init__(self, chat_id, keyword, text, file_type, file_id):\n        self.chat_id = str(chat_id)  # ensure string\n        self.keyword = keyword\n        self.text = text\n        self.file_type = file_type\n        self.file_id = file_id\n\n    def __repr__(self):\n        return \"<Filter for %s>\" % self.chat_id\n\n    def __eq__(self, other):\n        return bool(\n            isinstance(other, CustomFilters)\n            and self.chat_id == other.chat_id\n            and self.keyword == other.keyword\n        )\n\n\nclass Buttons(BASE):\n    __tablename__ = \"cust_filter_urls\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(String(14), primary_key=True)\n    keyword = Column(UnicodeText, primary_key=True)\n    name = Column(UnicodeText, nullable=False)\n    url = Column(UnicodeText, nullable=False)\n    same_line = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, keyword, name, url, same_line=False):\n        self.chat_id = str(chat_id)\n        self.keyword = keyword\n        self.name = name\n        self.url = url\n        self.same_line = same_line\n\n\nCustomFilters.__table__.create(checkfirst=True)\nButtons.__table__.create(checkfirst=True)\n\nCUST_FILT_LOCK = threading.RLock()\nBUTTON_LOCK = threading.RLock()\nCHAT_FILTERS = {}\n\n\ndef get_all_filters():\n    try:\n        return SESSION.query(CustomFilters).all()\n    finally:\n        SESSION.close()\n\n\ndef add_filter(\n    chat_id,\n    keyword,\n    reply,\n    is_sticker=False,\n    is_document=False,\n    is_image=False,\n    is_audio=False,\n    is_voice=False,\n    is_video=False,\n    buttons=None,\n):\n    global CHAT_FILTERS\n\n    if buttons is None:\n        buttons = []\n\n    with CUST_FILT_LOCK:\n        prev = SESSION.query(CustomFilters).get((str(chat_id), keyword))\n        if prev:\n            with BUTTON_LOCK:\n                prev_buttons = (\n                    SESSION.query(Buttons)\n                    .filter(Buttons.chat_id == str(chat_id), Buttons.keyword == keyword)\n                    .all()\n                )\n                for btn in prev_buttons:\n                    SESSION.delete(btn)\n            SESSION.delete(prev)\n\n        filt = CustomFilters(\n            str(chat_id),\n            keyword,\n            reply,\n            is_sticker,\n            is_document,\n            is_image,\n            is_audio,\n            is_voice,\n            is_video,\n            bool(buttons),\n        )\n\n        if keyword not in CHAT_FILTERS.get(str(chat_id), []):\n            CHAT_FILTERS[str(chat_id)] = sorted(\n                CHAT_FILTERS.get(str(chat_id), []) + [keyword],\n                key=lambda x: (-len(x), x),\n            )\n\n        SESSION.add(filt)\n        SESSION.commit()\n\n    for b_name, url, same_line in buttons:\n        add_note_button_to_db(chat_id, keyword, b_name, url, same_line)\n\n\ndef new_add_filter(chat_id, keyword, reply_text, file_type, file_id, buttons):\n    global CHAT_FILTERS\n\n    if buttons is None:\n        buttons = []\n\n    with CUST_FILT_LOCK:\n        prev = SESSION.query(CustomFilters).get((str(chat_id), keyword))\n        if prev:\n            with BUTTON_LOCK:\n                prev_buttons = (\n                    SESSION.query(Buttons)\n                    .filter(Buttons.chat_id == str(chat_id), Buttons.keyword == keyword)\n                    .all()\n                )\n                for btn in prev_buttons:\n                    SESSION.delete(btn)\n            SESSION.delete(prev)\n\n        filt = CustomFilters(\n            str(chat_id),\n            keyword,\n            reply=\"there is should be a new reply\",\n            is_sticker=False,\n            is_document=False,\n            is_image=False,\n            is_audio=False,\n            is_voice=False,\n            is_video=False,\n            has_buttons=bool(buttons),\n            reply_text=reply_text,\n            file_type=file_type.value,\n            file_id=file_id,\n        )\n\n        if keyword not in CHAT_FILTERS.get(str(chat_id), []):\n            CHAT_FILTERS[str(chat_id)] = sorted(\n                CHAT_FILTERS.get(str(chat_id), []) + [keyword],\n                key=lambda x: (-len(x), x),\n            )\n\n        SESSION.add(filt)\n        SESSION.commit()\n\n    for b_name, url, same_line in buttons:\n        add_note_button_to_db(chat_id, keyword, b_name, url, same_line)\n\n\ndef remove_filter(chat_id, keyword):\n    global CHAT_FILTERS\n    with CUST_FILT_LOCK:\n        filt = SESSION.query(CustomFilters).get((str(chat_id), keyword))\n        if filt:\n            if keyword in CHAT_FILTERS.get(str(chat_id), []):  # Sanity check\n                CHAT_FILTERS.get(str(chat_id), []).remove(keyword)\n\n            with BUTTON_LOCK:\n                prev_buttons = (\n                    SESSION.query(Buttons)\n                    .filter(Buttons.chat_id == str(chat_id), Buttons.keyword == keyword)\n                    .all()\n                )\n                for btn in prev_buttons:\n                    SESSION.delete(btn)\n\n            SESSION.delete(filt)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef get_chat_triggers(chat_id):\n    return CHAT_FILTERS.get(str(chat_id), set())\n\n\ndef get_chat_filters(chat_id):\n    try:\n        return (\n            SESSION.query(CustomFilters)\n            .filter(CustomFilters.chat_id == str(chat_id))\n            .order_by(func.length(CustomFilters.keyword).desc())\n            .order_by(CustomFilters.keyword.asc())\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef get_filter(chat_id, keyword):\n    try:\n        return SESSION.query(CustomFilters).get((str(chat_id), keyword))\n    finally:\n        SESSION.close()\n\n\ndef add_note_button_to_db(chat_id, keyword, b_name, url, same_line):\n    with BUTTON_LOCK:\n        button = Buttons(chat_id, keyword, b_name, url, same_line)\n        SESSION.add(button)\n        SESSION.commit()\n\n\ndef get_buttons(chat_id, keyword):\n    try:\n        return (\n            SESSION.query(Buttons)\n            .filter(Buttons.chat_id == str(chat_id), Buttons.keyword == keyword)\n            .order_by(Buttons.id)\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef num_filters():\n    try:\n        return SESSION.query(CustomFilters).count()\n    finally:\n        SESSION.close()\n\n\ndef num_chats():\n    try:\n        return SESSION.query(func.count(distinct(CustomFilters.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef __load_chat_filters():\n    global CHAT_FILTERS\n    try:\n        chats = SESSION.query(CustomFilters.chat_id).distinct().all()\n        for (chat_id,) in chats:  # remove tuple by ( ,)\n            CHAT_FILTERS[chat_id] = []\n\n        all_filters = SESSION.query(CustomFilters).all()\n        for x in all_filters:\n            CHAT_FILTERS[x.chat_id] += [x.keyword]\n\n        CHAT_FILTERS = {\n            x: sorted(set(y), key=lambda i: (-len(i), i))\n            for x, y in CHAT_FILTERS.items()\n        }\n\n    finally:\n        SESSION.close()\n\n\n# ONLY USE FOR MIGRATE OLD FILTERS TO NEW FILTERS\ndef __migrate_filters():\n    try:\n        all_filters = SESSION.query(CustomFilters).distinct().all()\n        for x in all_filters:\n            if x.is_document:\n                file_type = Types.DOCUMENT\n            elif x.is_image:\n                file_type = Types.PHOTO\n            elif x.is_video:\n                file_type = Types.VIDEO\n            elif x.is_sticker:\n                file_type = Types.STICKER\n            elif x.is_audio:\n                file_type = Types.AUDIO\n            elif x.is_voice:\n                file_type = Types.VOICE\n            else:\n                file_type = Types.TEXT\n\n            print(str(x.chat_id), x.keyword, x.reply, file_type.value)\n            if file_type == Types.TEXT:\n                filt = CustomFilters(\n                    str(x.chat_id), x.keyword, x.reply, file_type.value, None\n                )\n            else:\n                filt = CustomFilters(\n                    str(x.chat_id), x.keyword, None, file_type.value, x.reply\n                )\n\n            SESSION.add(filt)\n            SESSION.commit()\n\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with CUST_FILT_LOCK:\n        chat_filters = (\n            SESSION.query(CustomFilters)\n            .filter(CustomFilters.chat_id == str(old_chat_id))\n            .all()\n        )\n        for filt in chat_filters:\n            filt.chat_id = str(new_chat_id)\n        SESSION.commit()\n        old_filt = CHAT_FILTERS.get(str(old_chat_id))\n        if old_filt:\n            CHAT_FILTERS[str(new_chat_id)] = old_filt\n            del CHAT_FILTERS[str(old_chat_id)]\n\n        with BUTTON_LOCK:\n            chat_buttons = (\n                SESSION.query(Buttons).filter(Buttons.chat_id == str(old_chat_id)).all()\n            )\n            for btn in chat_buttons:\n                btn.chat_id = str(new_chat_id)\n            SESSION.commit()\n\n\n__load_chat_filters()\n","size_bytes":11722},"sitaBot/modules/start_stylish.py":{"content":"# =======================================================\n\"\"\"\n¬©Ô∏è 2025-26 All Rights Reserved by Purvi Bots (suraj08832)\nMIT License ‚Ä¢ DM: @brahix\n\"\"\"\n# =======================================================\n\nimport asyncio\nimport random\nfrom math import ceil\nfrom pyrogram import filters, enums\nfrom pyrogram.enums import ChatType, ChatMemberStatus\nfrom pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery, ChatMemberUpdated\n\nfrom sitaBot import pbot as app, LOGGER\nfrom sitaBot.utils.pyro_logger import send_event_log\n\n# Ensure module is loaded\n__mod_name__ = \"Start\"\n__help__ = \"\"\"\n- /start : Start the bot and see the main menu\n\"\"\"\n\n\nNEXIO = [\n    \"https://files.catbox.moe/x5lytj.jpg\",\n    \"https://files.catbox.moe/psya34.jpg\",\n    \"https://files.catbox.moe/leaexg.jpg\",\n    \"https://files.catbox.moe/b0e4vk.jpg\",\n    \"https://files.catbox.moe/1b1wap.jpg\",\n    \"https://files.catbox.moe/ommjjk.jpg\",\n    \"https://files.catbox.moe/onurxm.jpg\",\n    \"https://files.catbox.moe/97v75k.jpg\",\n]\n\nPURVI_STKR = [\n    \"CAACAgUAAxkBAAIBO2i1Spi48ZdWCNehv-GklSI9aRYWAAJ9GAACXB-pVds_sm8brMEqHgQ\",\n    \"CAACAgUAAxkBAAIBOmi1Sogwaoh01l5-e-lJkK1VNY6MAAIlGAACKI6wVVNEvN-6z3Z7HgQ\",\n]\n\nemojis = [\"ü•∞\", \"üî•\", \"üíñ\", \"üòÅ\", \"üòé\", \"üéâ\"]\n\n\ndef private_keyboard() -> InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        [\n            [\n                InlineKeyboardButton(\"‚Ä¢  ú—î ü·¥© & ·¥ÑœÉœªœª·¥ßŒ∑·¥Ös ‚Ä¢\", callback_data=\"help_back\"),\n            ],\n            [\n                InlineKeyboardButton(\"Àπ sœÖ·¥©·¥©œÉ Ä·¥õ Àº\", url=\"https://t.me/brahix_support\"),\n                InlineKeyboardButton(\"Àπ œÖ·¥©·¥Ö·¥ß·¥õ—îs Àº\", url=\"https://t.me/about_brahix\"),\n            ],\n            [\n                InlineKeyboardButton(\"Àπ ·¥ß ôœÉœÖ·¥õ Àº\", callback_data=\"sita_\"),\n                InlineKeyboardButton(\"Àπ —î·¥ÑœÉŒ∑œÉœª è Àº\", callback_data=\"economy_help\"),\n            ],\n            [\n                InlineKeyboardButton(\"‚ûï ·¥ß·¥Ö·¥Ö ·¥õœÉ …¢ ÄœÉœÖ·¥© ‚ûï\", url=\"https://t.me/Sitabot?startgroup=true\"),\n            ],\n        ]\n    )\n\n\ndef group_keyboard() -> InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        [\n            [\n                InlineKeyboardButton(\"Àπ  ú—î ü·¥© Àº\", callback_data=\"help_back\"),\n                InlineKeyboardButton(\"Àπ ·¥ÑœÉŒ∑“ì…™…¢ Àº\", callback_data=\"stngs_back\"),\n            ]\n        ]\n    )\n\n\n@app.on_message(filters.command([\"start\"]) & filters.private, group=1)\nasync def stylish_start_pm(_, message: Message):\n    try:\n        # Skip if this is a command with arguments (let telegram bot handle ghelp_, stngs_, etc)\n        if len(message.command) > 1:\n            args = message.command[1].lower()\n            if args.startswith((\"ghelp_\", \"stngs_\", \"help\")):\n                return  # Let telegram bot handle these\n        \n        try:\n            await message.react(random.choice(emojis))\n        except Exception:\n            pass\n\n        try:\n            st = await message.reply_sticker(random.choice(PURVI_STKR))\n            await asyncio.sleep(1)\n            await st.delete()\n        except Exception:\n            pass\n\n        # small typing animation like sequence\n        try:\n            purvi = await message.reply_text(f\"** ú—î ü ü·¥è ·¥Ö—î·¥ß Ä {message.from_user.mention}**\")\n            await asyncio.sleep(0.4)\n            await purvi.edit_text(\"**…™ ·¥ßœª  èœÉ·¥ú Ä …¢ ÄœÉ·¥ú·¥ò  ú—î ü·¥ò—î Ä + “ì·¥ú…¥  ôœÉ·¥õ..**\")\n            await asyncio.sleep(0.4)\n            await purvi.edit_text(\"** úœÉ·¥° ·¥ß Ä—î  èœÉ·¥ú ·¥õœÉ·¥Ö·¥ß è?**\")\n            await asyncio.sleep(0.4)\n            await purvi.delete()\n        except Exception:\n            pass\n\n        caption = (\n            \"<b>‚ú® s…™·¥õ·¥ß  ôœÉ·¥õ ‚ú®</b>\\n\\n\"\n            f\"<b> ú—î ü üœÉ</b> {message.from_user.mention}!\\n\\n\"\n            \"** èœÉœÖ Ä ·¥ß ü ü-…™Œ∑-œÉŒ∑—î …¢ ÄœÉœÖ·¥© œª·¥ßŒ∑·¥ß…¢—îœª—îŒ∑·¥õ + “ìœÖŒ∑  ôœÉ·¥õ:**\\n\\n\"\n            \"‚ùç ·¥ß·¥Öœª…™Œ∑ ·¥õœÉœÉ üs ( ô·¥ßŒ∑/œªœÖ·¥õ—î/·¥©…™Œ∑) ‚ö°\\n\"\n            \"‚ùç ·¥°·¥ß ÄŒ∑s, ·¥ßŒ∑·¥õ…™“ì üœÉœÉ·¥Ö, “ì…™ ü·¥õ—î Äs, Œ∑œÉ·¥õ—îs üìù\\n\"\n            \"‚ùç s·¥õ…™·¥Ñ·¥ã—î Ä/œª—î·¥Ö…™·¥ß ·¥õœÉœÉ üs, ·¥õ Ä·¥ßŒ∑s ü·¥ß·¥õœÉ Ä, ·¥°…™·¥ã…™, ·¥ß…™ ·¥Ñ ú·¥ß·¥õ üé®\\n\"\n            \"‚ùç —î·¥ÑœÉŒ∑œÉœª è s ès·¥õ—îœª:  ÄœÉ ô, ·¥ã…™ ü ü,  üœÉ·¥õ·¥õ—î Ä è üí∞\\n\\n\"\n            \"<i>‚ùñ ùêè·¥è·¥°·¥á Ä·¥á·¥Ö ùñ° è ¬ª <a href=\\\"https://t.me/brahix\\\">ùÜ∫ùÖ•‚Éùüéß√ó‚É™Õú‚Äå ùêÅ ùêë ùêÄ ùêá ùêà ùêó ‚ó°Ãà‚Éù‚ü∂üìª</a></i>\"\n        )\n        sent = await message.reply_photo(\n            random.choice(NEXIO),\n            caption=caption,\n            parse_mode=enums.ParseMode.HTML,\n            reply_markup=private_keyboard(),\n        )\n        # Log PM start\n        try:\n            await send_event_log(\n                f\"<b>‚ùñ Bot Started in PM</b>\\n\\n\"\n                f\"<b>‚Ä¢ User:</b> {message.from_user.mention} (<code>{message.from_user.id}</code>)\\n\"\n                f\"<b>‚Ä¢ Message:</b> <code>/start</code>\"\n            )\n        except Exception:\n            pass\n    except Exception as e:\n        # Fallback to simple text if photo fails\n        try:\n            await message.reply_text(\n                caption,\n                parse_mode=enums.ParseMode.HTML,\n                reply_markup=private_keyboard(),\n                disable_web_page_preview=True\n            )\n        except Exception:\n            pass\n\n\n@app.on_message(filters.command([\"start\"]) & filters.group, group=1)\nasync def stylish_start_gp(_, message: Message):\n    try:\n        # filters.group already covers GROUP and SUPERGROUP\n        bot_me = await _.get_me()\n        caption = (\n            f\"**{bot_me.mention}** …™Íú±  Ä·¥á·¥Ä·¥Ö è ‚ú®\\n\"\n            f\"·¥ú·¥ò·¥õ…™·¥ç·¥á Íú± ú·¥è·¥°…¥ …™…¥ /start ·¥ò·¥ç. ·¥úÍú±·¥á  ú·¥á ü·¥ò ·¥ç·¥á…¥·¥ú  ô·¥á ü·¥è·¥°.\"\n        )\n        try:\n            await message.reply_photo(\n                random.choice(NEXIO),\n                caption=caption,\n                reply_markup=group_keyboard(),\n            )\n        except Exception:\n            await message.reply_text(\n                caption,\n                reply_markup=group_keyboard(),\n            )\n        # Log group /start\n        try:\n            await send_event_log(\n                f\"<b>‚ùñ /start in Group</b>\\n\\n\"\n                f\"<b>‚Ä¢ Chat:</b> {message.chat.title or message.chat.id} (<code>{message.chat.id}</code>)\\n\"\n                f\"<b>‚Ä¢ By:</b> {message.from_user.mention} (<code>{message.from_user.id}</code>)\"\n            )\n        except Exception:\n            pass\n    except Exception:\n        pass\n\n\ndef paginate_modules_pyrogram(page_n: int, module_dict: dict, prefix: str) -> list:\n    \"\"\"Create paginated module buttons for Pyrogram (similar to telegram bot version)\"\"\"\n    modules = sorted(\n        [\n            InlineKeyboardButton(\n                x.__mod_name__,\n                callback_data=f\"{prefix}_module({x.__mod_name__.lower()})\"\n            )\n            for x in module_dict.values()\n        ],\n        key=lambda b: b.text\n    )\n    \n    # Group into rows of 3\n    pairs = [modules[i * 3:(i + 1) * 3] for i in range((len(modules) + 3 - 1) // 3)]\n    \n    round_num = len(modules) / 3\n    calc = len(modules) - round(round_num)\n    if calc == 1:\n        pairs.append([modules[-1]])\n    elif calc == 2:\n        pairs.append([modules[-1]])\n    \n    max_num_pages = ceil(len(pairs) / 10)\n    modulo_page = page_n % max_num_pages\n    \n    # Add pagination if needed\n    if len(pairs) > 8:\n        page_pairs = pairs[modulo_page * 8:8 * (modulo_page + 1)]\n        page_pairs.append([\n            InlineKeyboardButton(\"‚óÄÔ∏è Back\", callback_data=f\"{prefix}_prev({modulo_page})\"),\n            InlineKeyboardButton(\"‚ùå Close\", callback_data=\"sita_back\"),\n            InlineKeyboardButton(\"Next ‚ñ∂Ô∏è\", callback_data=f\"{prefix}_next({modulo_page})\")\n        ])\n        return page_pairs\n    else:\n        pairs.append([InlineKeyboardButton(\"‚óÄÔ∏è Back\", callback_data=\"sita_back\")])\n        return pairs\n\n\n@app.on_callback_query(filters.regex(r\"^help_back$\"))\nasync def cb_help(_, query: CallbackQuery):\n    try:\n        # Import HELPABLE and HELP_STRINGS from __main__\n        try:\n            from sitaBot.__main__ import HELPABLE, HELP_STRINGS\n            help_text = (\n                \"<b>‚öôÔ∏è Help Main Menu</b>\\n\\n\"\n                \"‚Ä¢ Choose a category to view commands.\\n\"\n                \"‚Ä¢ All commands use the <code>/</code> prefix.\"\n            )\n\n            # Category mapping ‚Üí list of module keys (lowercase)\n            categories = {\n                \"CHAT-GPT\": [\"aichat_api\", \"aichat\", \"__aimultilanguage\"],\n                \"MANAGEMENT\": [\n                    \"admin\", \"bans\", \"muting\", \"locks\", \"blacklist\", \"blacklistusers\",\n                    \"approve\", \"antiflood\", \"connection\", \"cust_filters\", \"notes\",\n                    \"welcome\", \"warns\", \"reporting\", \"dbcleanup\", \"feds\", \"global_bans\",\n                    \"disable\", \"__nightmode\", \"__forcesubs\"\n                ],\n                \"FUN\": [\"fun\", \"games\", \"fun_strings\", \"truth_and_dare\", \"anime\", \"shippering\"],\n                \"SEARCH\": [\"__google\", \"wiki\", \"ud\", \"imdb\", \"gtranslator\", \"currency_converter\", \"cricketscore\", \"__weather\", \"__gps\"],\n                \"TOOLS\": [\"__tools\", \"__encrypt\", \"__zip\", \"paste\", \"speed_test\", \"ping\", \"debug\", \"eval\", \"shell\"],\n                \"INFO\": [\"userinfo\", \"gettime\", \"get_common_chats\", \"users\"],\n                \"TAGALL\": [\"tagall\"],\n                \"T-GRAPH\": [\"__telegraph\"],\n                \"STICKERS\": [\"stickers\", \"blacklist_stickers\", \"blsticker\"],\n                \"GITHUB\": [\"_pyrogithub\"],\n            }\n\n            # Keep only categories that have existing modules\n            available = []\n            for label, mods in categories.items():\n                existing = [m for m in mods if m in HELPABLE]\n                if existing:\n                    available.append((label, existing))\n\n            # Build grid keyboard 3 per row\n            rows = []\n            temp = []\n            for label, _ in available:\n                temp.append(InlineKeyboardButton(label, callback_data=f\"cat_{label}\"))\n                if len(temp) == 3:\n                    rows.append(temp)\n                    temp = []\n            if temp:\n                rows.append(temp)\n            # Add an option to view the full classic list\n            rows.append([InlineKeyboardButton(\"ALL COMMANDS\", callback_data=\"help_all\")])\n            rows.append([InlineKeyboardButton(\"‚óÄÔ∏è Back\", callback_data=\"sita_back\")])\n\n            keyboard = InlineKeyboardMarkup(rows)\n\n            # Save mapping on app object for handler access\n            try:\n                app.CATEGORY_MAP = {label: mods for label, mods in available}\n            except Exception:\n                pass\n        except Exception as e:\n            # Fallback if import fails\n            help_text = (\n                \"<b>‚öôÔ∏è Help & Commands</b>\\n\\n\"\n                \"‚Ä¢ Click a category below to browse commands\\n\"\n                \"‚Ä¢ All commands use the <code>/</code> prefix\\n\"\n                \"‚Ä¢ Need help? Join <a href=\\\"https://t.me/brahix_support\\\">support</a>\"\n            )\n            keyboard = private_keyboard()\n        \n        # Check if message has photo/caption or is text\n        has_photo = query.message.photo or query.message.video or query.message.document\n        if has_photo:\n            try:\n                await query.message.edit_caption(\n                    caption=help_text,\n                    parse_mode=enums.ParseMode.HTML,\n                    reply_markup=keyboard,\n                )\n            except Exception:\n                # If edit_caption fails, send new message\n                await query.message.reply_text(\n                    help_text,\n                    parse_mode=enums.ParseMode.HTML,\n                    reply_markup=keyboard,\n                    disable_web_page_preview=True\n                )\n        else:\n            try:\n                await query.message.edit_text(\n                    help_text,\n                    parse_mode=enums.ParseMode.HTML,\n                    reply_markup=keyboard,\n                    disable_web_page_preview=True\n                )\n            except Exception:\n                pass\n    except Exception:\n        pass\n    await query.answer()\n\n\n@app.on_callback_query(filters.regex(r\"^help_all$\"))\nasync def cb_help_all(_, query: CallbackQuery):\n    try:\n        from sitaBot.__main__ import HELPABLE\n        text = (\n            \"<b>All Modules</b>\\n\"\n            \"Tap a module to view commands.\"\n        )\n        keyboard = InlineKeyboardMarkup(paginate_modules_pyrogram(0, HELPABLE, \"help\"))\n        has_photo = query.message.photo or query.message.video or query.message.document\n        if has_photo:\n            try:\n                await query.message.edit_caption(caption=text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard)\n            except Exception:\n                await query.message.reply_text(text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard, disable_web_page_preview=True)\n        else:\n            try:\n                await query.message.edit_text(text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard, disable_web_page_preview=True)\n            except Exception:\n                pass\n    except Exception:\n        pass\n    await query.answer()\n\n\n@app.on_chat_member_updated()\nasync def log_bot_added(_, cmu: ChatMemberUpdated):\n    try:\n        chat = cmu.chat\n        if chat.type not in (ChatType.GROUP, ChatType.SUPERGROUP):\n            return\n        # Only react to the bot's own membership updates\n        me = await _.get_me()\n        if not cmu.new_chat_member or not cmu.new_chat_member.user:\n            return\n        if cmu.new_chat_member.user.id != me.id:\n            return\n\n        new_status = cmu.new_chat_member.status\n        old_status = cmu.old_chat_member.status if cmu.old_chat_member else None\n\n        # Bot added/promoted\n        if new_status in (ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR) and old_status not in (ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR):\n            inviter = cmu.from_user.mention if cmu.from_user else \"Unknown\"\n            await send_event_log(\n                f\"<b>‚ùñ Bot Added to Group</b>\\n\\n\"\n                f\"<b>‚Ä¢ Chat:</b> {chat.title or chat.id} (<code>{chat.id}</code>)\\n\"\n                f\"<b>‚Ä¢ By:</b> {inviter}\\n\"\n                f\"<b>‚Ä¢ Status:</b> {new_status.name}\"\n            )\n        # Bot removed/kicked\n        elif new_status in (ChatMemberStatus.RESTRICTED, ChatMemberStatus.LEFT, ChatMemberStatus.BANNED):\n            remover = cmu.from_user.mention if cmu.from_user else \"Unknown\"\n            await send_event_log(\n                f\"<b>‚ùñ Bot Removed from Group</b>\\n\\n\"\n                f\"<b>‚Ä¢ Chat:</b> {chat.title or chat.id} (<code>{chat.id}</code>)\\n\"\n                f\"<b>‚Ä¢ By:</b> {remover}\\n\"\n                f\"<b>‚Ä¢ Status:</b> {new_status.name}\"\n            )\n    except Exception:\n        pass\n\n@app.on_callback_query(filters.regex(r\"^cat_.+$\"))\nasync def cb_category(_, query: CallbackQuery):\n    try:\n        from sitaBot.__main__ import HELPABLE\n        label = query.data.replace(\"cat_\", \"\", 1)\n        # Lookup category mapping built earlier\n        mapping = getattr(app, \"CATEGORY_MAP\", {})\n        modules = mapping.get(label, [])\n        if not modules:\n            # If something goes wrong, fall back to normal paginate\n            keyboard = InlineKeyboardMarkup(paginate_modules_pyrogram(0, HELPABLE, \"help\"))\n            text = \"<b>Modules</b>\"\n        else:\n            parts = [f\"<b>{label} Commands</b>\\n\"]\n            for key in modules:\n                mod = HELPABLE.get(key)\n                if not mod:\n                    continue\n                title = getattr(mod, \"__mod_name__\", key).strip()\n                help_text = getattr(mod, \"__help__\", \"No help available.\")\n                parts.append(f\"<b>‚Ä¢ {title}</b>\\n{help_text}\\n\")\n            text = \"\\n\".join(parts)\n            keyboard = InlineKeyboardMarkup([[InlineKeyboardButton(\"‚óÄÔ∏è Back\", callback_data=\"help_back\")]])\n\n        has_photo = query.message.photo or query.message.video or query.message.document\n        if has_photo:\n            try:\n                await query.message.edit_caption(caption=text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard)\n            except Exception:\n                await query.message.reply_text(text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard, disable_web_page_preview=True)\n        else:\n            try:\n                await query.message.edit_text(text, parse_mode=enums.ParseMode.HTML, reply_markup=keyboard, disable_web_page_preview=True)\n            except Exception:\n                pass\n    except Exception:\n        pass\n    await query.answer()\n\n@app.on_callback_query(filters.regex(r\"^help_module\\((.+?)\\)$\"))\nasync def cb_help_module(_, query: CallbackQuery):\n    try:\n        import re\n        match = re.match(r\"help_module\\((.+?)\\)\", query.data)\n        if match:\n            module_name = match.group(1)\n            from sitaBot.__main__ import HELPABLE\n            if module_name in HELPABLE:\n                mod_obj = HELPABLE[module_name]\n                mod_display = mod_obj.__mod_name__ if hasattr(mod_obj, '__mod_name__') else module_name\n                help_text = f\"<b>üìö {mod_display}</b>\\n\\n\"\n                \n                # Get help content\n                help_content = mod_obj.__help__ if hasattr(mod_obj, '__help__') else \"No help available.\"\n                help_text += help_content\n                \n                keyboard = InlineKeyboardMarkup([\n                    [InlineKeyboardButton(\"‚óÄÔ∏è Back\", callback_data=\"help_back\")]\n                ])\n                \n                # Always try to edit the same message, don't send new one\n                has_photo = query.message.photo or query.message.video or query.message.document\n                if has_photo:\n                    try:\n                        await query.message.edit_caption(\n                            caption=help_text,\n                            parse_mode=enums.ParseMode.HTML,\n                            reply_markup=keyboard,\n                        )\n                    except Exception:\n                        # If edit fails, try to convert to text message by deleting and editing\n                        try:\n                            # Delete photo message and send text\n                            chat_id = query.message.chat.id\n                            await query.message.delete()\n                            await _.send_message(\n                                chat_id,\n                                help_text,\n                                parse_mode=enums.ParseMode.HTML,\n                                reply_markup=keyboard,\n                                disable_web_page_preview=True\n                            )\n                        except Exception:\n                            pass\n                else:\n                    try:\n                        await query.message.edit_text(\n                            help_text,\n                            parse_mode=enums.ParseMode.HTML,\n                            reply_markup=keyboard,\n                            disable_web_page_preview=True\n                        )\n                    except Exception:\n                        pass\n    except Exception:\n        pass\n    await query.answer()\n\n\n@app.on_callback_query(filters.regex(r\"^help_prev\\((.+?)\\)$\"))\nasync def cb_help_prev(_, query: CallbackQuery):\n    try:\n        import re\n        match = re.match(r\"help_prev\\((.+?)\\)\", query.data)\n        if match:\n            curr_page = int(match.group(1))\n            from sitaBot.__main__ import HELPABLE, HELP_STRINGS\n            help_text = HELP_STRINGS.replace(\"Markdown\", \"HTML\").replace(\"*\", \"\").replace(\"_\", \"\")\n            if not help_text.strip():\n                help_text = (\n                    \"<b>‚öôÔ∏è Help & Commands</b>\\n\\n\"\n                    \"‚Ä¢ Click a module below to see commands and usage\\n\"\n                    \"‚Ä¢ All commands use the <code>/</code> prefix\"\n                )\n            keyboard = InlineKeyboardMarkup(paginate_modules_pyrogram(curr_page - 1, HELPABLE, \"help\"))\n            \n            has_photo = query.message.photo or query.message.video or query.message.document\n            if has_photo:\n                try:\n                    await query.message.edit_caption(\n                        caption=help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                    )\n                except Exception:\n                    await query.message.reply_text(\n                        help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                        disable_web_page_preview=True\n                    )\n            else:\n                try:\n                    await query.message.edit_text(\n                        help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                        disable_web_page_preview=True\n                    )\n                except Exception:\n                    pass\n    except Exception:\n        pass\n    await query.answer()\n\n\n@app.on_callback_query(filters.regex(r\"^help_next\\((.+?)\\)$\"))\nasync def cb_help_next(_, query: CallbackQuery):\n    try:\n        import re\n        match = re.match(r\"help_next\\((.+?)\\)\", query.data)\n        if match:\n            next_page = int(match.group(1))\n            from sitaBot.__main__ import HELPABLE, HELP_STRINGS\n            help_text = HELP_STRINGS.replace(\"Markdown\", \"HTML\").replace(\"*\", \"\").replace(\"_\", \"\")\n            if not help_text.strip():\n                help_text = (\n                    \"<b>‚öôÔ∏è Help & Commands</b>\\n\\n\"\n                    \"‚Ä¢ Click a module below to see commands and usage\\n\"\n                    \"‚Ä¢ All commands use the <code>/</code> prefix\"\n                )\n            keyboard = InlineKeyboardMarkup(paginate_modules_pyrogram(next_page + 1, HELPABLE, \"help\"))\n            \n            has_photo = query.message.photo or query.message.video or query.message.document\n            if has_photo:\n                try:\n                    await query.message.edit_caption(\n                        caption=help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                    )\n                except Exception:\n                    await query.message.reply_text(\n                        help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                        disable_web_page_preview=True\n                    )\n            else:\n                try:\n                    await query.message.edit_text(\n                        help_text,\n                        parse_mode=enums.ParseMode.HTML,\n                        reply_markup=keyboard,\n                        disable_web_page_preview=True\n                    )\n                except Exception:\n                    pass\n    except Exception:\n        pass\n    await query.answer()\n\n\n@app.on_callback_query(filters.regex(r\"^sita_back$\"))\nasync def cb_sita_back(_, query: CallbackQuery):\n    try:\n        caption = (\n            \"<b>‚ú® …™…¥…¥·¥áx…™·¥Ä  ô·¥è·¥õ</b> is online and ready to help!\\n\\n\"\n            \" è·¥è·¥ú Ä ·¥Ä ü ü‚Äë…™…¥‚Äë·¥è…¥·¥á …¢ Ä·¥è·¥ú·¥ò ·¥ç·¥Ä…¥·¥Ä…¢·¥á·¥ç·¥á…¥·¥õ + “ì·¥ú…¥  ô·¥è·¥õ:\\n\"\n            \"‚Ä¢ ·¥Ä·¥Ö·¥ç…™…¥ ·¥õ·¥è·¥è üs ( ô·¥Ä…¥/·¥ç·¥ú·¥õ·¥á/·¥ò…™…¥)\\n\"\n            \"‚Ä¢ ·¥°·¥Ä Ä…¥s, ·¥Ä…¥·¥õ…™“ì ü·¥è·¥è·¥Ö, “ì…™ ü·¥õ·¥á Äs, …¥·¥è·¥õ·¥ás\\n\"\n            \"‚Ä¢ Íú±·¥õ…™·¥Ñ·¥ã·¥á Ä/·¥ç·¥á·¥Ö…™·¥Ä ·¥õ·¥è·¥è üs, ·¥õ Ä·¥Ä…¥Íú± ü·¥Ä·¥õ·¥è Ä, ·¥°…™·¥ã…™, ·¥Ä…™ ·¥Ñ ú·¥Ä·¥õ\\n\\n\"\n            \"<i>¬© 2025‚Äë26 <a href=\\\"https://t.me/about_brahix\\\">brahix Bots</a> (\"\n            \"<a href=\\\"https://t.me/brahix\\\">brahix</a>) ¬∑ Powered by \"\n            \"<a href=\\\"https://t.me/brahix\\\">BRAHIX</a></i>\\n\\n\"\n            f\"<b> ú·¥á ü ü·¥è</b> {query.from_user.mention if query.from_user else ''}\\n\"\n            \"…™'·¥ç  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò  ú·¥á ü·¥ò·¥á Ä + “ì·¥ú…¥  ô·¥è·¥õ.  ü·¥á·¥õ'Íú± …¢·¥á·¥õ Íú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö!\"\n        )\n        try:\n            await query.message.edit_caption(\n                caption=caption,\n                parse_mode=enums.ParseMode.HTML,\n                reply_markup=private_keyboard(),\n            )\n        except Exception:\n            await query.message.edit_text(\n                caption,\n                parse_mode=enums.ParseMode.HTML,\n                reply_markup=private_keyboard(),\n                disable_web_page_preview=True\n            )\n    except Exception:\n        pass\n    await query.answer()\n\n","size_bytes":24956},"sitaBot/modules/disable.py":{"content":"import importlib\nfrom typing import Union\n\nfrom future.utils import string_types\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.helper_funcs.handlers import CMD_STARTERS, SpamChecker\nfrom sitaBot.modules.helper_funcs.misc import is_module_loaded\nfrom telegram import ParseMode, Update\nfrom telegram.ext import (\n    CallbackContext,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    RegexHandler,\n)\nfrom telegram.utils.helpers import escape_markdown\n\nFILENAME = __name__.rsplit(\".\", 1)[-1]\n\n# If module is due to be loaded, then setup all the magical handlers\nif is_module_loaded(FILENAME):\n\n    from sitaBot.modules.helper_funcs.chat_status import (\n        connection_status,\n        is_user_admin,\n        user_admin,\n    )\n    from sitaBot.modules.sql import disable_sql as sql\n    from telegram.ext.dispatcher import run_async\n\n    DISABLE_CMDS = []\n    DISABLE_OTHER = []\n    ADMIN_CMDS = []\n\n    class DisableAbleCommandHandler(CommandHandler):\n        def __init__(self, command, callback, admin_ok=False, **kwargs):\n            super().__init__(command, callback, **kwargs)\n            self.admin_ok = admin_ok\n            if isinstance(command, string_types):\n                DISABLE_CMDS.append(command)\n                if admin_ok:\n                    ADMIN_CMDS.append(command)\n            else:\n                DISABLE_CMDS.extend(command)\n                if admin_ok:\n                    ADMIN_CMDS.extend(command)\n\n        def check_update(self, update):\n            if isinstance(update, Update) and update.effective_message:\n                message = update.effective_message\n\n                if message.text and len(message.text) > 1:\n                    fst_word = message.text.split(None, 1)[0]\n                    if len(fst_word) > 1 and any(\n                        fst_word.startswith(start) for start in CMD_STARTERS\n                    ):\n                        args = message.text.split()[1:]\n                        command = fst_word[1:].split(\"@\")\n                        command.append(message.bot.username)\n\n                        if not (\n                            command[0].lower() in self.command\n                            and command[1].lower() == message.bot.username.lower()\n                        ):\n                            return None\n                        chat = update.effective_chat\n                        user = update.effective_user\n                        if user.id == 1087968824:\n                            user_id = chat.id\n                        else:\n                            user_id = user.id\n                        if SpamChecker.check_user(user_id):\n                            return None\n                        filter_result = self.filters(update)\n                        if filter_result:\n                            # disabled, admincmd, user admin\n                            if sql.is_command_disabled(chat.id, command[0].lower()):\n                                # check if command was disabled\n                                is_disabled = command[\n                                    0\n                                ] in ADMIN_CMDS and is_user_admin(chat, user.id)\n                                if not is_disabled:\n                                    return None\n                                else:\n                                    return args, filter_result\n\n                            return args, filter_result\n                        else:\n                            return False\n\n    class DisableAbleMessageHandler(MessageHandler):\n        def __init__(self, filters, callback, friendly, **kwargs):\n\n            super().__init__(filters, callback, **kwargs)\n            DISABLE_OTHER.append(friendly)\n            self.friendly = friendly\n            if filters:\n                self.filters = Filters.update.messages & filters\n            else:\n                self.filters = Filters.update.messages\n\n        def check_update(self, update):\n\n            chat = update.effective_chat\n            message = update.effective_message\n            filter_result = self.filters(update)\n\n            try:\n                args = message.text.split()[1:]\n            except:\n                args = []\n\n            if super().check_update(update):\n                if sql.is_command_disabled(chat.id, self.friendly):\n                    return False\n                else:\n                    return args, filter_result\n\n    class DisableAbleRegexHandler(RegexHandler):\n        def __init__(self, pattern, callback, friendly=\"\", filters=None, **kwargs):\n            super().__init__(pattern, callback, filters, **kwargs)\n            DISABLE_OTHER.append(friendly)\n            self.friendly = friendly\n\n        def check_update(self, update):\n            chat = update.effective_chat\n            if super().check_update(update):\n                if sql.is_command_disabled(chat.id, self.friendly):\n                    return False\n                else:\n                    return True\n\n    @run_async\n    @connection_status\n    @user_admin\n    def disable(update: Update, context: CallbackContext):\n        args = context.args\n        chat = update.effective_chat\n        if len(args) >= 1:\n            disable_cmd = args[0]\n            if disable_cmd.startswith(CMD_STARTERS):\n                disable_cmd = disable_cmd[1:]\n\n            if disable_cmd in set(DISABLE_CMDS + DISABLE_OTHER):\n                sql.disable_command(chat.id, str(disable_cmd).lower())\n                update.effective_message.reply_text(\n                    f\"Disabled the use of `{disable_cmd}`\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n            else:\n                update.effective_message.reply_text(\"That command can't be disabled\")\n\n        else:\n            update.effective_message.reply_text(\"What should I disable?\")\n\n    @run_async\n    @connection_status\n    @user_admin\n    def disable_module(update: Update, context: CallbackContext):\n        args = context.args\n        chat = update.effective_chat\n        if len(args) >= 1:\n            disable_module = \"sitaBot.modules.\" + args[0].rsplit(\".\", 1)[0]\n\n            try:\n                module = importlib.import_module(disable_module)\n            except:\n                update.effective_message.reply_text(\"Does that module even exist?\")\n                return\n\n            try:\n                command_list = module.__command_list__\n            except:\n                update.effective_message.reply_text(\n                    \"Module does not contain command list!\"\n                )\n                return\n\n            disabled_cmds = []\n            failed_disabled_cmds = []\n\n            for disable_cmd in command_list:\n                if disable_cmd.startswith(CMD_STARTERS):\n                    disable_cmd = disable_cmd[1:]\n\n                if disable_cmd in set(DISABLE_CMDS + DISABLE_OTHER):\n                    sql.disable_command(chat.id, str(disable_cmd).lower())\n                    disabled_cmds.append(disable_cmd)\n                else:\n                    failed_disabled_cmds.append(disable_cmd)\n\n            if disabled_cmds:\n                disabled_cmds_string = \", \".join(disabled_cmds)\n                update.effective_message.reply_text(\n                    f\"Disabled the uses of `{disabled_cmds_string}`\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n\n            if failed_disabled_cmds:\n                failed_disabled_cmds_string = \", \".join(failed_disabled_cmds)\n                update.effective_message.reply_text(\n                    f\"Commands `{failed_disabled_cmds_string}` can't be disabled\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n\n        else:\n            update.effective_message.reply_text(\"What should I disable?\")\n\n    @run_async\n    @connection_status\n    @user_admin\n    def enable(update: Update, context: CallbackContext):\n        args = context.args\n        chat = update.effective_chat\n        if len(args) >= 1:\n            enable_cmd = args[0]\n            if enable_cmd.startswith(CMD_STARTERS):\n                enable_cmd = enable_cmd[1:]\n\n            if sql.enable_command(chat.id, enable_cmd):\n                update.effective_message.reply_text(\n                    f\"Enabled the use of `{enable_cmd}`\", parse_mode=ParseMode.MARKDOWN\n                )\n            else:\n                update.effective_message.reply_text(\"Is that even disabled?\")\n\n        else:\n            update.effective_message.reply_text(\"What should I enable?\")\n\n    @run_async\n    @connection_status\n    @user_admin\n    def enable_module(update: Update, context: CallbackContext):\n        args = context.args\n        chat = update.effective_chat\n\n        if len(args) >= 1:\n            enable_module = \"sitaBot.modules.\" + args[0].rsplit(\".\", 1)[0]\n\n            try:\n                module = importlib.import_module(enable_module)\n            except:\n                update.effective_message.reply_text(\"Does that module even exist?\")\n                return\n\n            try:\n                command_list = module.__command_list__\n            except:\n                update.effective_message.reply_text(\n                    \"Module does not contain command list!\"\n                )\n                return\n\n            enabled_cmds = []\n            failed_enabled_cmds = []\n\n            for enable_cmd in command_list:\n                if enable_cmd.startswith(CMD_STARTERS):\n                    enable_cmd = enable_cmd[1:]\n\n                if sql.enable_command(chat.id, enable_cmd):\n                    enabled_cmds.append(enable_cmd)\n                else:\n                    failed_enabled_cmds.append(enable_cmd)\n\n            if enabled_cmds:\n                enabled_cmds_string = \", \".join(enabled_cmds)\n                update.effective_message.reply_text(\n                    f\"Enabled the uses of `{enabled_cmds_string}`\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n\n            if failed_enabled_cmds:\n                failed_enabled_cmds_string = \", \".join(failed_enabled_cmds)\n                update.effective_message.reply_text(\n                    f\"Are the commands `{failed_enabled_cmds_string}` even disabled?\",\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n\n        else:\n            update.effective_message.reply_text(\"What should I enable?\")\n\n    @run_async\n    @connection_status\n    @user_admin\n    def list_cmds(update: Update, context: CallbackContext):\n        if DISABLE_CMDS + DISABLE_OTHER:\n            result = \"\"\n            for cmd in set(DISABLE_CMDS + DISABLE_OTHER):\n                result += f\" - `{escape_markdown(cmd)}`\\n\"\n            update.effective_message.reply_text(\n                f\"The following commands are toggleable:\\n{result}\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        else:\n            update.effective_message.reply_text(\"No commands can be disabled.\")\n\n    # do not async\n    def build_curr_disabled(chat_id: Union[str, int]) -> str:\n        disabled = sql.get_all_disabled(chat_id)\n        if not disabled:\n            return \"No commands are disabled!\"\n\n        result = \"\"\n        for cmd in disabled:\n            result += \" - `{}`\\n\".format(escape_markdown(cmd))\n        return \"The following commands are currently restricted:\\n{}\".format(result)\n\n    @run_async\n    @connection_status\n    def commands(update: Update, context: CallbackContext):\n        chat = update.effective_chat\n        update.effective_message.reply_text(\n            build_curr_disabled(chat.id), parse_mode=ParseMode.MARKDOWN\n        )\n\n    def __stats__():\n        return f\"‚Ä¢ {sql.num_disabled()} disabled items, across {sql.num_chats()} chats.\"\n\n    def __migrate__(old_chat_id, new_chat_id):\n        sql.migrate_chat(old_chat_id, new_chat_id)\n\n    def __chat_settings__(chat_id, user_id):\n        return build_curr_disabled(chat_id)\n\n    DISABLE_HANDLER = CommandHandler(\"disable\", disable)\n    DISABLE_MODULE_HANDLER = CommandHandler(\"disablemodule\", disable_module)\n    ENABLE_HANDLER = CommandHandler(\"enable\", enable)\n    ENABLE_MODULE_HANDLER = CommandHandler(\"enablemodule\", enable_module)\n    COMMANDS_HANDLER = CommandHandler([\"cmds\", \"disabled\"], commands)\n    TOGGLE_HANDLER = CommandHandler(\"listcmds\", list_cmds)\n\n    dispatcher.add_handler(DISABLE_HANDLER)\n    dispatcher.add_handler(DISABLE_MODULE_HANDLER)\n    dispatcher.add_handler(ENABLE_HANDLER)\n    dispatcher.add_handler(ENABLE_MODULE_HANDLER)\n    dispatcher.add_handler(COMMANDS_HANDLER)\n    dispatcher.add_handler(TOGGLE_HANDLER)\n\n    __help__ = \"\"\"\n    ‚ùç /cmds*:* check the current status of disabled commands\n\n    *Admins only:*\n    ‚ùç /enable <cmd name>*:* enable that command\n    ‚ùç /disable <cmd name>*:* disable that command\n    ‚ùç /enablemodule <module name>*:* enable all commands in that module\n    ‚ùç /disablemodule <module name>*:* disable all commands in that module\n    ‚ùç /listcmds*:* list all possible toggleable commands\n    \"\"\"\n\n    __mod_name__ = \"Disable\"\n\nelse:\n    DisableAbleCommandHandler = CommandHandler\n    DisableAbleRegexHandler = RegexHandler\n    DisableAbleMessageHandler = MessageHandler\n","size_bytes":13167},"sitaBot/modules/log_channel.py":{"content":"from datetime import datetime\nfrom functools import wraps\n\nfrom telegram.ext import CallbackContext\n\nfrom sitaBot.modules.helper_funcs.misc import is_module_loaded\n\nFILENAME = __name__.rsplit(\".\", 1)[-1]\n\nif is_module_loaded(FILENAME):\n    from telegram import ParseMode, Update\n    from telegram.error import BadRequest, Unauthorized\n    from telegram.ext import CommandHandler, JobQueue, run_async\n    from telegram.utils.helpers import escape_markdown\n\n    from sitaBot import EVENT_LOGS, LOGGER, dispatcher\n    from sitaBot.modules.helper_funcs.chat_status import user_admin\n    from sitaBot.modules.sql import log_channel_sql as sql\n\n    def loggable(func):\n        @wraps(func)\n        def log_action(\n            update: Update,\n            context: CallbackContext,\n            job_queue: JobQueue = None,\n            *args,\n            **kwargs,\n        ):\n            if not job_queue:\n                result = func(update, context, *args, **kwargs)\n            else:\n                result = func(update, context, job_queue, *args, **kwargs)\n\n            chat = update.effective_chat\n            message = update.effective_message\n\n            if result:\n                datetime_fmt = \"%H:%M - %d-%m-%Y\"\n                result += f\"\\n<b>Event Stamp</b>: <code>{datetime.utcnow().strftime(datetime_fmt)}</code>\"\n\n                if message.chat.type == chat.SUPERGROUP and message.chat.username:\n                    result += f'\\n<b>Link:</b> <a href=\"https://t.me/{chat.username}/{message.message_id}\">click here</a>'\n                log_chat = sql.get_chat_log_channel(chat.id)\n                if log_chat:\n                    send_log(context, log_chat, chat.id, result)\n\n            return result\n\n        return log_action\n\n    def gloggable(func):\n        @wraps(func)\n        def glog_action(update: Update, context: CallbackContext, *args, **kwargs):\n            result = func(update, context, *args, **kwargs)\n            chat = update.effective_chat\n            message = update.effective_message\n\n            if result:\n                datetime_fmt = \"%H:%M - %d-%m-%Y\"\n                result += \"\\n<b>Event Stamp</b>: <code>{}</code>\".format(\n                    datetime.utcnow().strftime(datetime_fmt)\n                )\n\n                if message.chat.type == chat.SUPERGROUP and message.chat.username:\n                    result += f'\\n<b>Link:</b> <a href=\"https://t.me/{chat.username}/{message.message_id}\">click here</a>'\n                log_chat = str(EVENT_LOGS)\n                if log_chat:\n                    send_log(context, log_chat, chat.id, result)\n\n            return result\n\n        return glog_action\n\n    def send_log(\n        context: CallbackContext, log_chat_id: str, orig_chat_id: str, result: str\n    ):\n        bot = context.bot\n        try:\n            bot.send_message(\n                log_chat_id,\n                result,\n                parse_mode=ParseMode.HTML,\n                disable_web_page_preview=True,\n            )\n        except BadRequest as excp:\n            if excp.message == \"Chat not found\":\n                bot.send_message(\n                    orig_chat_id, \"This log channel has been deleted - unsetting.\"\n                )\n                sql.stop_chat_logging(orig_chat_id)\n            else:\n                LOGGER.warning(excp.message)\n                LOGGER.warning(result)\n                LOGGER.exception(\"Could not parse\")\n\n                bot.send_message(\n                    log_chat_id,\n                    result\n                    + \"\\n\\nFormatting has been disabled due to an unexpected error.\",\n                )\n\n    @run_async\n    @user_admin\n    def logging(update: Update, context: CallbackContext):\n        bot = context.bot\n        message = update.effective_message\n        chat = update.effective_chat\n\n        log_channel = sql.get_chat_log_channel(chat.id)\n        if log_channel:\n            log_channel_info = bot.get_chat(log_channel)\n            message.reply_text(\n                f\"This group has all it's logs sent to:\"\n                f\" {escape_markdown(log_channel_info.title)} (`{log_channel}`)\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n        else:\n            message.reply_text(\"No log channel has been set for this group!\")\n\n    @run_async\n    @user_admin\n    def setlog(update: Update, context: CallbackContext):\n        bot = context.bot\n        message = update.effective_message\n        chat = update.effective_chat\n        if chat.type == chat.CHANNEL:\n            message.reply_text(\n                \"Now, forward the /setlog to the group you want to tie this channel to!\"\n            )\n\n        elif message.forward_from_chat:\n            sql.set_chat_log_channel(chat.id, message.forward_from_chat.id)\n            try:\n                message.delete()\n            except BadRequest as excp:\n                if excp.message == \"Message to delete not found\":\n                    pass\n                else:\n                    LOGGER.exception(\n                        \"Error deleting message in log channel. Should work anyway though.\"\n                    )\n\n            try:\n                bot.send_message(\n                    message.forward_from_chat.id,\n                    f\"This channel has been set as the log channel for {chat.title or chat.first_name}.\",\n                )\n            except Unauthorized as excp:\n                if excp.message == \"Forbidden: bot is not a member of the channel chat\":\n                    bot.send_message(chat.id, \"Successfully set log channel!\")\n                else:\n                    LOGGER.exception(\"ERROR in setting the log channel.\")\n\n            bot.send_message(chat.id, \"Successfully set log channel!\")\n\n        else:\n            message.reply_text(\n                \"The steps to set a log channel are:\\n\"\n                \" - add bot to the desired channel\\n\"\n                \" - send /setlog to the channel\\n\"\n                \" - forward the /setlog to the group\\n\"\n            )\n\n    @run_async\n    @user_admin\n    def unsetlog(update: Update, context: CallbackContext):\n        bot = context.bot\n        message = update.effective_message\n        chat = update.effective_chat\n\n        log_channel = sql.stop_chat_logging(chat.id)\n        if log_channel:\n            bot.send_message(\n                log_channel, f\"Channel has been unlinked from {chat.title}\"\n            )\n            message.reply_text(\"Log channel has been un-set.\")\n\n        else:\n            message.reply_text(\"No log channel has been set yet!\")\n\n    def __stats__():\n        return f\"‚Ä¢ {sql.num_logchannels()} log channels set.\"\n\n    def __migrate__(old_chat_id, new_chat_id):\n        sql.migrate_chat(old_chat_id, new_chat_id)\n\n    def __chat_settings__(chat_id, user_id):\n        log_channel = sql.get_chat_log_channel(chat_id)\n        if log_channel:\n            log_channel_info = dispatcher.bot.get_chat(log_channel)\n            return f\"This group has all it's logs sent to: {escape_markdown(log_channel_info.title)} (`{log_channel}`)\"\n        return \"No log channel is set for this group!\"\n\n    __help__ = \"\"\"\n*Admins only:*\n ‚ùç /logchannel*:* get log channel info\n ‚ùç /setlog*:* set the log channel.\n ‚ùç /unsetlog*:* unset the log channel.\nSetting the log channel is done by:\n‚ùç adding the bot to the desired channel (as an admin!)\n‚ùç sending /setlog in the channel\n‚ùç forwarding the /setlog to the group\n\"\"\"\n\n    __mod_name__ = \"Channel\"\n\n    LOG_HANDLER = CommandHandler(\"logchannel\", logging)\n    SET_LOG_HANDLER = CommandHandler(\"setlog\", setlog)\n    UNSET_LOG_HANDLER = CommandHandler(\"unsetlog\", unsetlog)\n\n    dispatcher.add_handler(LOG_HANDLER)\n    dispatcher.add_handler(SET_LOG_HANDLER)\n    dispatcher.add_handler(UNSET_LOG_HANDLER)\n\nelse:\n    # run anyway if module not loaded\n    def loggable(func):\n        return func\n\n    def gloggable(func):\n        return func","size_bytes":7872},"sitaBot/modules/sql/feds_sql.py":{"content":"import threading\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, String, UnicodeText\nfrom telegram.error import BadRequest, Unauthorized\n\n\nclass Federations(BASE):\n    __tablename__ = \"feds\"\n    owner_id = Column(String(14))\n    fed_name = Column(UnicodeText)\n    fed_id = Column(UnicodeText, primary_key=True)\n    fed_rules = Column(UnicodeText)\n    fed_log = Column(UnicodeText)\n    fed_users = Column(UnicodeText)\n\n    def __init__(self, owner_id, fed_name, fed_id, fed_rules, fed_log, fed_users):\n        self.owner_id = owner_id\n        self.fed_name = fed_name\n        self.fed_id = fed_id\n        self.fed_rules = fed_rules\n        self.fed_log = fed_log\n        self.fed_users = fed_users\n\n\nclass ChatF(BASE):\n    __tablename__ = \"chat_feds\"\n    chat_id = Column(String(14), primary_key=True)\n    chat_name = Column(UnicodeText)\n    fed_id = Column(UnicodeText)\n\n    def __init__(self, chat_id, chat_name, fed_id):\n        self.chat_id = chat_id\n        self.chat_name = chat_name\n        self.fed_id = fed_id\n\n\nclass BansF(BASE):\n    __tablename__ = \"bans_feds\"\n    fed_id = Column(UnicodeText, primary_key=True)\n    user_id = Column(String(14), primary_key=True)\n    first_name = Column(UnicodeText, nullable=False)\n    last_name = Column(UnicodeText)\n    user_name = Column(UnicodeText)\n    reason = Column(UnicodeText, default=\"\")\n    time = Column(Integer, default=0)\n\n    def __init__(self, fed_id, user_id, first_name, last_name, user_name, reason, time):\n        self.fed_id = fed_id\n        self.user_id = user_id\n        self.first_name = first_name\n        self.last_name = last_name\n        self.user_name = user_name\n        self.reason = reason\n        self.time = time\n\n\nclass FedsUserSettings(BASE):\n    __tablename__ = \"feds_settings\"\n    user_id = Column(Integer, primary_key=True)\n    should_report = Column(Boolean, default=True)\n\n    def __init__(self, user_id):\n        self.user_id = user_id\n\n    def __repr__(self):\n        return \"<Feds report settings ({})>\".format(self.user_id)\n\n\nclass FedSubs(BASE):\n    __tablename__ = \"feds_subs\"\n    fed_id = Column(UnicodeText, primary_key=True)\n    fed_subs = Column(UnicodeText, primary_key=True, nullable=False)\n\n    def __init__(self, fed_id, fed_subs):\n        self.fed_id = fed_id\n        self.fed_subs = fed_subs\n\n    def __repr__(self):\n        return \"<Fed {} subscribes for {}>\".format(self.fed_id, self.fed_subs)\n\n\n# Dropping db\n# Federations.__table__.drop()\n# ChatF.__table__.drop()\n# BansF.__table__.drop()\n# FedSubs.__table__.drop()\n\nFederations.__table__.create(checkfirst=True)\nChatF.__table__.create(checkfirst=True)\nBansF.__table__.create(checkfirst=True)\nFedsUserSettings.__table__.create(checkfirst=True)\nFedSubs.__table__.create(checkfirst=True)\n\nFEDS_LOCK = threading.RLock()\nCHAT_FEDS_LOCK = threading.RLock()\nFEDS_SETTINGS_LOCK = threading.RLock()\nFEDS_SUBSCRIBER_LOCK = threading.RLock()\n\nFEDERATION_BYNAME = {}\nFEDERATION_BYOWNER = {}\nFEDERATION_BYFEDID = {}\n\nFEDERATION_CHATS = {}\nFEDERATION_CHATS_BYID = {}\n\nFEDERATION_BANNED_FULL = {}\nFEDERATION_BANNED_USERID = {}\n\nFEDERATION_NOTIFICATION = {}\nFEDS_SUBSCRIBER = {}\nMYFEDS_SUBSCRIBER = {}\n\n\ndef get_fed_info(fed_id):\n    get = FEDERATION_BYFEDID.get(str(fed_id))\n    if get is None:\n        return False\n    return get\n\n\ndef get_fed_id(chat_id):\n    get = FEDERATION_CHATS.get(str(chat_id))\n    if get is None:\n        return False\n    else:\n        return get[\"fid\"]\n\n\ndef get_fed_name(chat_id):\n    get = FEDERATION_CHATS.get(str(chat_id))\n    if get is None:\n        return False\n    else:\n        return get[\"chat_name\"]\n\n\ndef get_user_fban(fed_id, user_id):\n    if not FEDERATION_BANNED_FULL.get(fed_id):\n        return False, False, False\n    user_info = FEDERATION_BANNED_FULL[fed_id].get(user_id)\n    if not user_info:\n        return None, None, None\n    return user_info[\"first_name\"], user_info[\"reason\"], user_info[\"time\"]\n\n\ndef get_user_admin_fed_name(user_id):\n    user_feds = []\n    for f in FEDERATION_BYFEDID:\n        if int(user_id) in eval(eval(FEDERATION_BYFEDID[f][\"fusers\"])[\"members\"]):\n            user_feds.append(FEDERATION_BYFEDID[f][\"fname\"])\n    return user_feds\n\n\ndef get_user_owner_fed_name(user_id):\n    user_feds = []\n    for f in FEDERATION_BYFEDID:\n        if int(user_id) == int(eval(FEDERATION_BYFEDID[f][\"fusers\"])[\"owner\"]):\n            user_feds.append(FEDERATION_BYFEDID[f][\"fname\"])\n    return user_feds\n\n\ndef get_user_admin_fed_full(user_id):\n    user_feds = []\n    for f in FEDERATION_BYFEDID:\n        if int(user_id) in eval(eval(FEDERATION_BYFEDID[f][\"fusers\"])[\"members\"]):\n            user_feds.append({\"fed_id\": f, \"fed\": FEDERATION_BYFEDID[f]})\n    return user_feds\n\n\ndef get_user_owner_fed_full(user_id):\n    user_feds = []\n    for f in FEDERATION_BYFEDID:\n        if int(user_id) == int(eval(FEDERATION_BYFEDID[f][\"fusers\"])[\"owner\"]):\n            user_feds.append({\"fed_id\": f, \"fed\": FEDERATION_BYFEDID[f]})\n    return user_feds\n\n\ndef get_user_fbanlist(user_id):\n    banlist = FEDERATION_BANNED_FULL\n    user_name = \"\"\n    fedname = []\n    for x in banlist:\n        if banlist[x].get(user_id):\n            if user_name == \"\":\n                user_name = banlist[x][user_id].get(\"first_name\")\n            fedname.append([x, banlist[x][user_id].get(\"reason\")])\n    return user_name, fedname\n\n\ndef new_fed(owner_id, fed_name, fed_id):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n        fed = Federations(\n            str(owner_id),\n            fed_name,\n            str(fed_id),\n            \"Rules is not set in this federation.\",\n            None,\n            str({\"owner\": str(owner_id), \"members\": \"[]\"}),\n        )\n        SESSION.add(fed)\n        SESSION.commit()\n        FEDERATION_BYOWNER[str(owner_id)] = {\n            \"fid\": str(fed_id),\n            \"fname\": fed_name,\n            \"frules\": \"Rules is not set in this federation.\",\n            \"flog\": None,\n            \"fusers\": str({\"owner\": str(owner_id), \"members\": \"[]\"}),\n        }\n        FEDERATION_BYFEDID[str(fed_id)] = {\n            \"owner\": str(owner_id),\n            \"fname\": fed_name,\n            \"frules\": \"Rules is not set in this federation.\",\n            \"flog\": None,\n            \"fusers\": str({\"owner\": str(owner_id), \"members\": \"[]\"}),\n        }\n        FEDERATION_BYNAME[fed_name] = {\n            \"fid\": str(fed_id),\n            \"owner\": str(owner_id),\n            \"frules\": \"Rules is not set in this federation.\",\n            \"flog\": None,\n            \"fusers\": str({\"owner\": str(owner_id), \"members\": \"[]\"}),\n        }\n        return fed\n\n\ndef del_fed(fed_id):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME, FEDERATION_CHATS, FEDERATION_CHATS_BYID, FEDERATION_BANNED_USERID, FEDERATION_BANNED_FULL\n        getcache = FEDERATION_BYFEDID.get(fed_id)\n        if getcache is None:\n            return False\n        # Variables\n        getfed = FEDERATION_BYFEDID.get(fed_id)\n        owner_id = getfed[\"owner\"]\n        fed_name = getfed[\"fname\"]\n        # Delete from cache\n        FEDERATION_BYOWNER.pop(owner_id)\n        FEDERATION_BYFEDID.pop(fed_id)\n        FEDERATION_BYNAME.pop(fed_name)\n        if FEDERATION_CHATS_BYID.get(fed_id):\n            for x in FEDERATION_CHATS_BYID[fed_id]:\n                delchats = SESSION.query(ChatF).get(str(x))\n                if delchats:\n                    SESSION.delete(delchats)\n                    SESSION.commit()\n                FEDERATION_CHATS.pop(x)\n            FEDERATION_CHATS_BYID.pop(fed_id)\n        # Delete fedban users\n        getall = FEDERATION_BANNED_USERID.get(fed_id)\n        if getall:\n            for x in getall:\n                banlist = SESSION.query(BansF).get((fed_id, str(x)))\n                if banlist:\n                    SESSION.delete(banlist)\n                    SESSION.commit()\n        if FEDERATION_BANNED_USERID.get(fed_id):\n            FEDERATION_BANNED_USERID.pop(fed_id)\n        if FEDERATION_BANNED_FULL.get(fed_id):\n            FEDERATION_BANNED_FULL.pop(fed_id)\n        # Delete fedsubs\n        getall = MYFEDS_SUBSCRIBER.get(fed_id)\n        if getall:\n            for x in getall:\n                getsubs = SESSION.query(FedSubs).get((fed_id, str(x)))\n                if getsubs:\n                    SESSION.delete(getsubs)\n                    SESSION.commit()\n        if FEDS_SUBSCRIBER.get(fed_id):\n            FEDS_SUBSCRIBER.pop(fed_id)\n        if MYFEDS_SUBSCRIBER.get(fed_id):\n            MYFEDS_SUBSCRIBER.pop(fed_id)\n        # Delete from database\n        curr = SESSION.query(Federations).get(fed_id)\n        if curr:\n            SESSION.delete(curr)\n            SESSION.commit()\n        return True\n\n\ndef rename_fed(fed_id, owner_id, newname):\n    with FEDS_LOCK:\n        global FEDERATION_BYFEDID, FEDERATION_BYOWNER, FEDERATION_BYNAME\n        fed = SESSION.query(Federations).get(fed_id)\n        if not fed:\n            return False\n        fed.fed_name = newname\n        SESSION.commit()\n\n        # Update the dicts\n        oldname = FEDERATION_BYFEDID[str(fed_id)][\"fname\"]\n        tempdata = FEDERATION_BYNAME[oldname]\n        FEDERATION_BYNAME.pop(oldname)\n\n        FEDERATION_BYOWNER[str(owner_id)][\"fname\"] = newname\n        FEDERATION_BYFEDID[str(fed_id)][\"fname\"] = newname\n        FEDERATION_BYNAME[newname] = tempdata\n        return True\n\n\ndef chat_join_fed(fed_id, chat_name, chat_id):\n    with FEDS_LOCK:\n        global FEDERATION_CHATS, FEDERATION_CHATS_BYID\n        r = ChatF(chat_id, chat_name, fed_id)\n        SESSION.add(r)\n        FEDERATION_CHATS[str(chat_id)] = {\"chat_name\": chat_name, \"fid\": fed_id}\n        checkid = FEDERATION_CHATS_BYID.get(fed_id)\n        if checkid is None:\n            FEDERATION_CHATS_BYID[fed_id] = []\n        FEDERATION_CHATS_BYID[fed_id].append(str(chat_id))\n        SESSION.commit()\n        return r\n\n\ndef search_fed_by_name(fed_name):\n    allfed = FEDERATION_BYNAME.get(fed_name)\n    if allfed is None:\n        return False\n    return allfed\n\n\ndef search_user_in_fed(fed_id, user_id):\n    getfed = FEDERATION_BYFEDID.get(fed_id)\n    if getfed is None:\n        return False\n    getfed = eval(getfed[\"fusers\"])[\"members\"]\n    if user_id in eval(getfed):\n        return True\n    else:\n        return False\n\n\ndef user_demote_fed(fed_id, user_id):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n        # Variables\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        owner_id = getfed[\"owner\"]\n        fed_name = getfed[\"fname\"]\n        fed_rules = getfed[\"frules\"]\n        fed_log = getfed[\"flog\"]\n        # Temp set\n        try:\n            members = eval(eval(getfed[\"fusers\"])[\"members\"])\n        except ValueError:\n            return False\n        members.remove(user_id)\n        # Set user\n        FEDERATION_BYOWNER[str(owner_id)][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        FEDERATION_BYFEDID[str(fed_id)][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        FEDERATION_BYNAME[fed_name][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        # Set on database\n        fed = Federations(\n            str(owner_id),\n            fed_name,\n            str(fed_id),\n            fed_rules,\n            fed_log,\n            str({\"owner\": str(owner_id), \"members\": str(members)}),\n        )\n        SESSION.merge(fed)\n        SESSION.commit()\n        return True\n\n        curr = SESSION.query(UserF).all()\n        result = False\n        for r in curr:\n            if int(r.user_id) == int(user_id):\n                if r.fed_id == fed_id:\n                    SESSION.delete(r)\n                    SESSION.commit()\n                    result = True\n\n        SESSION.close()\n        return result\n\n\ndef user_join_fed(fed_id, user_id):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n        # Variables\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        owner_id = getfed[\"owner\"]\n        fed_name = getfed[\"fname\"]\n        fed_rules = getfed[\"frules\"]\n        fed_log = getfed[\"flog\"]\n        # Temp set\n        members = eval(eval(getfed[\"fusers\"])[\"members\"])\n        members.append(user_id)\n        # Set user\n        FEDERATION_BYOWNER[str(owner_id)][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        FEDERATION_BYFEDID[str(fed_id)][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        FEDERATION_BYNAME[fed_name][\"fusers\"] = str(\n            {\"owner\": str(owner_id), \"members\": str(members)}\n        )\n        # Set on database\n        fed = Federations(\n            str(owner_id),\n            fed_name,\n            str(fed_id),\n            fed_rules,\n            fed_log,\n            str({\"owner\": str(owner_id), \"members\": str(members)}),\n        )\n        SESSION.merge(fed)\n        SESSION.commit()\n        __load_all_feds_chats()\n        return True\n\n\ndef chat_leave_fed(chat_id):\n    with FEDS_LOCK:\n        global FEDERATION_CHATS, FEDERATION_CHATS_BYID\n        # Set variables\n        fed_info = FEDERATION_CHATS.get(str(chat_id))\n        if fed_info is None:\n            return False\n        fed_id = fed_info[\"fid\"]\n        # Delete from cache\n        FEDERATION_CHATS.pop(str(chat_id))\n        FEDERATION_CHATS_BYID[str(fed_id)].remove(str(chat_id))\n        # Delete from db\n        curr = SESSION.query(ChatF).all()\n        for U in curr:\n            if int(U.chat_id) == int(chat_id):\n                SESSION.delete(U)\n                SESSION.commit()\n        return True\n\n\ndef all_fed_chats(fed_id):\n    with FEDS_LOCK:\n        getfed = FEDERATION_CHATS_BYID.get(fed_id)\n        if getfed is None:\n            return []\n        else:\n            return getfed\n\n\ndef all_fed_users(fed_id):\n    with FEDS_LOCK:\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        if getfed is None:\n            return False\n        fed_owner = eval(eval(getfed[\"fusers\"])[\"owner\"])\n        fed_admins = eval(eval(getfed[\"fusers\"])[\"members\"])\n        fed_admins.append(fed_owner)\n        return fed_admins\n\n\ndef all_fed_members(fed_id):\n    with FEDS_LOCK:\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        fed_admins = eval(eval(getfed[\"fusers\"])[\"members\"])\n        return fed_admins\n\n\ndef set_frules(fed_id, rules):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n        # Variables\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        owner_id = getfed[\"owner\"]\n        fed_name = getfed[\"fname\"]\n        fed_members = getfed[\"fusers\"]\n        fed_rules = str(rules)\n        fed_log = getfed[\"flog\"]\n        # Set user\n        FEDERATION_BYOWNER[str(owner_id)][\"frules\"] = fed_rules\n        FEDERATION_BYFEDID[str(fed_id)][\"frules\"] = fed_rules\n        FEDERATION_BYNAME[fed_name][\"frules\"] = fed_rules\n        # Set on database\n        fed = Federations(\n            str(owner_id), fed_name, str(fed_id), fed_rules, fed_log, str(fed_members)\n        )\n        SESSION.merge(fed)\n        SESSION.commit()\n        return True\n\n\ndef get_frules(fed_id):\n    with FEDS_LOCK:\n        rules = FEDERATION_BYFEDID[str(fed_id)][\"frules\"]\n        return rules\n\n\ndef fban_user(fed_id, user_id, first_name, last_name, user_name, reason, time):\n    with FEDS_LOCK:\n        r = SESSION.query(BansF).all()\n        for I in r:\n            if I.fed_id == fed_id:\n                if int(I.user_id) == int(user_id):\n                    SESSION.delete(I)\n\n        r = BansF(\n            str(fed_id), str(user_id), first_name, last_name, user_name, reason, time\n        )\n\n        SESSION.add(r)\n        try:\n            SESSION.commit()\n        except:\n            SESSION.rollback()\n            return False\n        finally:\n            SESSION.commit()\n        __load_all_feds_banned()\n        return r\n\n\ndef multi_fban_user(\n    multi_fed_id,\n    multi_user_id,\n    multi_first_name,\n    multi_last_name,\n    multi_user_name,\n    multi_reason,\n):\n    if True:  # with FEDS_LOCK:\n        counter = 0\n        time = 0\n        for x in range(len(multi_fed_id)):\n            fed_id = multi_fed_id[x]\n            user_id = multi_user_id[x]\n            first_name = multi_first_name[x]\n            last_name = multi_last_name[x]\n            user_name = multi_user_name[x]\n            reason = multi_reason[x]\n            r = SESSION.query(BansF).all()\n            for I in r:\n                if I.fed_id == fed_id:\n                    if int(I.user_id) == int(user_id):\n                        SESSION.delete(I)\n\n            r = BansF(\n                str(fed_id),\n                str(user_id),\n                first_name,\n                last_name,\n                user_name,\n                reason,\n                time,\n            )\n\n            SESSION.add(r)\n            counter += 1\n            if str(str(counter)[-2:]) == \"00\":\n                print(user_id)\n                print(first_name)\n                print(reason)\n                print(counter)\n        try:\n            SESSION.commit()\n        except:\n            SESSION.rollback()\n            return False\n        finally:\n            SESSION.commit()\n        __load_all_feds_banned()\n        print(\"Done\")\n        return counter\n\n\ndef un_fban_user(fed_id, user_id):\n    with FEDS_LOCK:\n        r = SESSION.query(BansF).all()\n        for I in r:\n            if I.fed_id == fed_id:\n                if int(I.user_id) == int(user_id):\n                    SESSION.delete(I)\n        try:\n            SESSION.commit()\n        except:\n            SESSION.rollback()\n            return False\n        finally:\n            SESSION.commit()\n        __load_all_feds_banned()\n        return I\n\n\ndef get_fban_user(fed_id, user_id):\n    list_fbanned = FEDERATION_BANNED_USERID.get(fed_id)\n    if list_fbanned is None:\n        FEDERATION_BANNED_USERID[fed_id] = []\n    if user_id in FEDERATION_BANNED_USERID[fed_id]:\n        r = SESSION.query(BansF).all()\n        reason = None\n        for I in r:\n            if I.fed_id == fed_id:\n                if int(I.user_id) == int(user_id):\n                    reason = I.reason\n                    time = I.time\n        return True, reason, time\n    else:\n        return False, None, None\n\n\ndef get_all_fban_users(fed_id):\n    list_fbanned = FEDERATION_BANNED_USERID.get(fed_id)\n    if list_fbanned is None:\n        FEDERATION_BANNED_USERID[fed_id] = []\n    return FEDERATION_BANNED_USERID[fed_id]\n\n\ndef get_all_fban_users_target(fed_id, user_id):\n    list_fbanned = FEDERATION_BANNED_FULL.get(fed_id)\n    if list_fbanned is None:\n        FEDERATION_BANNED_FULL[fed_id] = []\n        return False\n    getuser = list_fbanned[str(user_id)]\n    return getuser\n\n\ndef get_all_fban_users_global():\n    list_fbanned = FEDERATION_BANNED_USERID\n    total = []\n    for x in list(FEDERATION_BANNED_USERID):\n        for y in FEDERATION_BANNED_USERID[x]:\n            total.append(y)\n    return total\n\n\ndef get_all_feds_users_global():\n    list_fed = FEDERATION_BYFEDID\n    total = []\n    for x in list(FEDERATION_BYFEDID):\n        total.append(FEDERATION_BYFEDID[x])\n    return total\n\n\ndef search_fed_by_id(fed_id):\n    get = FEDERATION_BYFEDID.get(fed_id)\n    if get is None:\n        return False\n    else:\n        return get\n    result = False\n    for Q in curr:\n        if Q.fed_id == fed_id:\n            result = Q.fed_id\n\n    return result\n\n\ndef user_feds_report(user_id: int) -> bool:\n    user_setting = FEDERATION_NOTIFICATION.get(str(user_id))\n    if user_setting is None:\n        user_setting = True\n    return user_setting\n\n\ndef set_feds_setting(user_id: int, setting: bool):\n    with FEDS_SETTINGS_LOCK:\n        global FEDERATION_NOTIFICATION\n        user_setting = SESSION.query(FedsUserSettings).get(user_id)\n        if not user_setting:\n            user_setting = FedsUserSettings(user_id)\n\n        user_setting.should_report = setting\n        FEDERATION_NOTIFICATION[str(user_id)] = setting\n        SESSION.add(user_setting)\n        SESSION.commit()\n\n\ndef get_fed_log(fed_id):\n    fed_setting = FEDERATION_BYFEDID.get(str(fed_id))\n    if fed_setting is None:\n        fed_setting = False\n        return fed_setting\n    if fed_setting.get(\"flog\") is None:\n        return False\n    elif fed_setting.get(\"flog\"):\n        try:\n            dispatcher.bot.get_chat(fed_setting.get(\"flog\"))\n        except BadRequest:\n            set_fed_log(fed_id, None)\n            return False\n        except Unauthorized:\n            set_fed_log(fed_id, None)\n            return False\n        return fed_setting.get(\"flog\")\n    else:\n        return False\n\n\ndef set_fed_log(fed_id, chat_id):\n    with FEDS_LOCK:\n        global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n        # Variables\n        getfed = FEDERATION_BYFEDID.get(str(fed_id))\n        owner_id = getfed[\"owner\"]\n        fed_name = getfed[\"fname\"]\n        fed_members = getfed[\"fusers\"]\n        fed_rules = getfed[\"frules\"]\n        fed_log = str(chat_id)\n        # Set user\n        FEDERATION_BYOWNER[str(owner_id)][\"flog\"] = fed_log\n        FEDERATION_BYFEDID[str(fed_id)][\"flog\"] = fed_log\n        FEDERATION_BYNAME[fed_name][\"flog\"] = fed_log\n        # Set on database\n        fed = Federations(\n            str(owner_id), fed_name, str(fed_id), fed_rules, fed_log, str(fed_members)\n        )\n        SESSION.merge(fed)\n        SESSION.commit()\n        print(fed_log)\n        return True\n\n\ndef subs_fed(fed_id, my_fed):\n    check = get_spec_subs(fed_id, my_fed)\n    if check:\n        return False\n    with FEDS_SUBSCRIBER_LOCK:\n        subsfed = FedSubs(fed_id, my_fed)\n\n        SESSION.merge(subsfed)  # merge to avoid duplicate key issues\n        SESSION.commit()\n        global FEDS_SUBSCRIBER\n        if FEDS_SUBSCRIBER.get(fed_id, set()) == set():\n            FEDS_SUBSCRIBER[fed_id] = {my_fed}\n        else:\n            FEDS_SUBSCRIBER.get(fed_id, set()).add(my_fed)\n        return True\n\n\ndef unsubs_fed(fed_id, my_fed):\n    with FEDS_SUBSCRIBER_LOCK:\n        getsubs = SESSION.query(FedSubs).get((fed_id, my_fed))\n        if getsubs:\n            if my_fed in FEDS_SUBSCRIBER.get(fed_id, set()):  # sanity check\n                FEDS_SUBSCRIBER.get(fed_id, set()).remove(my_fed)\n\n            SESSION.delete(getsubs)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef get_all_subs(fed_id):\n    return FEDS_SUBSCRIBER.get(fed_id, set())\n\n\ndef get_spec_subs(fed_id, fed_target):\n    if FEDS_SUBSCRIBER.get(fed_id, set()) == set():\n        return {}\n    else:\n        return FEDS_SUBSCRIBER.get(fed_id, fed_target)\n\n\ndef get_mysubs(my_fed):\n    return list(MYFEDS_SUBSCRIBER.get(my_fed))\n\n\ndef get_subscriber(fed_id):\n    return FEDS_SUBSCRIBER.get(fed_id, set())\n\n\ndef __load_all_feds():\n    global FEDERATION_BYOWNER, FEDERATION_BYFEDID, FEDERATION_BYNAME\n    try:\n        feds = SESSION.query(Federations).all()\n        for x in feds:  # remove tuple by ( ,)\n            # Fed by Owner\n            check = FEDERATION_BYOWNER.get(x.owner_id)\n            if check is None:\n                FEDERATION_BYOWNER[x.owner_id] = []\n            FEDERATION_BYOWNER[str(x.owner_id)] = {\n                \"fid\": str(x.fed_id),\n                \"fname\": x.fed_name,\n                \"frules\": x.fed_rules,\n                \"flog\": x.fed_log,\n                \"fusers\": str(x.fed_users),\n            }\n            # Fed By FedId\n            check = FEDERATION_BYFEDID.get(x.fed_id)\n            if check is None:\n                FEDERATION_BYFEDID[x.fed_id] = []\n            FEDERATION_BYFEDID[str(x.fed_id)] = {\n                \"owner\": str(x.owner_id),\n                \"fname\": x.fed_name,\n                \"frules\": x.fed_rules,\n                \"flog\": x.fed_log,\n                \"fusers\": str(x.fed_users),\n            }\n            # Fed By Name\n            check = FEDERATION_BYNAME.get(x.fed_name)\n            if check is None:\n                FEDERATION_BYNAME[x.fed_name] = []\n            FEDERATION_BYNAME[x.fed_name] = {\n                \"fid\": str(x.fed_id),\n                \"owner\": str(x.owner_id),\n                \"frules\": x.fed_rules,\n                \"flog\": x.fed_log,\n                \"fusers\": str(x.fed_users),\n            }\n    finally:\n        SESSION.close()\n\n\ndef __load_all_feds_chats():\n    global FEDERATION_CHATS, FEDERATION_CHATS_BYID\n    try:\n        qall = SESSION.query(ChatF).all()\n        FEDERATION_CHATS = {}\n        FEDERATION_CHATS_BYID = {}\n        for x in qall:\n            # Federation Chats\n            check = FEDERATION_CHATS.get(x.chat_id)\n            if check is None:\n                FEDERATION_CHATS[x.chat_id] = {}\n            FEDERATION_CHATS[x.chat_id] = {\"chat_name\": x.chat_name, \"fid\": x.fed_id}\n            # Federation Chats By ID\n            check = FEDERATION_CHATS_BYID.get(x.fed_id)\n            if check is None:\n                FEDERATION_CHATS_BYID[x.fed_id] = []\n            FEDERATION_CHATS_BYID[x.fed_id].append(x.chat_id)\n    finally:\n        SESSION.close()\n\n\ndef __load_all_feds_banned():\n    global FEDERATION_BANNED_USERID, FEDERATION_BANNED_FULL\n    try:\n        FEDERATION_BANNED_USERID = {}\n        FEDERATION_BANNED_FULL = {}\n        qall = SESSION.query(BansF).all()\n        for x in qall:\n            check = FEDERATION_BANNED_USERID.get(x.fed_id)\n            if check is None:\n                FEDERATION_BANNED_USERID[x.fed_id] = []\n            if int(x.user_id) not in FEDERATION_BANNED_USERID[x.fed_id]:\n                FEDERATION_BANNED_USERID[x.fed_id].append(int(x.user_id))\n            check = FEDERATION_BANNED_FULL.get(x.fed_id)\n            if check is None:\n                FEDERATION_BANNED_FULL[x.fed_id] = {}\n            FEDERATION_BANNED_FULL[x.fed_id][x.user_id] = {\n                \"first_name\": x.first_name,\n                \"last_name\": x.last_name,\n                \"user_name\": x.user_name,\n                \"reason\": x.reason,\n                \"time\": x.time,\n            }\n    finally:\n        SESSION.close()\n\n\ndef __load_all_feds_settings():\n    global FEDERATION_NOTIFICATION\n    try:\n        getuser = SESSION.query(FedsUserSettings).all()\n        for x in getuser:\n            FEDERATION_NOTIFICATION[str(x.user_id)] = x.should_report\n    finally:\n        SESSION.close()\n\n\ndef __load_feds_subscriber():\n    global FEDS_SUBSCRIBER\n    global MYFEDS_SUBSCRIBER\n    try:\n        feds = SESSION.query(FedSubs.fed_id).distinct().all()\n        for (fed_id,) in feds:  # remove tuple by ( ,)\n            FEDS_SUBSCRIBER[fed_id] = []\n            MYFEDS_SUBSCRIBER[fed_id] = []\n\n        all_fedsubs = SESSION.query(FedSubs).all()\n        for x in all_fedsubs:\n            FEDS_SUBSCRIBER[x.fed_id] += [x.fed_subs]\n            try:\n                MYFEDS_SUBSCRIBER[x.fed_subs] += [x.fed_id]\n            except KeyError:\n                getsubs = SESSION.query(FedSubs).get((x.fed_id, x.fed_subs))\n                if getsubs:\n                    SESSION.delete(getsubs)\n                    SESSION.commit()\n\n        FEDS_SUBSCRIBER = {x: set(y) for x, y in FEDS_SUBSCRIBER.items()}\n        MYFEDS_SUBSCRIBER = {x: set(y) for x, y in MYFEDS_SUBSCRIBER.items()}\n\n    finally:\n        SESSION.close()\n\n\n__load_all_feds()\n__load_all_feds_chats()\n__load_all_feds_banned()\n__load_all_feds_settings()\n__load_feds_subscriber()\n","size_bytes":27405},"sitaBot/modules/userinfo.py":{"content":"import html\nimport re\nimport os\nimport requests\n\nfrom telethon.tl.functions.channels import GetFullChannelRequest\nfrom telethon.tl.types import ChannelParticipantsAdmins\nfrom telethon import events\n\nfrom telegram import MAX_MESSAGE_LENGTH, ParseMode, Update\nfrom telegram.ext import CallbackContext, CommandHandler\nfrom telegram.ext.dispatcher import run_async\nfrom telegram.error import BadRequest\nfrom telegram.utils.helpers import escape_markdown, mention_html\n\nfrom sitaBot import (\n    DEV_USERS,\n    OWNER_ID,\n    DRAGONS,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    INFOPIC,\n    dispatcher,\n    sw,\n)\nfrom sitaBot.__main__ import STATS, TOKEN, USER_INFO\nimport sitaBot.modules.sql.userinfo_sql as sql\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.sql.global_bans_sql import is_user_gbanned\nfrom sitaBot.modules.sql.afk_sql import is_afk, check_afk_status\nfrom sitaBot.modules.sql.users_sql import get_user_num_chats\nfrom sitaBot.modules.helper_funcs.chat_status import sudo_plus\nfrom sitaBot.modules.helper_funcs.extraction import extract_user\nfrom sitaBot import telethn as YoneTelethonClient, TIGERS, DRAGONS, DEMONS\n\n\ndef no_by_per(totalhp, percentage):\n    \"\"\"\n    rtype: num of `percentage` from total\n    eg: 1000, 10 -> 10% of 1000 (100)\n    \"\"\"\n    return totalhp * percentage / 100\n\n\ndef get_percentage(totalhp, earnedhp):\n    \"\"\"\n    rtype: percentage of `totalhp` num\n    eg: (1000, 100) will return 10%\n    \"\"\"\n\n    matched_less = totalhp - earnedhp\n    per_of_totalhp = 100 - matched_less * 100.0 / totalhp\n    per_of_totalhp = str(int(per_of_totalhp))\n    return per_of_totalhp\n\n\ndef hpmanager(user):\n    total_hp = (get_user_num_chats(user.id) + 10) * 10\n\n    if not is_user_gbanned(user.id):\n\n        # Assign new var `new_hp` since we need `total_hp` in\n        # end to calculate percentage.\n        new_hp = total_hp\n\n        # if no username decrease 25% of hp.\n        if not user.username:\n            new_hp -= no_by_per(total_hp, 25)\n        try:\n            dispatcher.bot.get_user_profile_photos(user.id).photos[0][-1]\n        except IndexError:\n            # no profile photo ==> -25% of hp\n            new_hp -= no_by_per(total_hp, 25)\n        # if no /setme exist ==> -20% of hp\n        if not sql.get_user_me_info(user.id):\n            new_hp -= no_by_per(total_hp, 20)\n        # if no bio exsit ==> -10% of hp\n        if not sql.get_user_bio(user.id):\n            new_hp -= no_by_per(total_hp, 10)\n\n        if is_afk(user.id):\n            afkst = check_afk_status(user.id)\n            # if user is afk and no reason then decrease 7%\n            # else if reason exist decrease 5%\n            if not afkst.reason:\n                new_hp -= no_by_per(total_hp, 7)\n            else:\n                new_hp -= no_by_per(total_hp, 5)\n\n        # fbanned users will have (2*number of fbans) less from max HP\n        # Example: if HP is 100 but user has 5 diff fbans\n        # Available HP is (2*5) = 10% less than Max HP\n        # So.. 10% of 100HP = 90HP\n\n    # Commenting out fban health decrease cause it wasnt working and isnt needed ig.\n    # _, fbanlist = get_user_fbanlist(user.id)\n    # new_hp -= no_by_per(total_hp, 2 * len(fbanlist))\n\n    # Bad status effects:\n    # gbanned users will always have 5% HP from max HP\n    # Example: If HP is 100 but gbanned\n    # Available HP is 5% of 100 = 5HP\n\n    else:\n        new_hp = no_by_per(total_hp, 5)\n\n    return {\n        \"earnedhp\": int(new_hp),\n        \"totalhp\": int(total_hp),\n        \"percentage\": get_percentage(total_hp, new_hp),\n    }\n\n\ndef make_bar(per):\n    done = min(round(per / 10), 10)\n    return \"‚ñ†\" * done + \"‚ñ°\" * (10 - done)\n\n\n@run_async\ndef get_id(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    chat = update.effective_chat\n    msg = update.effective_message\n    user_id = extract_user(msg, args)\n\n    if user_id:\n\n        if msg.reply_to_message and msg.reply_to_message.forward_from:\n\n            user1 = message.reply_to_message.from_user\n            user2 = message.reply_to_message.forward_from\n\n            msg.reply_text(\n                f\"<b>Telegram ID:</b>,\"\n                f\"‚Ä¢ {html.escape(user2.first_name)} - <code>{user2.id}</code>.\\n\"\n                f\"‚Ä¢ {html.escape(user1.first_name)} - <code>{user1.id}</code>.\",\n                parse_mode=ParseMode.HTML,\n            )\n\n        else:\n\n            user = bot.get_chat(user_id)\n            msg.reply_text(\n                f\"{html.escape(user.first_name)}'s id is <code>{user.id}</code>.\",\n                parse_mode=ParseMode.HTML,\n            )\n\n    else:\n\n        if chat.type == \"private\":\n            msg.reply_text(\n                f\"Your id is <code>{chat.id}</code>.\", parse_mode=ParseMode.HTML\n            )\n\n        else:\n            msg.reply_text(\n                f\"This group's id is <code>{chat.id}</code>.\", parse_mode=ParseMode.HTML\n            )\n\n\n@YoneTelethonClient.on(\n    events.NewMessage(\n        pattern=\"/ginfo \", from_users=(TIGERS or []) + (DRAGONS or []) + (DEMONS or [])\n    )\n)\nasync def group_info(event) -> None:\n    chat = event.text.split(\" \", 1)[1]\n    try:\n        entity = await event.client.get_entity(chat)\n        totallist = await event.client.get_participants(\n            entity, filter=ChannelParticipantsAdmins\n        )\n        ch_full = await event.client(GetFullChannelRequest(channel=entity))\n    except:\n        await event.reply(\n            \"Can't for some reason, maybe it is a private one or that I am banned there.\"\n        )\n        return\n    msg = f\"**ID**: `{entity.id}`\"\n    msg += f\"\\n**Title**: `{entity.title}`\"\n    msg += f\"\\n**Datacenter**: `{entity.photo.dc_id}`\"\n    msg += f\"\\n**Video PFP**: `{entity.photo.has_video}`\"\n    msg += f\"\\n**Supergroup**: `{entity.megagroup}`\"\n    msg += f\"\\n**Restricted**: `{entity.restricted}`\"\n    msg += f\"\\n**Scam**: `{entity.scam}`\"\n    msg += f\"\\n**Slowmode**: `{entity.slowmode_enabled}`\"\n    if entity.username:\n        msg += f\"\\n**Username**: {entity.username}\"\n    msg += \"\\n\\n**Member Stats:**\"\n    msg += f\"\\n`Admins:` `{len(totallist)}`\"\n    msg += f\"\\n`Users`: `{totallist.total}`\"\n    msg += \"\\n\\n**Admins List:**\"\n    for x in totallist:\n        msg += f\"\\n‚Ä¢ [{x.id}](tg://user?id={x.id})\"\n    msg += f\"\\n\\n**Description**:\\n`{ch_full.full_chat.about}`\"\n    await event.reply(msg)\n\n\n@run_async\ndef gifid(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    if msg.reply_to_message and msg.reply_to_message.animation:\n        update.effective_message.reply_text(\n            f\"Gif ID:\\n<code>{msg.reply_to_message.animation.file_id}</code>\",\n            parse_mode=ParseMode.HTML,\n        )\n    else:\n        update.effective_message.reply_text(\"Please reply to a gif to get its ID.\")\n\n\n@run_async\ndef info(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    chat = update.effective_chat\n    user_id = extract_user(update.effective_message, args)\n\n    if user_id:\n        user = bot.get_chat(user_id)\n\n    elif not message.reply_to_message and not args:\n        user = message.from_user\n\n    elif not message.reply_to_message and (\n        not args\n        or (\n            len(args) >= 1\n            and not args[0].startswith(\"@\")\n            and not args[0].isdigit()\n            and not message.parse_entities([MessageEntity.TEXT_MENTION])\n        )\n    ):\n        message.reply_text(\"I can't extract a user from this.\")\n        return\n\n    else:\n        return\n\n    rep = message.reply_text(\"<code>Appraising...</code>\", parse_mode=ParseMode.HTML)\n\n    text = (\n        f\"‚ïí‚ïê‚ïê‚ïê„Äå<b> Appraisal results:</b> „Äç\\n\"\n        f\"ID: <code>{user.id}</code>\\n\"\n        f\"First Name: {html.escape(user.first_name)}\"\n    )\n\n    if user.last_name:\n        text += f\"\\nLast Name: {html.escape(user.last_name)}\"\n\n    if user.username:\n        text += f\"\\nUsername: @{html.escape(user.username)}\"\n\n    text += f\"\\nPermalink: {mention_html(user.id, 'link')}\"\n\n    if chat.type != \"private\" and user_id != bot.id:\n        _stext = \"\\nPresence: <code>{}</code>\"\n\n        afk_st = is_afk(user.id)\n        if afk_st:\n            text += _stext.format(\"AFK\")\n        else:\n            status = status = bot.get_chat_member(chat.id, user.id).status\n            if status:\n                if status in {\"left\", \"kicked\"}:\n                    text += _stext.format(\"Not here\")\n                elif status == \"member\":\n                    text += _stext.format(\"Detected\")\n                elif status in {\"administrator\", \"creator\"}:\n                    text += _stext.format(\"Admin\")\n    if user_id not in [bot.id, 777000, 1087968824]:\n        userhp = hpmanager(user)\n        text += f\"\\n\\n<b>Health:</b> <code>{userhp['earnedhp']}/{userhp['totalhp']}</code>\\n[<i>{make_bar(int(userhp['percentage']))} </i>{userhp['percentage']}%]\"\n\n    try:\n        spamwtc = sw.get_ban(int(user.id))\n        if spamwtc:\n            text += \"\\n\\n<b>This person is Spamwatched!</b>\"\n            text += f\"\\nReason: <pre>{spamwtc.reason}</pre>\"\n            text += \"\\nAppeal at @SpamWatchSupport\"\n        else:\n            pass\n    except:\n        pass  # don't crash if api is down somehow...\n\n    disaster_level_present = False\n\n    if user.id == OWNER_ID:\n        text += \"\\n\\nThe Disaster level of this person is 'God'.\"\n        disaster_level_present = True\n    elif user.id in DEV_USERS:\n        text += \"\\n\\nThis user is member of 'Hero Association'.\"\n        disaster_level_present = True\n    elif user.id in DRAGONS:\n        text += \"\\n\\nThe Disaster level of this person is 'Dragon'.\"\n        disaster_level_present = True\n    elif user.id in DEMONS:\n        text += \"\\n\\nThe Disaster level of this person is 'Demon'.\"\n        disaster_level_present = True\n    elif user.id in TIGERS:\n        text += \"\\n\\nThe Disaster level of this person is 'Tiger'.\"\n        disaster_level_present = True\n    elif user.id in WOLVES:\n        text += \"\\n\\nThe Disaster level of this person is 'Wolf'.\"\n        disaster_level_present = True\n\n    if disaster_level_present:\n        text += ' [<a href=\"https://t.me/OnePunchUpdates/155\">?</a>]'.format(\n            bot.username\n        )\n\n    try:\n        user_member = chat.get_member(user.id)\n        if user_member.status == \"administrator\":\n            result = requests.post(\n                f\"https://api.telegram.org/bot{TOKEN}/getChatMember?chat_id={chat.id}&user_id={user.id}\"\n            )\n            result = result.json()[\"result\"]\n            if \"custom_title\" in result.keys():\n                custom_title = result[\"custom_title\"]\n                text += f\"\\n\\nTitle:\\n<b>{custom_title}</b>\"\n    except BadRequest:\n        pass\n\n    for mod in USER_INFO:\n        try:\n            mod_info = mod.__user_info__(user.id).strip()\n        except TypeError:\n            mod_info = mod.__user_info__(user.id, chat.id).strip()\n        if mod_info:\n            text += \"\\n\\n\" + mod_info\n\n    if INFOPIC:\n        try:\n            profile = context.bot.get_user_profile_photos(user.id).photos[0][-1]\n            _file = bot.get_file(profile[\"file_id\"])\n            _file.download(f\"{user.id}.png\")\n\n            message.reply_document(\n                document=open(f\"{user.id}.png\", \"rb\"),\n                caption=(text),\n                parse_mode=ParseMode.HTML,\n                disable_web_page_preview=True,\n            )\n\n            os.remove(f\"{user.id}.png\")\n        # Incase user don't have profile pic, send normal text\n        except IndexError:\n            message.reply_text(\n                text, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n            )\n\n    else:\n        message.reply_text(\n            text, parse_mode=ParseMode.HTML, disable_web_page_preview=True\n        )\n\n    rep.delete()\n\n\n@run_async\ndef about_me(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    user_id = extract_user(message, args)\n\n    if user_id:\n        user = bot.get_chat(user_id)\n    else:\n        user = message.from_user\n\n    info = sql.get_user_me_info(user.id)\n\n    if info:\n        update.effective_message.reply_text(\n            f\"*{user.first_name}*:\\n{escape_markdown(info)}\",\n            parse_mode=ParseMode.MARKDOWN,\n            disable_web_page_preview=True,\n        )\n    elif message.reply_to_message:\n        username = message.reply_to_message.from_user.first_name\n        update.effective_message.reply_text(\n            f\"{username} hasn't set an info message about themselves yet!\"\n        )\n    else:\n        update.effective_message.reply_text(\"There isnt one, use /setme to set one.\")\n\n\n@run_async\ndef set_about_me(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user_id = message.from_user.id\n    if user_id in [777000, 1087968824]:\n        message.reply_text(\"Error! Unauthorized\")\n        return\n    bot = context.bot\n    if message.reply_to_message:\n        repl_message = message.reply_to_message\n        repl_user_id = repl_message.from_user.id\n        if repl_user_id in [bot.id, 777000, 1087968824] and (user_id in DEV_USERS):\n            user_id = repl_user_id\n    text = message.text\n    info = text.split(None, 1)\n    if len(info) == 2:\n        if len(info[1]) < MAX_MESSAGE_LENGTH // 4:\n            sql.set_user_me_info(user_id, info[1])\n            if user_id in [777000, 1087968824]:\n                message.reply_text(\"Authorized...Information updated!\")\n            elif user_id == bot.id:\n                message.reply_text(\"I have updated my info with the one you provided!\")\n            else:\n                message.reply_text(\"Information updated!\")\n        else:\n            message.reply_text(\n                \"The info needs to be under {} characters! You have {}.\".format(\n                    MAX_MESSAGE_LENGTH // 4, len(info[1])\n                )\n            )\n\n\n@run_async\n@sudo_plus\ndef stats(update: Update, context: CallbackContext):\n    stats = \"<b>üìä Current stats:</b>\\n\" + \"\\n\".join([mod.__stats__() for mod in STATS])\n    result = re.sub(r\"(\\d+)\", r\"<code>\\1</code>\", stats)\n    update.effective_message.reply_text(result, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef about_bio(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    user_id = extract_user(message, args)\n    if user_id:\n        user = bot.get_chat(user_id)\n    else:\n        user = message.from_user\n\n    info = sql.get_user_bio(user.id)\n\n    if info:\n        update.effective_message.reply_text(\n            \"*{}*:\\n{}\".format(user.first_name, escape_markdown(info)),\n            parse_mode=ParseMode.MARKDOWN,\n            disable_web_page_preview=True,\n        )\n    elif message.reply_to_message:\n        username = user.first_name\n        update.effective_message.reply_text(\n            f\"{username} hasn't had a message set about themselves yet!\\nSet one using /setbio\"\n        )\n    else:\n        update.effective_message.reply_text(\n            \"You haven't had a bio set about yourself yet!\"\n        )\n\n\n@run_async\ndef set_about_bio(update: Update, context: CallbackContext):\n    message = update.effective_message\n    sender_id = update.effective_user.id\n    bot = context.bot\n\n    if message.reply_to_message:\n        repl_message = message.reply_to_message\n        user_id = repl_message.from_user.id\n\n        if user_id == message.from_user.id:\n            message.reply_text(\n                \"Ha, you can't set your own bio! You're at the mercy of others here...\"\n            )\n            return\n\n        if user_id in [777000, 1087968824] and sender_id not in DEV_USERS:\n            message.reply_text(\"You are not authorised\")\n            return\n\n        if user_id == bot.id and sender_id not in DEV_USERS:\n            message.reply_text(\n                \"Erm... yeah, I only trust Heroes Association to set my bio.\"\n            )\n            return\n\n        text = message.text\n        bio = text.split(\n            None, 1\n        )  # use python's maxsplit to only remove the cmd, hence keeping newlines.\n\n        if len(bio) == 2:\n            if len(bio[1]) < MAX_MESSAGE_LENGTH // 4:\n                sql.set_user_bio(user_id, bio[1])\n                message.reply_text(\n                    \"Updated {}'s bio!\".format(repl_message.from_user.first_name)\n                )\n            else:\n                message.reply_text(\n                    \"Bio needs to be under {} characters! You tried to set {}.\".format(\n                        MAX_MESSAGE_LENGTH // 4, len(bio[1])\n                    )\n                )\n    else:\n        message.reply_text(\"Reply to someone to set their bio!\")\n\n\ndef __user_info__(user_id):\n    bio = html.escape(sql.get_user_bio(user_id) or \"\")\n    me = html.escape(sql.get_user_me_info(user_id) or \"\")\n    result = \"\"\n    if me:\n        result += f\"<b>About user:</b>\\n{me}\\n\"\n    if bio:\n        result += f\"<b>What others say:</b>\\n{bio}\\n\"\n    result = result.strip(\"\\n\")\n    return result\n\n\n__help__ = \"\"\"\n*Away from group*\n ‚ùç /afk <reason>*:* mark yourself as AFK(away from keyboard).\n ‚ùç brb <reason>*:* same as the afk command - but not a command.\nWhen marked as AFK, any mentions will be replied to with a message to say you're not available!\n\n*ID:*\n ‚ùç /id*:* get the current group id. If used by replying to a message, gets that user's id.\n ‚ùç /gifid*:* reply to a gif to me to tell you its file ID.\n\n*Self addded information:* \n ‚ùç /setme <text>*:* will set your info\n ‚ùç /me*:* will get your or another user's info.\n*Examples:* üí°\n ‚û© /setme I am a wolf.\n ‚û© /me @username(defaults to yours if no user specified)\n\n*Information others add on you:* \n ‚ùç /bio*:* will get your or another user's bio. This cannot be set by yourself.\n ‚ùç /setbio <text>*:* while replying, will save another user's bio \n*Examples:* üí°\n ‚û© /bio @username(defaults to yours if not specified).`\n ‚û© /setbio This user is a wolf` (reply to the user)\n\n*Overall Information about you:*\n ‚ùç /info*:* get information about a user. \n \n*What is that health thingy?*\n Come and see [HP System explained](https://t.me/about_zefron)\n\"\"\"\n\nSET_BIO_HANDLER = DisableAbleCommandHandler(\"setbio\", set_about_bio)\nGET_BIO_HANDLER = DisableAbleCommandHandler(\"bio\", about_bio)\n\nSTATS_HANDLER = CommandHandler(\"stats\", stats)\nID_HANDLER = DisableAbleCommandHandler(\"id\", get_id)\nGIFID_HANDLER = DisableAbleCommandHandler(\"gifid\", gifid)\nINFO_HANDLER = DisableAbleCommandHandler((\"info\", \"book\"), info)\n\nSET_ABOUT_HANDLER = DisableAbleCommandHandler(\"setme\", set_about_me)\nGET_ABOUT_HANDLER = DisableAbleCommandHandler(\"me\", about_me)\n\ndispatcher.add_handler(STATS_HANDLER)\ndispatcher.add_handler(ID_HANDLER)\ndispatcher.add_handler(GIFID_HANDLER)\ndispatcher.add_handler(INFO_HANDLER)\ndispatcher.add_handler(SET_BIO_HANDLER)\ndispatcher.add_handler(GET_BIO_HANDLER)\ndispatcher.add_handler(SET_ABOUT_HANDLER)\ndispatcher.add_handler(GET_ABOUT_HANDLER)\n\n__mod_name__ = \"Infos\"\n__command_list__ = [\"setbio\", \"bio\", \"setme\", \"me\", \"info\"]\n__handlers__ = [\n    ID_HANDLER,\n    GIFID_HANDLER,\n    INFO_HANDLER,\n    SET_BIO_HANDLER,\n    GET_BIO_HANDLER,\n    SET_ABOUT_HANDLER,\n    GET_ABOUT_HANDLER,\n    STATS_HANDLER,\n]\n","size_bytes":19308},"sitaBot/modules/sql/blsticker_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, Integer, String, UnicodeText, distinct, func\n\n\nclass StickersFilters(BASE):\n    __tablename__ = \"blacklist_stickers\"\n    chat_id = Column(String(14), primary_key=True)\n    trigger = Column(UnicodeText, primary_key=True, nullable=False)\n\n    def __init__(self, chat_id, trigger):\n        self.chat_id = str(chat_id)  # ensure string\n        self.trigger = trigger\n\n    def __repr__(self):\n        return \"<Stickers filter '%s' for %s>\" % (self.trigger, self.chat_id)\n\n    def __eq__(self, other):\n        return bool(\n            isinstance(other, StickersFilters)\n            and self.chat_id == other.chat_id\n            and self.trigger == other.trigger\n        )\n\n\nclass StickerSettings(BASE):\n    __tablename__ = \"blsticker_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    blacklist_type = Column(Integer, default=1)\n    value = Column(UnicodeText, default=\"0\")\n\n    def __init__(self, chat_id, blacklist_type=1, value=\"0\"):\n        self.chat_id = str(chat_id)\n        self.blacklist_type = blacklist_type\n        self.value = value\n\n    def __repr__(self):\n        return \"<{} will executing {} for blacklist trigger.>\".format(\n            self.chat_id, self.blacklist_type\n        )\n\n\nStickersFilters.__table__.create(checkfirst=True)\nStickerSettings.__table__.create(checkfirst=True)\n\nSTICKERS_FILTER_INSERTION_LOCK = threading.RLock()\nSTICKSET_FILTER_INSERTION_LOCK = threading.RLock()\n\nCHAT_STICKERS = {}\nCHAT_BLSTICK_BLACKLISTS = {}\n\n\ndef add_to_stickers(chat_id, trigger):\n    with STICKERS_FILTER_INSERTION_LOCK:\n        stickers_filt = StickersFilters(str(chat_id), trigger)\n\n        SESSION.merge(stickers_filt)  # merge to avoid duplicate key issues\n        SESSION.commit()\n        global CHAT_STICKERS\n        if CHAT_STICKERS.get(str(chat_id), set()) == set():\n            CHAT_STICKERS[str(chat_id)] = {trigger}\n        else:\n            CHAT_STICKERS.get(str(chat_id), set()).add(trigger)\n\n\ndef rm_from_stickers(chat_id, trigger):\n    with STICKERS_FILTER_INSERTION_LOCK:\n        stickers_filt = SESSION.query(StickersFilters).get((str(chat_id), trigger))\n        if stickers_filt:\n            if trigger in CHAT_STICKERS.get(str(chat_id), set()):  # sanity check\n                CHAT_STICKERS.get(str(chat_id), set()).remove(trigger)\n\n            SESSION.delete(stickers_filt)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef get_chat_stickers(chat_id):\n    return CHAT_STICKERS.get(str(chat_id), set())\n\n\ndef num_stickers_filters():\n    try:\n        return SESSION.query(StickersFilters).count()\n    finally:\n        SESSION.close()\n\n\ndef num_stickers_chat_filters(chat_id):\n    try:\n        return (\n            SESSION.query(StickersFilters.chat_id)\n            .filter(StickersFilters.chat_id == str(chat_id))\n            .count()\n        )\n    finally:\n        SESSION.close()\n\n\ndef num_stickers_filter_chats():\n    try:\n        return SESSION.query(func.count(distinct(StickersFilters.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef set_blacklist_strength(chat_id, blacklist_type, value):\n    # for blacklist_type\n    # 0 = nothing\n    # 1 = delete\n    # 2 = warn\n    # 3 = mute\n    # 4 = kick\n    # 5 = ban\n    # 6 = tban\n    # 7 = tmute\n    with STICKSET_FILTER_INSERTION_LOCK:\n        global CHAT_BLSTICK_BLACKLISTS\n        curr_setting = SESSION.query(StickerSettings).get(str(chat_id))\n        if not curr_setting:\n            curr_setting = StickerSettings(\n                chat_id, blacklist_type=int(blacklist_type), value=value\n            )\n\n        curr_setting.blacklist_type = int(blacklist_type)\n        curr_setting.value = str(value)\n        CHAT_BLSTICK_BLACKLISTS[str(chat_id)] = {\n            \"blacklist_type\": int(blacklist_type),\n            \"value\": value,\n        }\n\n        SESSION.add(curr_setting)\n        SESSION.commit()\n\n\ndef get_blacklist_setting(chat_id):\n    try:\n        setting = CHAT_BLSTICK_BLACKLISTS.get(str(chat_id))\n        if setting:\n            return setting[\"blacklist_type\"], setting[\"value\"]\n        else:\n            return 1, \"0\"\n\n    finally:\n        SESSION.close()\n\n\ndef __load_CHAT_STICKERS():\n    global CHAT_STICKERS\n    try:\n        chats = SESSION.query(StickersFilters.chat_id).distinct().all()\n        for (chat_id,) in chats:  # remove tuple by ( ,)\n            CHAT_STICKERS[chat_id] = []\n\n        all_filters = SESSION.query(StickersFilters).all()\n        for x in all_filters:\n            CHAT_STICKERS[x.chat_id] += [x.trigger]\n\n        CHAT_STICKERS = {x: set(y) for x, y in CHAT_STICKERS.items()}\n\n    finally:\n        SESSION.close()\n\n\ndef __load_chat_stickerset_blacklists():\n    global CHAT_BLSTICK_BLACKLISTS\n    try:\n        chats_settings = SESSION.query(StickerSettings).all()\n        for x in chats_settings:  # remove tuple by ( ,)\n            CHAT_BLSTICK_BLACKLISTS[x.chat_id] = {\n                \"blacklist_type\": x.blacklist_type,\n                \"value\": x.value,\n            }\n\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with STICKERS_FILTER_INSERTION_LOCK:\n        chat_filters = (\n            SESSION.query(StickersFilters)\n            .filter(StickersFilters.chat_id == str(old_chat_id))\n            .all()\n        )\n        for filt in chat_filters:\n            filt.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n\n__load_CHAT_STICKERS()\n__load_chat_stickerset_blacklists()\n","size_bytes":5518},"sitaBot/modules/__forcesubs.py":{"content":"# credits @InukaAsith, @Mr_dark_prince\n\nimport asyncio\nimport logging\nimport time\n\nfrom pyrogram import filters\nfrom pyrogram.errors.exceptions.bad_request_400 import (\n    ChatAdminRequired,\n    PeerIdInvalid,\n    UsernameNotOccupied,\n    UserNotParticipant,\n)\nfrom pyrogram.types import ChatPermissions, InlineKeyboardButton, InlineKeyboardMarkup\nfrom pyrogram.enums import ChatMemberStatus\n\nfrom sitaBot import DRAGONS as SUDO_USERS\nfrom sitaBot import pbot\nfrom sitaBot.modules.sql_extended import forceSubscribe_sql as sql\n\nlogging.basicConfig(level=logging.INFO)\n\nstatic_data_filter = filters.create(\n    lambda _, __, query: query.data == \"onUnMuteRequest\"\n)\n\n\n@pbot.on_callback_query(static_data_filter)\nasync def _onUnMuteRequest(client, cb):\n    user_id = cb.from_user.id\n    chat_id = cb.message.chat.id\n    chat_db = sql.fs_settings(chat_id)\n    if chat_db:\n        channel = chat_db.channel\n        try:\n            chat_member = await client.get_chat_member(chat_id, user_id)\n            if chat_member.restricted_by:\n                if chat_member.restricted_by.id == (await client.get_me()).id:\n                    try:\n                        await client.get_chat_member(channel, user_id)\n                        await client.unban_chat_member(chat_id, user_id)\n                        await cb.message.delete()\n                    except UserNotParticipant:\n                        await client.answer_callback_query(\n                            cb.id,\n                            text=f\"‚ùó Join our @{channel} channel and press 'UnMute Me' button.\",\n                            show_alert=True,\n                        )\n                else:\n                    await client.answer_callback_query(\n                        cb.id,\n                        text=\"‚ùó You have been muted by admins due to some other reason.\",\n                        show_alert=True,\n                    )\n            else:\n                me = await client.get_chat_member(chat_id, (await client.get_me()).id)\n                if me.status != ChatMemberStatus.ADMINISTRATOR:\n                    await client.send_message(\n                        chat_id,\n                        f\"‚ùó **{cb.from_user.mention} is trying to UnMute himself but i can't unmute him because i am not an admin in this chat add me as admin again.**\\n__#Leaving this chat...__\",\n                    )\n                else:\n                    await client.answer_callback_query(\n                        cb.id,\n                        text=\"‚ùó Warning! Don't press the button when you cn talk.\",\n                        show_alert=True,\n                    )\n        except Exception as e:\n            await client.answer_callback_query(cb.id, text=f\"Error: {str(e)}\", show_alert=True)\n\n\n@pbot.on_message(filters.text & ~filters.private, group=1)\nasync def _check_member(client, message):\n    chat_id = message.chat.id\n    chat_db = sql.fs_settings(chat_id)\n    if chat_db:\n        user_id = message.from_user.id\n        try:\n            user_member = await client.get_chat_member(chat_id, user_id)\n            if (\n                user_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER)\n                and user_id not in SUDO_USERS\n            ):\n                channel = chat_db.channel\n                try:\n                    await client.get_chat_member(channel, user_id)\n                except UserNotParticipant:\n                    try:\n                        sent_message = await message.reply_text(\n                            \"Welcome {} üôè \\n **You havent joined our @{} Channel yet** üò≠ \\n \\nPlease Join [Our Channel](https://t.me/{}) and hit the **UNMUTE ME** Button. \\n \\n \".format(\n                                message.from_user.mention, channel, channel\n                            ),\n                            disable_web_page_preview=True,\n                            reply_markup=InlineKeyboardMarkup(\n                                [\n                                    [\n                                        InlineKeyboardButton(\n                                            \"Join Channel\",\n                                            url=\"https://t.me/{}\".format(channel),\n                                        )\n                                    ],\n                                    [\n                                        InlineKeyboardButton(\n                                            \"UnMute Me\", callback_data=\"onUnMuteRequest\"\n                                        )\n                                    ],\n                                ]\n                            ),\n                        )\n                        await client.restrict_chat_member(\n                            chat_id, user_id, ChatPermissions(can_send_messages=False)\n                        )\n                    except ChatAdminRequired:\n                        try:\n                            await sent_message.edit(\n                                \"‚ùó **Bot is not admin here..**\\n__Give me ban permissions and retry.. \\n#Ending FSub...__\"\n                            )\n                        except:\n                            pass\n\n                except ChatAdminRequired:\n                    await client.send_message(\n                        chat_id,\n                        text=f\"‚ùó **I not an admin of @{channel} channel.**\\n__Give me admin of that channel and retry.\\n#Ending FSub...__\",\n                    )\n        except Exception:\n            pass\n\n\n@pbot.on_message(filters.command([\"forcesubscribe\", \"fsub\"]) & filters.group & ~filters.bot)\nasync def config(client, message):\n    try:\n        # Check if message has chat\n        if not message.chat:\n            return\n        \n        # Get user info\n        try:\n            user = await client.get_chat_member(message.chat.id, message.from_user.id)\n            status = getattr(user, \"status\", None)\n            is_owner = status in (ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR)\n            user_id = user.user.id if hasattr(user, 'user') else getattr(user, 'user_id', message.from_user.id)\n            \n            # Check if user is owner or admin or sudo\n            if not (is_owner or user_id in SUDO_USERS):\n                await message.reply_text(\n                    \"‚ùó **Permission Denied**\\n__You need to be group creator or admin to use this command.__\"\n                )\n                return\n        except Exception as e:\n            logging.error(f\"Error checking user permissions: {e}\")\n            await message.reply_text(f\"Error checking permissions: {str(e)}\")\n            return\n        \n        chat_id = message.chat.id\n        \n        if len(message.command) > 1:\n            input_str = message.command[1]\n            input_str = input_str.replace(\"@\", \"\").strip()\n            \n            if not input_str:\n                await message.reply_text(\"‚ùó **Please provide a channel username.**\\nUsage: `/fsub @channel_username`\")\n                return\n            \n            if input_str.lower() in (\"off\", \"no\", \"disable\"):\n                sql.disapprove(chat_id)\n                await message.reply_text(\"‚ùå **Force Subscribe is Disabled Successfully.**\")\n            elif input_str.lower() in (\"clear\",):\n                sent_message = await message.reply_text(\n                    \"**Unmuting all members who are muted by me...**\"\n                )\n                try:\n                    unmuted_count = 0\n                    me_obj = await client.get_me()\n                    async for chat_member in client.get_chat_members(\n                        message.chat.id, filter=\"restricted\"\n                    ):\n                        if chat_member.restricted_by and chat_member.restricted_by.id == me_obj.id:\n                            try:\n                                await client.unban_chat_member(chat_id, chat_member.user.id)\n                                unmuted_count += 1\n                                await asyncio.sleep(0.5)\n                            except Exception:\n                                pass\n                    await sent_message.edit(f\"‚úÖ **UnMuted {unmuted_count} member(s) who were muted by me.**\")\n                except ChatAdminRequired:\n                    await sent_message.edit(\n                        \"‚ùó **I am not an admin in this chat.**\\n__I can't unmute members because i am not an admin in this chat make me admin with ban user permission.__\"\n                    )\n                except Exception as e:\n                    await sent_message.edit(f\"‚ùó **Error:** {str(e)}\")\n            else:\n                # Add channel\n                try:\n                    # Check if bot is admin in the channel\n                    channel_username = input_str\n                    try:\n                        bot_member = await client.get_chat_member(channel_username, \"me\")\n                        if bot_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                            await message.reply_text(\n                                f\"‚ùó **Not an Admin in the Channel**\\n__I am not an admin in the [channel](https://t.me/{channel_username}). Add me as an admin in order to enable ForceSubscribe.__\",\n                                disable_web_page_preview=True,\n                            )\n                            return\n                    except UserNotParticipant:\n                        await message.reply_text(\n                            f\"‚ùó **Not an Admin in the Channel**\\n__I am not an admin in the [channel](https://t.me/{channel_username}). Add me as an admin in order to enable ForceSubscribe.__\",\n                            disable_web_page_preview=True,\n                        )\n                        return\n                    \n                    # Add channel to database\n                    sql.add_channel(chat_id, channel_username)\n                    await message.reply_text(\n                        f\"‚úÖ **Force Subscribe is Enabled**\\n__Force Subscribe is enabled, all the group members have to subscribe this [channel](https://t.me/{channel_username}) in order to send messages in this group.__\",\n                        disable_web_page_preview=True,\n                    )\n                except (UsernameNotOccupied, PeerIdInvalid):\n                    await message.reply_text(f\"‚ùó **Invalid Channel Username:** `{input_str}`\\n__Please provide a valid channel username without @.__\")\n                except Exception as err:\n                    logging.error(f\"Error setting up fsub: {err}\")\n                    await message.reply_text(f\"‚ùó **ERROR:** `{str(err)}`\")\n        else:\n            # Show current settings\n            if sql.fs_settings(chat_id):\n                channel = sql.fs_settings(chat_id).channel\n                await message.reply_text(\n                    f\"‚úÖ **Force Subscribe is enabled in this chat.**\\n__For this [Channel](https://t.me/{channel})__\\n\\nUse `/fsub disable` to turn off.\\nUse `/fsub clear` to unmute all muted members.\",\n                    disable_web_page_preview=True,\n                )\n            else:\n                await message.reply_text(\n                    \"‚ùå **Force Subscribe is disabled in this chat.**\\n\\nUse `/fsub @channel_username` to enable.\"\n                )\n    except Exception as e:\n        logging.error(f\"Error in fsub command: {e}\", exc_info=True)\n        try:\n            await message.reply_text(f\"‚ùó **Error:** `{str(e)}`\")\n        except Exception:\n            pass\n\n\n__help__ = \"\"\"\n*Force Subscribe:*\n‚ùç Sita can mute members who are not subscribed your channel until they subscribe\n‚ùç When enabled I will mute unsubscribed members and show them a unmute button. When they pressed the button I will unmute them\n*Setup*\n*Only creator*\n‚ùç Add me in your group as admin\n‚ùç Add me in your channel as admin \n \n*Commmands*\n ‚ùç /fsub {channel username} - To turn on and setup the channel.\n  üí°Do this first...\n ‚ùç /fsub - To get the current settings.\n ‚ùç /fsub disable - To turn of ForceSubscribe..\n  üí°If you disable fsub, you need to set again for working.. /fsub {channel username} \n ‚ùç /fsub clear - To unmute all members who muted by me.\n\"\"\"\n__mod_name__ = \"F-Sub\"\n","size_bytes":12253},"sitaBot/modules/__init__.py":{"content":"from sitaBot import LOAD, LOGGER, NO_LOAD\n\n\ndef __list_all_modules():\n    import glob\n    from os.path import basename, dirname, isfile\n\n    # This generates a list of modules in this folder for the * in __main__ to work.\n    mod_paths = glob.glob(dirname(__file__) + \"/*.py\")\n    all_modules = [\n        basename(f)[:-3]\n        for f in mod_paths\n        if isfile(f) and f.endswith(\".py\") and not f.endswith(\"__init__.py\")\n    ]\n\n    if LOAD or NO_LOAD:\n        to_load = LOAD\n        if to_load:\n            if not all(\n                any(mod == module_name for module_name in all_modules)\n                for mod in to_load\n            ):\n                LOGGER.error(\"Invalid loadorder names. Quitting.\")\n                quit(1)\n\n            all_modules = sorted(set(all_modules) - set(to_load))\n            to_load = list(all_modules) + to_load\n\n        else:\n            to_load = all_modules\n\n        if NO_LOAD:\n            LOGGER.info(\"Not loading: {}\".format(NO_LOAD))\n            return [item for item in to_load if item not in NO_LOAD]\n\n        return to_load\n\n    return all_modules\n\n\nALL_MODULES = __list_all_modules()\nLOGGER.info(\"Modules to load: %s\", str(ALL_MODULES))\n__all__ = ALL_MODULES + [\"ALL_MODULES\"]\n","size_bytes":1229},"sitaBot/modules/zombies.py":{"content":"import asyncio\nfrom asyncio import sleep\n\nfrom telethon import events\nfrom telethon.errors import ChatAdminRequiredError, UserAdminInvalidError\nfrom telethon.tl.functions.channels import EditBannedRequest\nfrom telethon.tl.types import ChatBannedRights, ChannelParticipantsAdmins\n\nfrom sitaBot import telethn, OWNER_ID, DEV_USERS, DRAGONS, DEMONS\n\n# =================== CONSTANT ===================\n\nBANNED_RIGHTS = ChatBannedRights(\n    until_date=None,\n    view_messages=True,\n    send_messages=True,\n    send_media=True,\n    send_stickers=True,\n    send_gifs=True,\n    send_games=True,\n    send_inline=True,\n    embed_links=True,\n)\n\n\nUNBAN_RIGHTS = ChatBannedRights(\n    until_date=None,\n    send_messages=None,\n    send_media=None,\n    send_stickers=None,\n    send_gifs=None,\n    send_games=None,\n    send_inline=None,\n    embed_links=None,\n)\n\nOFFICERS = [OWNER_ID] + DEV_USERS + DRAGONS + DEMONS\n\n# Check if user has admin rights\nasync def is_administrator(user_id: int, message):\n    admin = False\n    async for user in telethn.iter_participants(\n        message.chat_id, filter=ChannelParticipantsAdmins\n    ):\n        if user_id == user.id or user_id in OFFICERS:\n            admin = True\n            break\n    return admin\n\n\n\n@telethn.on(events.NewMessage(pattern=f\"^[!/]zombies ?(.*)\"))\nasync def zombies(event):\n    \"\"\" For .zombies command, list all the zombies in a chat. \"\"\"\n\n    con = event.pattern_match.group(1).lower()\n    del_u = 0\n    del_status = \"No Deleted Accounts Found, Group Is Clean.\"\n\n    if con != \"clean\":\n        find_zombies = await event.respond(\"Searching For Zombies...\")\n        async for user in event.client.iter_participants(event.chat_id):\n\n            if user.deleted:\n                del_u += 1\n                await sleep(1)\n        if del_u > 0:\n            del_status = f\"Found **{del_u}** Zombies In This Group.\\\n            \\nClean Them By Using - `/zombies clean`\"\n        await find_zombies.edit(del_status)\n        return\n\n    # Here laying the sanity check\n    chat = await event.get_chat()\n    admin = chat.admin_rights\n    creator = chat.creator\n\n    # Well\n    if not await is_administrator(user_id=event.from_id, message=event):\n        await event.respond(\"You're Not An Admin!\")\n        return\n\n    if not admin and not creator:\n        await event.respond(\"I Am Not An Admin Here!\")\n        return\n\n    cleaning_zombies = await event.respond(\"Cleaning Zombies...\")\n    del_u = 0\n    del_a = 0\n\n    async for user in event.client.iter_participants(event.chat_id):\n        if user.deleted:\n            try:\n                await event.client(\n                    EditBannedRequest(event.chat_id, user.id, BANNED_RIGHTS)\n                )\n            except ChatAdminRequiredError:\n                await cleaning_zombies.edit(\"I Don't Have Ban Rights In This Group.\")\n                return\n            except UserAdminInvalidError:\n                del_u -= 1\n                del_a += 1\n            await event.client(EditBannedRequest(event.chat_id, user.id, UNBAN_RIGHTS))\n            del_u += 1\n\n    if del_u > 0:\n        del_status = f\"Cleaned `{del_u}` Zombies\"\n\n    if del_a > 0:\n        del_status = f\"Cleaned `{del_u}` Zombies \\\n        \\n`{del_a}` Zombie Admin Accounts Are Not Removed!\"\n\n    await cleaning_zombies.edit(del_status)\n    \n    \nfrom telethon.tl.types import UserStatusLastMonth, UserStatusLastWeek, ChatBannedRights\nfrom sitaBot.events import register\nfrom telethon import *\nfrom telethon.tl.functions.channels import (EditBannedRequest)\n                                            \n\n@register(pattern=\"^/kickthefools\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    chat = await event.get_chat()\n    admin = chat.admin_rights\n    creator = chat.creator\n    if not event.chat.admin_rights.ban_users:\n        return\n    if not admin and not creator:\n        await event.reply(\"I am not admin here !\")\n        return\n    c = 0\n    KICK_RIGHTS = ChatBannedRights(until_date=None, view_messages=True)\n    await event.reply(\"Searching Participant Lists...\")\n    async for i in event.client.iter_participants(event.chat_id):\n\n        if isinstance(i.status, UserStatusLastMonth):\n            status = await event.client(EditBannedRequest(event.chat_id, i, KICK_RIGHTS))\n            if not status:\n               return\n            else:\n               c = c + 1\n                    \n        if isinstance(i.status, UserStatusLastMonth):\n            status = await event.client(EditBannedRequest(event.chat_id, i, KICK_RIGHTS))\n            if not status:\n               return\n            else:\n               c = c + 1                    \n\n    required_string = \"Successfully Kicked **{}** users\"\n    await event.reply(required_string.format(c))\n\n","size_bytes":4735},"sitaBot/modules/__shield.py":{"content":"#    Copyright (C) DevsExpo 2020-2021\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Affero General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Affero General Public License for more details.\n#\n#    You should have received a copy of the GNU Affero General Public License\n#    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nimport asyncio\nimport logging\nimport os\nimport re\n\nimport better_profanity\nimport emoji\n# import nude  # nudepy not available - commented out\nimport requests\nfrom better_profanity import profanity\nfrom google_trans_new import google_translator\nfrom telethon import events\nfrom telethon.tl.types import ChatBannedRights\n\nfrom sitaBot import BOT_ID\nfrom sitaBot.conf import get_int_key, get_str_key\n\n# from sitaBot.db.mongo_helpers.nsfw_guard import add_chat, get_all_nsfw_chats, is_chat_in_db, rm_chat\nfrom sitaBot.pyrogramee.telethonbasics import is_admin\nfrom sitaBot.events import register\nfrom sitaBot import MONGO_DB_URI\nfrom pymongo import MongoClient\nfrom sitaBot.modules.sql_extended.nsfw_watch_sql import (\n    add_nsfwatch,\n    get_all_nsfw_enabled_chat,\n    is_nsfwatch_indb,\n    rmnsfwatch,\n)\nfrom sitaBot import telethn as tbot, pbot\nfrom pyrogram import filters\nfrom pyrogram.enums import ChatMemberStatus\n\ntranslator = google_translator()\nMUTE_RIGHTS = ChatBannedRights(until_date=None, send_messages=False)\n\n# Extract database name from URI or default to destinymusic\n_db_name = \"destinymusic\"\nif MONGO_DB_URI and \"/\" in MONGO_DB_URI.split(\"?\")[0]:\n    try:\n        _db_name = MONGO_DB_URI.split(\"/\")[-1].split(\"?\")[0] or _db_name\n    except Exception:\n        pass\n\nclient = MongoClient(MONGO_DB_URI) if MONGO_DB_URI else None\ndb = client[_db_name] if client else None\n\nasync def is_nsfw(event):\n    lmao = event\n    if not (\n        lmao.gif\n        or lmao.video\n        or lmao.video_note\n        or lmao.photo\n        or lmao.sticker\n        or lmao.media\n    ):\n        return False\n    if lmao.video or lmao.video_note or lmao.sticker or lmao.gif:\n        try:\n            starkstark = await event.client.download_media(lmao.media, thumb=-1)\n        except:\n            return False\n    elif lmao.photo or lmao.sticker:\n        try:\n            starkstark = await event.client.download_media(lmao.media)\n        except:\n            return False\n    img = starkstark\n    f = {\"file\": (img, open(img, \"rb\"))}\n\n    r = requests.post(\"https://starkapi.herokuapp.com/nsfw/\", files=f).json()\n    if r.get(\"success\") is False:\n        is_nsfw = False\n    elif r.get(\"is_nsfw\") is True:\n        is_nsfw = True\n    elif r.get(\"is_nsfw\") is False:\n        is_nsfw = False\n    return is_nsfw\n\n\n# Pyrogram handler for gshield\n@pbot.on_message(filters.command(\"gshield\") & filters.group & ~filters.bot)\nasync def gshield_pyrogram(client, message):\n    try:\n        if not message.chat:\n            return\n        \n        # Check if bot is admin\n        try:\n            bot_member = await client.get_chat_member(message.chat.id, (await client.get_me()).id)\n            if bot_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                await message.reply_text(\"`I Should Be Admin To Do This!`\")\n                return\n        except Exception:\n            await message.reply_text(\"`I Should Be Admin To Do This!`\")\n            return\n        \n        # Check if user is admin\n        try:\n            user_member = await client.get_chat_member(message.chat.id, message.from_user.id)\n            if user_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                await message.reply_text(\"`You Should Be Admin To Do This!`\")\n                return\n        except Exception:\n            await message.reply_text(\"`You Should Be Admin To Do This!`\")\n            return\n        \n        if len(message.command) < 2:\n            await message.reply_text(\"Usage: `/gshield on` or `/gshield off`\")\n            return\n        \n        input_str = message.command[1].lower()\n        chat_id_str = str(message.chat.id)\n        \n        if input_str in (\"on\", \"enable\"):\n            if is_nsfwatch_indb(chat_id_str):\n                await message.reply_text(\"`This Chat Has Already Enabled Nsfw Watch.`\")\n                return\n            add_nsfwatch(chat_id_str)\n            await message.reply_text(\n                f\"**Added Chat {message.chat.title} With Id {message.chat.id} To Database. This Groups Nsfw Contents Will Be Deleted**\"\n            )\n        elif input_str in (\"off\", \"disable\"):\n            if not is_nsfwatch_indb(chat_id_str):\n                await message.reply_text(\"This Chat Has Not Enabled Nsfw Watch.\")\n                return\n            rmnsfwatch(chat_id_str)\n            await message.reply_text(\n                f\"**Removed Chat {message.chat.title} With Id {message.chat.id} From Nsfw Watch**\"\n            )\n        else:\n            await message.reply_text(\n                \"I understand `/gshield on` and `/gshield off` only\"\n            )\n    except Exception as e:\n        await message.reply_text(f\"Error: {str(e)}\")\n\n\n# Telethon handler (kept for compatibility)\n@tbot.on(events.NewMessage(pattern=\"/gshield (.*)\"))\nasync def nsfw_watch(event):\n    if not event.is_group:\n        await event.reply(\"You Can Only Nsfw Watch in Groups.\")\n        return\n    input_str = event.pattern_match.group(1)\n    if not await is_admin(event, BOT_ID):\n        try:\n            await event.reply(\"`I Should Be Admin To Do This!`\")\n        except Exception:\n            pass  # Ignore ChannelPrivateError or other errors\n        return\n    if await is_admin(event, event.message.sender_id):\n        if (\n            input_str == \"on\"\n            or input_str == \"On\"\n            or input_str == \"ON\"\n            or input_str == \"enable\"\n        ):\n            if is_nsfwatch_indb(str(event.chat_id)):\n                await event.reply(\"`This Chat Has Already Enabled Nsfw Watch.`\")\n                return\n            add_nsfwatch(str(event.chat_id))\n            await event.reply(\n                f\"**Added Chat {event.chat.title} With Id {event.chat_id} To Database. This Groups Nsfw Contents Will Be Deleted**\"\n            )\n        elif (\n            input_str == \"off\"\n            or input_str == \"Off\"\n            or input_str == \"OFF\"\n            or input_str == \"disable\"\n        ):\n            if not is_nsfwatch_indb(str(event.chat_id)):\n                await event.reply(\"This Chat Has Not Enabled Nsfw Watch.\")\n                return\n            rmnsfwatch(str(event.chat_id))\n            await event.reply(\n                f\"**Removed Chat {event.chat.title} With Id {event.chat_id} From Nsfw Watch**\"\n            )\n        else:\n            await event.reply(\n                \"I undestand `/gshield on` and `/gshield off` only\"\n            )\n    else:\n        await event.reply(\"`You Should Be Admin To Do This!`\")\n        return\n\n\n@tbot.on(events.NewMessage())\nasync def ws(event):\n    warner_starkz = get_all_nsfw_enabled_chat()\n    if len(warner_starkz) == 0:\n        return\n    if not is_nsfwatch_indb(str(event.chat_id)):\n        return\n    if not (event.photo):\n        return\n    if not await is_admin(event, BOT_ID):\n        return\n    if await is_admin(event, event.message.sender_id):\n        return\n    sender = await event.get_sender()\n    await event.client.download_media(event.photo, \"nudes.jpg\")\n    if nude.is_nude(\"./nudes.jpg\"):\n        await event.delete()\n        st = sender.first_name\n        hh = sender.id\n        final = f\"**NSFW DETECTED**\\n\\n{st}](tg://user?id={hh}) your message contain NSFW content.. So, Sita deleted the message\\n\\n **Nsfw Sender - User / Bot :** {st}](tg://user?id={hh})  \\n\\n`‚öîÔ∏èAutomatic Detections Powered By Sita AI` \\n**#GROUP_GUARDIAN** \"\n        dev = await event.respond(final)\n        await asyncio.sleep(10)\n        await dev.delete()\n        os.remove(\"nudes.jpg\")\n\n\n# Pyrogram NSFW filter for gshield\nasync def is_nsfw_pyrogram(client, message):\n    \"\"\"Check if message contains NSFW content using API\"\"\"\n    try:\n        if not (message.photo or message.video or message.document or message.sticker or message.animation):\n            return False\n        \n        # Download media\n        try:\n            if message.photo:\n                file_path = await message.download()\n            elif message.video or message.animation:\n                file_path = await message.download()\n            elif message.sticker:\n                file_path = await message.download()\n            elif message.document:\n                file_path = await message.download()\n            else:\n                return False\n        except Exception:\n            return False\n        \n        # Check using API\n        try:\n            with open(file_path, \"rb\") as f:\n                files = {\"file\": (os.path.basename(file_path), f, \"image/jpeg\")}\n                r = requests.post(\"https://starkapi.herokuapp.com/nsfw/\", files=files, timeout=10)\n                data = r.json() if r.status_code == 200 else {}\n                \n            # Clean up file\n            try:\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n            except Exception:\n                pass\n            \n            if data.get(\"success\") is False:\n                return False\n            elif data.get(\"is_nsfw\") is True:\n                return True\n            else:\n                return False\n        except Exception:\n            try:\n                os.remove(file_path)\n            except Exception:\n                pass\n            return False\n    except Exception:\n        return False\n\n\n@pbot.on_message(filters.media & filters.group & ~filters.private & ~filters.bot, group=2)\nasync def nsfw_filter_pyrogram(client, message):\n    \"\"\"Filter NSFW content when gshield is enabled\"\"\"\n    try:\n        # Check if gshield is enabled for this chat\n        if not is_nsfwatch_indb(str(message.chat.id)):\n            return\n        \n        # Check if bot is admin\n        try:\n            bot_member = await client.get_chat_member(message.chat.id, (await client.get_me()).id)\n            if bot_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                return\n        except Exception:\n            return\n        \n        # Skip if sender is admin\n        try:\n            user_member = await client.get_chat_member(message.chat.id, message.from_user.id)\n            if user_member.status in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                return\n        except Exception:\n            pass\n        \n        # Check for NSFW\n        is_nsfw_content = await is_nsfw_pyrogram(client, message)\n        \n        if is_nsfw_content:\n            try:\n                await message.delete()\n                \n                # Get user info\n                try:\n                    user = await client.get_users(message.from_user.id)\n                    user_name = user.first_name if user else \"Unknown\"\n                    user_id = message.from_user.id\n                except Exception:\n                    user_name = \"Unknown\"\n                    user_id = message.from_user.id\n                \n                # Send alert\n                alert_msg = (\n                    f\"**NSFW DETECTED**\\n\\n\"\n                    f\"[{user_name}](tg://user?id={user_id}) your message contains NSFW content. \"\n                    f\"So, Sita deleted the message.\\n\\n\"\n                    f\"**NSFW Sender:** [{user_name}](tg://user?id={user_id})\\n\"\n                    f\"**Chat:** {message.chat.title}\\n\\n\"\n                    f\"`‚öîÔ∏è Automatic Detections Powered By Sita AI`\\n\"\n                    f\"**#GROUP_GUARDIAN**\"\n                )\n                \n                sent_msg = await client.send_message(\n                    message.chat.id,\n                    alert_msg,\n                    disable_web_page_preview=True\n                )\n                \n                # Delete alert after 10 seconds\n                await asyncio.sleep(10)\n                try:\n                    await sent_msg.delete()\n                except Exception:\n                    pass\n            except Exception as e:\n                logging.error(f\"Error deleting NSFW content: {e}\")\n    except Exception:\n        pass\n\n\n\"\"\"\n# Old commented code - keeping for reference\n@pbot.on_message(filters.incoming & filters.media & ~filters.private & ~filters.channel & ~filters.bot)\nasync def nsfw_watch(client, message):\n    lol = get_all_nsfw_chats()\n    if len(lol) == 0:\n        message.continue_propagation()\n    if not is_chat_in_db(message.chat.id):\n        message.continue_propagation()\n    hot = await is_nsfw(client, message)\n    if not hot:\n        message.continue_propagation()\n    else:\n        try:\n            await message.delete()\n        except:\n            pass\n        lolchat = await client.get_chat(message.chat.id)\n        ctitle = lolchat.title\n        if lolchat.username:\n            hehe = lolchat.username\n        else:\n            hehe = message.chat.id\n        midhun = await client.get_users(message.from_user.id)\n        await message.delete()\n        if midhun.username:\n            Escobar = midhun.username\n        else:\n            Escobar = midhun.id\n        await client.send_message(\n            message.chat.id,\n            f\"**NSFW DETECTED**\\n\\n{hehe}'s message contain NSFW content.. So, Sita deleted the message\\n\\n **Nsfw Sender - User / Bot :** `{Escobar}` \\n**Chat Title:** `{ctitle}` \\n\\n`‚öîÔ∏èAutomatic Detections Powered By SitaAI` \\n**#GROUP_GUARDIAN** \",\n        )\n        message.continue_propagation()\n\"\"\"\n\n\n# This Module is ported from https://github.com/MissJuliaRobot/MissJuliaRobot\n# This hardwork was completely done by MissJuliaRobot\n# Full Credits goes to MissJuliaRobot\n\n\napproved_users = db.approve\nspammers = db.spammer\nglobalchat = db.globchat\n\nCMD_STARTERS = \"/\"\nprofanity.load_censor_words_from_file(\"./profanity_wordlist.txt\")\n\n\n@register(pattern=\"^/profanity(?: |$)(.*)\")\nasync def profanity(event):\n    if event.fwd_from:\n        return\n    if not event.is_group:\n        await event.reply(\"You Can Only profanity in Groups.\")\n        return\n    event.pattern_match.group(1)\n    if not await is_admin(event, BOT_ID):\n        await event.reply(\"`I Should Be Admin To Do This!`\")\n        return\n    if await is_admin(event, event.message.sender_id):\n        input = event.pattern_match.group(1)\n        chats = spammers.find({})\n        if not input:\n            for c in chats:\n                if event.chat_id == c[\"id\"]:\n                    await event.reply(\n                        \"Please provide some input yes or no.\\n\\nCurrent setting is : **on**\"\n                    )\n                    return\n            await event.reply(\n                \"Please provide some input yes or no.\\n\\nCurrent setting is : **off**\"\n            )\n            return\n        if input == \"on\":\n            if event.is_group:\n                chats = spammers.find({})\n                for c in chats:\n                    if event.chat_id == c[\"id\"]:\n                        await event.reply(\n                            \"Profanity filter is already activated for this chat.\"\n                        )\n                        return\n                spammers.insert_one({\"id\": event.chat_id})\n                await event.reply(\"Profanity filter turned on for this chat.\")\n        if input == \"off\":\n            if event.is_group:\n                chats = spammers.find({})\n                for c in chats:\n                    if event.chat_id == c[\"id\"]:\n                        spammers.delete_one({\"id\": event.chat_id})\n                        await event.reply(\"Profanity filter turned off for this chat.\")\n                        return\n            await event.reply(\"Profanity filter isn't turned on for this chat.\")\n        if not input == \"on\" and not input == \"off\":\n            await event.reply(\"I only understand by on or off\")\n            return\n    else:\n        await event.reply(\"`You Should Be Admin To Do This!`\")\n        return\n\n\n@register(pattern=\"^/globalmode(?: |$)(.*)\")\nasync def profanity(event):\n    if event.fwd_from:\n        return\n    if not event.is_group:\n        await event.reply(\"You Can Only enable global mode Watch in Groups.\")\n        return\n    event.pattern_match.group(1)\n    if not await is_admin(event, BOT_ID):\n        await event.reply(\"`I Should Be Admin To Do This!`\")\n        return\n    if await is_admin(event, event.message.sender_id):\n\n        input = event.pattern_match.group(1)\n        chats = globalchat.find({})\n        if not input:\n            for c in chats:\n                if event.chat_id == c[\"id\"]:\n                    await event.reply(\n                        \"Please provide some input yes or no.\\n\\nCurrent setting is : **on**\"\n                    )\n                    return\n            await event.reply(\n                \"Please provide some input yes or no.\\n\\nCurrent setting is : **off**\"\n            )\n            return\n        if input == \"on\":\n            if event.is_group:\n                chats = globalchat.find({})\n                for c in chats:\n                    if event.chat_id == c[\"id\"]:\n                        await event.reply(\n                            \"Global mode is already activated for this chat.\"\n                        )\n                        return\n                globalchat.insert_one({\"id\": event.chat_id})\n                await event.reply(\"Global mode turned on for this chat.\")\n        if input == \"off\":\n            if event.is_group:\n                chats = globalchat.find({})\n                for c in chats:\n                    if event.chat_id == c[\"id\"]:\n                        globalchat.delete_one({\"id\": event.chat_id})\n                        await event.reply(\"Global mode turned off for this chat.\")\n                        return\n            await event.reply(\"Global mode isn't turned on for this chat.\")\n        if not input == \"on\" and not input == \"off\":\n            await event.reply(\"I only understand by on or off\")\n            return\n    else:\n        await event.reply(\"`You Should Be Admin To Do This!`\")\n        return\n\n\n# Pyrogram handler for /profanity command\n@pbot.on_message(filters.command(\"profanity\") & filters.group & ~filters.bot)\nasync def profanity_command_pyrogram(client, message):\n    \"\"\"Enable/disable profanity filter\"\"\"\n    try:\n        if not message.chat:\n            return\n        \n        # Check if user is admin\n        try:\n            user_member = await client.get_chat_member(message.chat.id, message.from_user.id)\n            if user_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                await message.reply_text(\"‚ùó **You need to be admin to use this command.**\")\n                return\n        except Exception:\n            await message.reply_text(\"‚ùó **You need to be admin to use this command.**\")\n            return\n        \n        if len(message.command) < 2:\n            # Check current status\n            chat_id = message.chat.id\n            chats = spammers.find({})\n            is_enabled = False\n            for c in chats:\n                if c.get(\"id\") == chat_id:\n                    is_enabled = True\n                    break\n            \n            status_text = \"**on**\" if is_enabled else \"**off**\"\n            await message.reply_text(\n                f\"**Profanity Filter Status:** {status_text}\\n\\n\"\n                f\"Usage: `/profanity on` or `/profanity off`\"\n            )\n            return\n        \n        input_str = message.command[1].lower()\n        chat_id = message.chat.id\n        \n        if input_str == \"on\":\n            chats = spammers.find({})\n            for c in chats:\n                if c.get(\"id\") == chat_id:\n                    await message.reply_text(\"‚úÖ **Profanity filter is already enabled for this chat.**\")\n                    return\n            spammers.insert_one({\"id\": chat_id})\n            await message.reply_text(\"‚úÖ **Profanity filter turned on for this chat.**\")\n        elif input_str == \"off\":\n            chats = spammers.find({})\n            found = False\n            for c in chats:\n                if c.get(\"id\") == chat_id:\n                    spammers.delete_one({\"id\": chat_id})\n                    found = True\n                    break\n            if found:\n                await message.reply_text(\"‚ùå **Profanity filter turned off for this chat.**\")\n            else:\n                await message.reply_text(\"‚ùå **Profanity filter isn't enabled for this chat.**\")\n        else:\n            await message.reply_text(\"‚ùó **I only understand `on` or `off`**\\nUsage: `/profanity on` or `/profanity off`\")\n    except Exception as e:\n        logging.error(f\"Error in profanity command: {e}\")\n        await message.reply_text(f\"‚ùó **Error:** {str(e)}\")\n\n\n# Pyrogram profanity filter\n@pbot.on_message(filters.text & filters.group & ~filters.private & ~filters.bot, group=3)\nasync def profanity_filter_pyrogram(client, message):\n    \"\"\"Filter profanity words when profanity filter is enabled\"\"\"\n    try:\n        if not message.text or not message.chat:\n            return\n        \n        # Check if profanity filter is enabled for this chat\n        chat_id_str = str(message.chat.id)\n        chats = spammers.find({})\n        is_enabled = False\n        for c in chats:\n            if str(c.get(\"id\")) == chat_id_str:\n                is_enabled = True\n                break\n        \n        if not is_enabled:\n            return\n        \n        # Check if bot is admin\n        try:\n            bot_member = await client.get_chat_member(message.chat.id, (await client.get_me()).id)\n            if bot_member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                return\n        except Exception:\n            return\n        \n        # Skip if sender is admin\n        try:\n            user_member = await client.get_chat_member(message.chat.id, message.from_user.id)\n            if user_member.status in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):\n                return\n        except Exception:\n            pass\n        \n        # Check for profanity\n        msg_text = str(message.text)\n        if better_profanity.profanity.contains_profanity(msg_text):\n            try:\n                await message.delete()\n                \n                # Get user info\n                try:\n                    user = await client.get_users(message.from_user.id)\n                    user_name = user.first_name if user else \"Unknown\"\n                    user_id = message.from_user.id\n                except Exception:\n                    user_name = \"Unknown\"\n                    user_id = message.from_user.id\n                \n                # Send alert message\n                alert_msg = (\n                    f\"[{user_name}](tg://user?id={user_id}) your message **`{msg_text[:50]}...`** \"\n                    f\"contains profanity/slang words and has been deleted.\\n\\n\"\n                    f\"**Reason:** Profanity filter is enabled in this chat.\"\n                )\n                \n                sent_msg = await message.reply_text(\n                    alert_msg,\n                    disable_web_page_preview=True\n                )\n                \n                # Delete alert after 10 seconds\n                await asyncio.sleep(10)\n                try:\n                    await sent_msg.delete()\n                except Exception:\n                    pass\n            except Exception as e:\n                logging.error(f\"Error deleting profanity message: {e}\")\n    except Exception:\n        pass\n\n\n@tbot.on(events.NewMessage(pattern=None))\nasync def del_profanity(event):\n    if event.is_private:\n        return\n    msg = str(event.text)\n    sender = await event.get_sender()\n    # let = sender.username\n    if await is_admin(event, event.message.sender_id):\n        return\n    chats = spammers.find({})\n    for c in chats:\n        if event.text:\n            if event.chat_id == c[\"id\"]:\n                if better_profanity.profanity.contains_profanity(msg):\n                    await event.delete()\n                    if sender.username is None:\n                        st = sender.first_name\n                        hh = sender.id\n                        final = f\"[{st}](tg://user?id={hh}) **{msg}** is detected as a slang word and your message has been deleted\"\n                    else:\n                        final = f\"Sir **{msg}** is detected as a slang word and your message has been deleted\"\n                    dev = await event.respond(final)\n                    await asyncio.sleep(10)\n                    await dev.delete()\n        if event.photo:\n            if event.chat_id == c[\"id\"]:\n                await event.client.download_media(event.photo, \"nudes.jpg\")\n                if nude.is_nude(\"./nudes.jpg\"):\n                    await event.delete()\n                    st = sender.first_name\n                    hh = sender.id\n                    final = f\"**NSFW DETECTED**\\n\\n{st}](tg://user?id={hh}) your message contain NSFW content.. So, Sita deleted the message\\n\\n **Nsfw Sender - User / Bot :** {st}](tg://user?id={hh})  \\n\\n`‚öîÔ∏èAutomatic Detections Powered By Sita AI` \\n**#GROUP_GUARDIAN** \"\n                    dev = await event.respond(final)\n                    await asyncio.sleep(10)\n                    await dev.delete()\n                    os.remove(\"nudes.jpg\")\n\n\ntry:\n    from emoji import EMOJI_DATA as EMOJI_MAP\nexcept Exception:\n    try:\n        from emoji import UNICODE_EMOJI as EMOJI_MAP\n    except Exception:\n        EMOJI_MAP = {}\n\ndef extract_emojis(s):\n    return \"\".join(c for c in s if c in EMOJI_MAP)\n\n\n@tbot.on(events.NewMessage(pattern=None))\nasync def del_profanity(event):\n    if event.is_private:\n        return\n    msg = str(event.text)\n    sender = await event.get_sender()\n    # sender.username\n    if await is_admin(event, event.message.sender_id):\n        return\n    chats = globalchat.find({})\n    for c in chats:\n        if event.text:\n            if event.chat_id == c[\"id\"]:\n                u = msg.split()\n                emj = extract_emojis(msg)\n                msg = msg.replace(emj, \"\")\n                if (\n                    [(k) for k in u if k.startswith(\"@\")]\n                    and [(k) for k in u if k.startswith(\"#\")]\n                    and [(k) for k in u if k.startswith(\"/\")]\n                    and re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []\n                ):\n                    h = \" \".join(filter(lambda x: x[0] != \"@\", u))\n                    km = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", h)\n                    tm = km.split()\n                    jm = \" \".join(filter(lambda x: x[0] != \"#\", tm))\n                    hm = jm.split()\n                    rm = \" \".join(filter(lambda x: x[0] != \"/\", hm))\n                elif [(k) for k in u if k.startswith(\"@\")]:\n                    rm = \" \".join(filter(lambda x: x[0] != \"@\", u))\n                elif [(k) for k in u if k.startswith(\"#\")]:\n                    rm = \" \".join(filter(lambda x: x[0] != \"#\", u))\n                elif [(k) for k in u if k.startswith(\"/\")]:\n                    rm = \" \".join(filter(lambda x: x[0] != \"/\", u))\n                elif re.findall(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", msg) != []:\n                    rm = re.sub(r\"\\[([^]]+)]\\(\\s*([^)]+)\\s*\\)\", r\"\", msg)\n                else:\n                    rm = msg\n                # print (rm)\n                b = translator.detect(rm)\n                if not \"en\" in b and not b == \"\":\n                    await event.delete()\n                    st = sender.first_name\n                    hh = sender.id\n                    final = f\"[{st}](tg://user?id={hh}) you should only speak in english here !\"\n                    dev = await event.respond(final)\n                    await asyncio.sleep(10)\n                    await dev.delete()\n#\n\n__help__ = \"\"\"\n<b> Group Guardian: </b>\n‚ú™ Layla can protect your group from NSFW senders, Slag word users and also can force members to use English\n\n<b>Commmands</b>\n - /gshield <i>on/off</i> - Enable|Disable Porn cleaning\n - /globalmode <i>on/off</i> - Enable|Disable English only mode\n - /profanity <i>on/off</i> - Enable|Disable slag word cleaning\n \nNote: Special credits goes to Julia project and Friday Userbot\n \n\"\"\"\n__mod_name__ = \"Shield\"\n","size_bytes":28715},"sitaBot/modules/economy.py":{"content":"import random\nfrom datetime import datetime, timedelta\nfrom telegram import Update, ParseMode\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin\nfrom sitaBot.modules.sql import economy_sql as sql\n\nITEMS = {\n    \"rose\": {\"emoji\": \"üåπ\", \"price\": 500, \"name\": \"Rose\"},\n    \"chocolate\": {\"emoji\": \"üç´\", \"price\": 800, \"name\": \"Chocolate\"},\n    \"ring\": {\"emoji\": \"üíç\", \"price\": 2000, \"name\": \"Ring\"},\n    \"teddy\": {\"emoji\": \"üß∏\", \"price\": 1500, \"name\": \"Teddy Bear\"},\n    \"pizza\": {\"emoji\": \"üçï\", \"price\": 600, \"name\": \"Pizza\"},\n    \"surprise\": {\"emoji\": \"üéÅ\", \"price\": 2500, \"name\": \"Surprise Box\"},\n    \"puppy\": {\"emoji\": \"üê∂\", \"price\": 3000, \"name\": \"Puppy\"},\n    \"cake\": {\"emoji\": \"üéÇ\", \"price\": 1000, \"name\": \"Cake\"},\n    \"letter\": {\"emoji\": \"üíå\", \"price\": 400, \"name\": \"Love Letter\"},\n    \"cat\": {\"emoji\": \"üê±\", \"price\": 2500, \"name\": \"Cat\"},\n}\n\n\n@run_async\ndef balance(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if message.reply_to_message:\n        target_user = message.reply_to_message.from_user\n        user_id = target_user.id\n        name = target_user.first_name\n    else:\n        user_id = user.id\n        name = user.first_name\n    \n    balance = sql.get_balance(user_id, chat.id)\n    message.reply_text(f\"üí∞ {name}'s Balance: ${balance}\")\n\n\n@run_async\ndef top_rich(update: Update, context: CallbackContext):\n    users = sql.get_top_rich(10)\n    \n    if not users:\n        update.effective_message.reply_text(\"üìä No economy data yet!\")\n        return\n    \n    text = \"üåç <b>Top 10 Richest Users</b>\\n\\n\"\n    for i, user_eco in enumerate(users, 1):\n        medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n        text += f\"{medal} User {user_eco.user_id}: ${user_eco.balance}\\n\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef top_killers(update: Update, context: CallbackContext):\n    users = sql.get_top_killers(10)\n    \n    if not users:\n        update.effective_message.reply_text(\"‚öîÔ∏è No kill data yet!\")\n        return\n    \n    text = \"‚ò†Ô∏è <b>Top 10 Killers</b>\\n\\n\"\n    for i, user_eco in enumerate(users, 1):\n        if user_eco.kills == 0:\n            continue\n        medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n        text += f\"{medal} User {user_eco.user_id}: {user_eco.kills} kills\\n\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef my_rank(update: Update, context: CallbackContext):\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    rank = sql.get_user_rank(user.id, chat.id)\n    balance = sql.get_balance(user.id, chat.id)\n    \n    if rank:\n        update.effective_message.reply_text(f\"üèÜ Your Global Rank: #{rank}\\nüí∞ Balance: ${balance}\")\n    else:\n        update.effective_message.reply_text(\"You haven't joined the economy yet!\")\n\n\n@run_async\ndef rob(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not message.reply_to_message:\n        message.reply_text(\"‚ùå Reply to a user to rob them!\")\n        return\n    \n    target = message.reply_to_message.from_user\n    \n    if target.id == user.id:\n        message.reply_text(\"‚ùå You can't rob yourself!\")\n        return\n    \n    if target.is_bot:\n        message.reply_text(\"‚ùå You can't rob bots!\")\n        return\n    \n    if sql.is_dead(user.id, chat.id):\n        message.reply_text(\"üíÄ You're dead! Use /revive to come back.\")\n        return\n    \n    if sql.is_protected(target.id, chat.id):\n        message.reply_text(\"üõ°Ô∏è This user is protected!\")\n        return\n    \n    if sql.is_dead(target.id, chat.id):\n        message.reply_text(\"üíÄ They're already dead!\")\n        return\n    \n    if context.args:\n        try:\n            amount = int(context.args[0].replace(\"$\", \"\").replace(\",\", \"\"))\n        except ValueError:\n            message.reply_text(\"‚ùå Invalid amount!\")\n            return\n    else:\n        message.reply_text(\"‚ùå Usage: /rob <amount> (reply to user)\")\n        return\n    \n    if amount <= 0:\n        message.reply_text(\"‚ùå Amount must be positive!\")\n        return\n    \n    target_balance = sql.get_balance(target.id, chat.id)\n    \n    if target_balance < amount:\n        message.reply_text(f\"‚ùå They don't have ${amount}!\")\n        return\n    \n    success = random.choice([True, False])\n    \n    if success:\n        sql.update_balance(user.id, chat.id, amount)\n        sql.update_balance(target.id, chat.id, -amount)\n        message.reply_text(f\"ü¶π‚Äç‚ôÇÔ∏è Success! You robbed ${amount} from {target.first_name}!\")\n    else:\n        penalty = amount // 4\n        robber_balance = sql.get_balance(user.id, chat.id)\n        \n        if robber_balance >= penalty:\n            sql.update_balance(user.id, chat.id, -penalty)\n            sql.update_balance(target.id, chat.id, penalty)\n            message.reply_text(f\"‚ùå Rob failed! You paid ${penalty} to {target.first_name}!\")\n        else:\n            message.reply_text(f\"‚ùå Rob failed! You don't have enough for the penalty.\")\n\n\n@run_async\ndef kill(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not message.reply_to_message:\n        message.reply_text(\"‚ùå Reply to a user to kill them!\")\n        return\n    \n    target = message.reply_to_message.from_user\n    \n    if target.id == user.id:\n        message.reply_text(\"‚ùå You can't kill yourself!\")\n        return\n    \n    if target.is_bot:\n        message.reply_text(\"‚ùå You can't kill bots!\")\n        return\n    \n    if sql.is_dead(user.id, chat.id):\n        message.reply_text(\"üíÄ You're dead! Use /revive to come back.\")\n        return\n    \n    if sql.is_protected(target.id, chat.id):\n        message.reply_text(\"üõ°Ô∏è This user is protected!\")\n        return\n    \n    if sql.is_dead(target.id, chat.id):\n        message.reply_text(\"üíÄ They're already dead!\")\n        return\n    \n    success = random.random() < 0.6\n    \n    if success:\n        sql.kill_user(target.id, chat.id, user.id)\n        target_balance = sql.get_balance(target.id, chat.id)\n        stolen = target_balance // 10\n        \n        # Random reward between 200-400 for successful kill\n        kill_reward = random.randint(200, 400)\n        sql.update_balance(user.id, chat.id, kill_reward)\n        \n        if stolen > 0:\n            sql.update_balance(target.id, chat.id, -stolen)\n            sql.update_balance(user.id, chat.id, stolen)\n            message.reply_text(f\"üíÄ You killed {target.first_name} and stole ${stolen}!\\nüí∞ Kill Reward: +${kill_reward}\\n\\nThey can /revive or wait 5 hours.\")\n        else:\n            message.reply_text(f\"üíÄ You killed {target.first_name}!\\nüí∞ Kill Reward: +${kill_reward}\\n\\nThey can /revive or wait 5 hours.\")\n    else:\n        message.reply_text(f\"‚ùå Kill attempt failed! {target.first_name} got away.\")\n\n\n@run_async\ndef revive(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if message.reply_to_message:\n        target = message.reply_to_message.from_user\n        user_id = target.id\n        name = target.first_name\n    else:\n        user_id = user.id\n        name = user.first_name\n    \n    if not sql.is_dead(user_id, chat.id):\n        message.reply_text(f\"‚ù§Ô∏è {name} is not dead!\")\n        return\n    \n    cost = 200\n    payer_balance = sql.get_balance(user.id, chat.id)\n    \n    if payer_balance < cost:\n        message.reply_text(f\"‚ùå Revive costs ${cost}. You only have ${payer_balance}.\")\n        return\n    \n    sql.update_balance(user.id, chat.id, -cost)\n    sql.revive_user(user_id, chat.id)\n    message.reply_text(f\"‚ù§Ô∏è {name} has been revived! Cost: ${cost}\")\n\n\n@run_async\ndef protect(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not context.args:\n        message.reply_text(\"‚ùå Usage: /protect <1d|2d>\\n\\nüõ°Ô∏è Protection Prices:\\n1 day = $100\\n2 days = $500\")\n        return\n    \n    duration = context.args[0].lower()\n    \n    if duration == \"1d\":\n        cost = 100\n        days = 1\n    elif duration == \"2d\":\n        cost = 500\n        days = 2\n    else:\n        message.reply_text(\"‚ùå Use: /protect 1d or /protect 2d\")\n        return\n    \n    balance = sql.get_balance(user.id, chat.id)\n    \n    if balance < cost:\n        message.reply_text(f\"‚ùå Protection costs ${cost}. You only have ${balance}.\")\n        return\n    \n    sql.update_balance(user.id, chat.id, -cost)\n    sql.protect_user(user.id, chat.id, days)\n    message.reply_text(f\"üõ°Ô∏è You are protected for {days} day(s)! Cost: ${cost}\")\n\n\n@run_async\ndef give_money(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not message.reply_to_message:\n        message.reply_text(\"‚ùå Reply to a user to give them money!\")\n        return\n    \n    target = message.reply_to_message.from_user\n    \n    if target.id == user.id:\n        message.reply_text(\"‚ùå You can't give money to yourself!\")\n        return\n    \n    if not context.args:\n        message.reply_text(\"‚ùå Usage: /give <amount> (reply to user)\\n\\n‚ö†Ô∏è Note: 10% tax will be deducted!\")\n        return\n    \n    try:\n        amount = int(context.args[0].replace(\"$\", \"\").replace(\",\", \"\"))\n    except ValueError:\n        message.reply_text(\"‚ùå Invalid amount!\")\n        return\n    \n    if amount <= 0:\n        message.reply_text(\"‚ùå Amount must be positive!\")\n        return\n    \n    tax = amount // 10\n    total_cost = amount + tax\n    \n    balance = sql.get_balance(user.id, chat.id)\n    \n    if balance < total_cost:\n        message.reply_text(f\"‚ùå You need ${total_cost} (${amount} + ${tax} tax). You only have ${balance}.\")\n        return\n    \n    sql.update_balance(user.id, chat.id, -total_cost)\n    sql.update_balance(target.id, chat.id, amount)\n    message.reply_text(f\"üéÅ You gave ${amount} to {target.first_name}!\\nüí∏ Tax paid: ${tax}\")\n\n\n@run_async\ndef economy_help(update: Update, context: CallbackContext):\n    text = \"\"\"üí∞ <b>Sita's Economy System</b>\n\nEarn virtual money by robbing, killing and playing lottery game. Most commands work only in groups.\n\n‚ö° All users will get $50 after every 12 hours!\n\nüìå <b>Commands:</b>\n\n/bal ‚Äî Your/your friend's balance üíµ\n/toprich ‚Äî Top 10 richest globally üåç\n/rob (reply) &lt;amount&gt; ‚Äî Rob money ü¶π‚Äç‚ôÇÔ∏è\n/kill (reply) ‚Äî Kill someone üíÄ\n/protect &lt;1d|2d&gt; ‚Äî Protect yourself üõ°Ô∏è\n/revive (reply or no reply) ‚Äî Revive yourself or a friend ‚ù§Ô∏è\n/give (reply) &lt;amount&gt; ‚Äî Give money üéÅ\n/myrank ‚Äî Show global rank üèÜ\n/topkill ‚Äî Top 10 killers ‚ò†Ô∏è\n\nüîí <b>Protection Rules:</b>\n\nProtected users cannot be robbed or killed.\nDead users auto-revive after 5 hours, or use /revive to come back sooner.\n\n1-day protection = $100 üí∞ | 2-day = $500 üí∞üí∞\nRevive cost = $200 üí∞\n\n‚ö†Ô∏è Note: This is all virtual fun, no real money is involved! üéâ\"\"\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef items_list(update: Update, context: CallbackContext):\n    text = \"üõçÔ∏è <b>Available Items</b>\\n\\n\"\n    \n    for key, item in ITEMS.items():\n        text += f\"{item['emoji']} {item['name']} ‚Äî ${item['price']}\\n\"\n    \n    text += \"\\nüí° Use /gift &lt;item&gt; to gift items to friends!\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef inventory(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    \n    if message.reply_to_message:\n        target_user = message.reply_to_message.from_user\n        user_id = target_user.id\n        name = target_user.first_name\n    else:\n        user_id = user.id\n        name = \"Your\"\n    \n    items = sql.get_inventory(user_id)\n    \n    if not items:\n        message.reply_text(f\"üì¶ {name} inventory is empty!\")\n        return\n    \n    text = f\"üì¶ <b>{name} Inventory</b>\\n\\n\"\n    for item in items:\n        for key, item_data in ITEMS.items():\n            if item_data['name'].lower() == item.item_name.lower():\n                text += f\"{item_data['emoji']} {item.item_name} x{item.quantity}\\n\"\n                break\n        else:\n            text += f\"‚Ä¢ {item.item_name} x{item.quantity}\\n\"\n    \n    message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef gift_item(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not message.reply_to_message:\n        message.reply_text(\"‚ùå Reply to a user to gift them an item!\")\n        return\n    \n    target = message.reply_to_message.from_user\n    \n    if target.id == user.id:\n        message.reply_text(\"‚ùå You can't gift yourself!\")\n        return\n    \n    if not context.args:\n        message.reply_text(\"‚ùå Usage: /gift <item name> (reply to user)\\n\\nUse /items to see available items.\")\n        return\n    \n    item_search = \" \".join(context.args).lower()\n    \n    item_key = None\n    for key, item_data in ITEMS.items():\n        if item_search in item_data['name'].lower() or item_search in key:\n            item_key = key\n            break\n    \n    if not item_key:\n        message.reply_text(\"‚ùå Item not found! Use /items to see available items.\")\n        return\n    \n    item = ITEMS[item_key]\n    \n    balance = sql.get_balance(user.id, chat.id)\n    if balance < item['price']:\n        message.reply_text(f\"‚ùå {item['emoji']} {item['name']} costs ${item['price']}. You only have ${balance}.\")\n        return\n    \n    sql.update_balance(user.id, chat.id, -item['price'])\n    sql.add_item(target.id, item['name'], 1)\n    \n    message.reply_text(f\"üéÅ You gifted {item['emoji']} {item['name']} to {target.first_name}!\\nüí∞ Cost: ${item['price']}\")\n\n\n@run_async\ndef new_lottery(update: Update, context: CallbackContext):\n    active = sql.get_active_lottery()\n    \n    if active:\n        time_left = active.end_time - datetime.utcnow()\n        hours = int(time_left.total_seconds() // 3600)\n        update.effective_message.reply_text(f\"‚ùå A lottery is already running! Time left: {hours}h\")\n        return\n    \n    lottery_id = sql.create_lottery()\n    \n    if lottery_id:\n        update.effective_message.reply_text(\n            \"üé∞ <b>New Lottery Started!</b>\\n\\n\"\n            \"Duration: 2 days\\n\"\n            \"Minimum ticket: $1000\\n\\n\"\n            \"Use /buy &lt;amount&gt; to join!\\n\"\n            \"Use /status to check progress\",\n            parse_mode=ParseMode.HTML\n        )\n    else:\n        update.effective_message.reply_text(\"‚ùå Failed to create lottery!\")\n\n\n@run_async\ndef buy_ticket(update: Update, context: CallbackContext):\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    lottery = sql.get_active_lottery()\n    \n    if not lottery:\n        message.reply_text(\"‚ùå No active lottery! Use /new to start one.\")\n        return\n    \n    if not context.args:\n        message.reply_text(\"‚ùå Usage: /buy <amount>\\n\\nMinimum: $1000\")\n        return\n    \n    try:\n        amount = int(context.args[0].replace(\"$\", \"\").replace(\",\", \"\"))\n    except ValueError:\n        message.reply_text(\"‚ùå Invalid amount!\")\n        return\n    \n    if amount < 1000:\n        message.reply_text(\"‚ùå Minimum ticket is $1000!\")\n        return\n    \n    balance = sql.get_balance(user.id, chat.id)\n    \n    if balance < amount:\n        message.reply_text(f\"‚ùå You need ${amount}. You only have ${balance}.\")\n        return\n    \n    if not sql.join_lottery(lottery.lottery_id, user.id, amount):\n        message.reply_text(\"‚ùå You already joined this lottery!\")\n        return\n    \n    sql.update_balance(user.id, chat.id, -amount)\n    message.reply_text(f\"üé∞ You joined the lottery with ${amount}!\\n\\nUse /status to check progress.\")\n\n\n@run_async\ndef lottery_status(update: Update, context: CallbackContext):\n    lottery = sql.get_active_lottery()\n    \n    if not lottery:\n        update.effective_message.reply_text(\"‚ùå No active lottery!\")\n        return\n    \n    participants = sql.get_lottery_participants(lottery.lottery_id)\n    \n    time_left = lottery.end_time - datetime.utcnow()\n    hours = int(time_left.total_seconds() // 3600)\n    \n    text = f\"\"\"üé∞ <b>Lottery Status</b>\n\nüí∞ Total Jackpot: ${lottery.total_pool}\nüë• Participants: {len(participants)}\n‚è∞ Time Left: {hours} hours\n\nüèÜ <b>Prizes:</b>\nü•á 1st Place ‚Üí ${lottery.total_pool * 10}\nü•à 2nd Place ‚Üí ${lottery.total_pool * 5}\nü•â 3rd Place ‚Üí ${lottery.total_pool * 3}\n\n‚ö†Ô∏è Minimum 3 participants required!\"\"\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef lottery_game(update: Update, context: CallbackContext):\n    text = \"\"\"üé∞ <b>Lottery Game Info</b>\n\n‚öôÔ∏è <b>How It Works</b>\n\nA new lottery runs for 2 days.\nUse /buy &lt;amount&gt; to join the lottery (minimum ticket = $1000).\nAt the end, 3 winners are randomly selected.\n\nüèÜ <b>Prizes</b>\n\nü•á 1st Place ‚Üí amount √ó 10\nü•à 2nd Place ‚Üí amount √ó 5\nü•â 3rd Place ‚Üí amount √ó 3\n\nüìå <b>Commands</b>\n\n/new ‚Üí Start a new lottery (only if none running)\n/buy &lt;amount&gt; ‚Üí Join the active lottery\n/status ‚Üí Check players, jackpot & time left\n/game ‚Üí Game info & rules\n\n‚ö†Ô∏è <b>Rules</b>\n\n‚Ä¢ Minimum 3 participants required, otherwise all money is refunded\n‚Ä¢ Each player can join only once per lottery\"\"\"\n    \n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef daily(update: Update, context: CallbackContext):\n    user = update.effective_user\n    chat = update.effective_chat\n    \n    if not sql.can_claim_daily(user.id):\n        update.effective_message.reply_text(\"‚ùå You already claimed your daily bonus! Wait 12 hours.\")\n        return\n    \n    balance_before = sql.get_balance(user.id, chat.id)\n    is_new_user = (balance_before == 0)\n    \n    if is_new_user:\n        sql.update_balance(user.id, chat.id, 100)\n        update.effective_message.reply_text(\"‚ö° Daily bonus claimed! +$50\\nüéâ Welcome bonus! +$50\\n\\nüí∞ Total received: $100\")\n    else:\n        sql.update_balance(user.id, chat.id, 50)\n        update.effective_message.reply_text(\"‚ö° Daily bonus claimed! +$50\")\n    \n    sql.update_daily(user.id)\n\n\ndispatcher.add_handler(CommandHandler(\"bal\", balance))\ndispatcher.add_handler(CommandHandler(\"balance\", balance))\ndispatcher.add_handler(CommandHandler(\"toprich\", top_rich))\ndispatcher.add_handler(CommandHandler(\"topkill\", top_killers))\ndispatcher.add_handler(CommandHandler(\"myrank\", my_rank))\ndispatcher.add_handler(CommandHandler(\"rob\", rob))\ndispatcher.add_handler(CommandHandler(\"kill\", kill))\ndispatcher.add_handler(CommandHandler(\"revive\", revive))\ndispatcher.add_handler(CommandHandler(\"protect\", protect))\ndispatcher.add_handler(CommandHandler(\"give\", give_money))\ndispatcher.add_handler(CommandHandler(\"economy\", economy_help))\ndispatcher.add_handler(CommandHandler(\"items\", items_list))\ndispatcher.add_handler(CommandHandler(\"item\", inventory))\ndispatcher.add_handler(CommandHandler(\"inventory\", inventory))\ndispatcher.add_handler(CommandHandler(\"gift\", gift_item))\ndispatcher.add_handler(CommandHandler(\"new\", new_lottery))\ndispatcher.add_handler(CommandHandler(\"buy\", buy_ticket))\ndispatcher.add_handler(CommandHandler(\"status\", lottery_status))\ndispatcher.add_handler(CommandHandler(\"game\", lottery_game))\ndispatcher.add_handler(CommandHandler(\"daily\", daily))\n\n__mod_name__ = \"Economy\"\n__help__ = \"\"\"\nüí∞ Economy System - Earn, rob, kill, and play lottery!\n\nCommands:\n ‚Ä¢ `/bal` - Check balance\n ‚Ä¢ `/toprich` - Top 10 richest\n ‚Ä¢ `/topkill` - Top 10 killers\n ‚Ä¢ `/myrank` - Your global rank\n ‚Ä¢ `/rob` <amount> - Rob someone (reply)\n ‚Ä¢ `/kill` - Kill someone (reply)\n ‚Ä¢ `/revive` - Revive yourself or someone (reply)\n ‚Ä¢ `/protect` <1d|2d> - Buy protection\n ‚Ä¢ `/give` <amount> - Give money (reply, 10% tax)\n ‚Ä¢ `/economy` - Full economy guide\n ‚Ä¢ `/items` - See all items\n ‚Ä¢ `/item` - Check inventory\n ‚Ä¢ `/gift` <item> - Gift an item (reply)\n ‚Ä¢ `/new` - Start new lottery\n ‚Ä¢ `/buy` <amount> - Join lottery\n ‚Ä¢ `/status` - Lottery status\n ‚Ä¢ `/game` - Lottery game info\n ‚Ä¢ `/daily` - Claim daily bonus ($50)\n\"\"\"\n","size_bytes":20810},"sitaBot/modules/global_bans.py":{"content":"import html\nimport time\nfrom datetime import datetime\nfrom io import BytesIO\n\nfrom telegram import ParseMode, Update\nfrom telegram.error import BadRequest, TelegramError, Unauthorized\nfrom telegram.ext import (\n    CallbackContext,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import mention_html\n\nimport sitaBot.modules.sql.global_bans_sql as sql\nfrom sitaBot.modules.sql.users_sql import get_user_com_chats\nfrom sitaBot import (\n    DEV_USERS,\n    EVENT_LOGS,\n    OWNER_ID,\n    STRICT_GBAN,\n    DRAGONS,\n    SUPPORT_CHAT,\n    SPAMWATCH_SUPPORT_CHAT,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    sw,\n    dispatcher,\n)\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    is_user_admin,\n    support_plus,\n    user_admin,\n)\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_user,\n    extract_user_and_text,\n)\nfrom sitaBot.modules.helper_funcs.misc import send_to_list\n\nGBAN_ENFORCE_GROUP = 6\n\nGBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to kick it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can kick group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n    \"Can't remove chat owner\",\n}\n\nUNGBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Method is available for supergroup and channel chats only\",\n    \"Not in the chat\",\n    \"Channel_private\",\n    \"Chat_admin_required\",\n    \"Peer_id_invalid\",\n    \"User not found\",\n}\n\n\n@run_async\n@support_plus\ndef gban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    log_message = \"\"\n\n    user_id, reason = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n\n    if int(user_id) in DEV_USERS:\n        message.reply_text(\n            \"That user is part of the Association\\nI can't act against our own.\"\n        )\n        return\n\n    if int(user_id) in DRAGONS:\n        message.reply_text(\n            \"I spy, with my little eye... a disaster! Why are you guys turning on each other?\"\n        )\n        return\n\n    if int(user_id) in DEMONS:\n        message.reply_text(\n            \"OOOH someone's trying to gban a Demon Disaster! *grabs popcorn*\"\n        )\n        return\n\n    if int(user_id) in TIGERS:\n        message.reply_text(\"That's a Tiger! They cannot be banned!\")\n        return\n\n    if int(user_id) in WOLVES:\n        message.reply_text(\"That's a Wolf! They cannot be banned!\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"You uhh...want me to punch myself?\")\n        return\n\n    if user_id in [777000, 1087968824]:\n        message.reply_text(\"Fool! You can't attack Telegram's native tech!\")\n        return\n\n    try:\n        user_chat = bot.get_chat(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user.\")\n            return \"\"\n        else:\n            return\n\n    if user_chat.type != \"private\":\n        message.reply_text(\"That's not a user!\")\n        return\n\n    if sql.is_user_gbanned(user_id):\n\n        if not reason:\n            message.reply_text(\n                \"This user is already gbanned; I'd change the reason, but you haven't given me one...\"\n            )\n            return\n\n        old_reason = sql.update_gban_reason(\n            user_id, user_chat.username or user_chat.first_name, reason\n        )\n        if old_reason:\n            message.reply_text(\n                \"This user is already gbanned, for the following reason:\\n\"\n                \"<code>{}</code>\\n\"\n                \"I've gone and updated it with your new reason!\".format(\n                    html.escape(old_reason)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n\n        else:\n            message.reply_text(\n                \"This user is already gbanned, but had no reason set; I've gone and updated it!\"\n            )\n\n        return\n\n    message.reply_text(\"On it!\")\n\n    start_time = time.time()\n    datetime_fmt = \"%Y-%m-%dT%H:%M\"\n    current_time = datetime.utcnow().strftime(datetime_fmt)\n\n    if chat.type != \"private\":\n        chat_origin = \"<b>{} ({})</b>\\n\".format(html.escape(chat.title), chat.id)\n    else:\n        chat_origin = \"<b>{}</b>\\n\".format(chat.id)\n\n    log_message = (\n        f\"#GBANNED\\n\"\n        f\"<b>Originated from:</b> <code>{chat_origin}</code>\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>Banned User:</b> {mention_html(user_chat.id, user_chat.first_name)}\\n\"\n        f\"<b>Banned User ID:</b> <code>{user_chat.id}</code>\\n\"\n        f\"<b>Event Stamp:</b> <code>{current_time}</code>\"\n    )\n\n    if reason:\n        if chat.type == chat.SUPERGROUP and chat.username:\n            log_message += f'\\n<b>Reason:</b> <a href=\"https://telegram.me/{chat.username}/{message.message_id}\">{reason}</a>'\n        else:\n            log_message += f\"\\n<b>Reason:</b> <code>{reason}</code>\"\n\n    if EVENT_LOGS:\n        try:\n            log = bot.send_message(EVENT_LOGS, log_message, parse_mode=ParseMode.HTML)\n        except BadRequest as excp:\n            log = bot.send_message(\n                EVENT_LOGS,\n                log_message\n                + \"\\n\\nFormatting has been disabled due to an unexpected error.\",\n            )\n\n    else:\n        send_to_list(bot, DRAGONS + DEMONS, log_message, html=True)\n\n    sql.gban_user(user_id, user_chat.username or user_chat.first_name, reason)\n\n    chats = get_user_com_chats(user_id)\n    gbanned_chats = 0\n\n    for chat in chats:\n        chat_id = int(chat)\n\n        # Check if this group has disabled gbans\n        if not sql.does_chat_gban(chat_id):\n            continue\n\n        try:\n            bot.kick_chat_member(chat_id, user_id)\n            gbanned_chats += 1\n\n        except BadRequest as excp:\n            if excp.message in GBAN_ERRORS:\n                pass\n            else:\n                message.reply_text(f\"Could not gban due to: {excp.message}\")\n                if EVENT_LOGS:\n                    bot.send_message(\n                        EVENT_LOGS,\n                        f\"Could not gban due to {excp.message}\",\n                        parse_mode=ParseMode.HTML,\n                    )\n                else:\n                    send_to_list(\n                        bot, DRAGONS + DEMONS, f\"Could not gban due to: {excp.message}\"\n                    )\n                sql.ungban_user(user_id)\n                return\n        except TelegramError:\n            pass\n\n    if EVENT_LOGS:\n        log.edit_text(\n            log_message + f\"\\n<b>Chats affected:</b> <code>{gbanned_chats}</code>\",\n            parse_mode=ParseMode.HTML,\n        )\n    else:\n        send_to_list(\n            bot,\n            DRAGONS + DEMONS,\n            f\"Gban complete! (User banned in <code>{gbanned_chats}</code> chats)\",\n            html=True,\n        )\n\n    end_time = time.time()\n    gban_time = round((end_time - start_time), 2)\n\n    if gban_time > 60:\n        gban_time = round((gban_time / 60), 2)\n        message.reply_text(\"Done! Gbanned.\", parse_mode=ParseMode.HTML)\n    else:\n        message.reply_text(\"Done! Gbanned.\", parse_mode=ParseMode.HTML)\n\n    try:\n        bot.send_message(\n            user_id,\n            \"#EVENT\"\n            \"You have been marked as Malicious and as such have been banned from any future groups we manage.\"\n            f\"\\n<b>Reason:</b> <code>{html.escape(user.reason)}</code>\"\n            f\"</b>Appeal Chat:</b> @{SUPPORT_CHAT}\",\n            parse_mode=ParseMode.HTML,\n        )\n    except:\n        pass  # bot probably blocked by user\n\n\n@run_async\n@support_plus\ndef ungban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n    log_message = \"\"\n\n    user_id = extract_user(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n\n    user_chat = bot.get_chat(user_id)\n    if user_chat.type != \"private\":\n        message.reply_text(\"That's not a user!\")\n        return\n\n    if not sql.is_user_gbanned(user_id):\n        message.reply_text(\"This user is not gbanned!\")\n        return\n\n    message.reply_text(f\"I'll give {user_chat.first_name} a second chance, globally.\")\n\n    start_time = time.time()\n    datetime_fmt = \"%Y-%m-%dT%H:%M\"\n    current_time = datetime.utcnow().strftime(datetime_fmt)\n\n    if chat.type != \"private\":\n        chat_origin = f\"<b>{html.escape(chat.title)} ({chat.id})</b>\\n\"\n    else:\n        chat_origin = f\"<b>{chat.id}</b>\\n\"\n\n    log_message = (\n        f\"#UNGBANNED\\n\"\n        f\"<b>Originated from:</b> <code>{chat_origin}</code>\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"<b>Unbanned User:</b> {mention_html(user_chat.id, user_chat.first_name)}\\n\"\n        f\"<b>Unbanned User ID:</b> <code>{user_chat.id}</code>\\n\"\n        f\"<b>Event Stamp:</b> <code>{current_time}</code>\"\n    )\n\n    if EVENT_LOGS:\n        try:\n            log = bot.send_message(EVENT_LOGS, log_message, parse_mode=ParseMode.HTML)\n        except BadRequest as excp:\n            log = bot.send_message(\n                EVENT_LOGS,\n                log_message\n                + \"\\n\\nFormatting has been disabled due to an unexpected error.\",\n            )\n    else:\n        send_to_list(bot, DRAGONS + DEMONS, log_message, html=True)\n\n    chats = get_user_com_chats(user_id)\n    ungbanned_chats = 0\n\n    for chat in chats:\n        chat_id = int(chat)\n\n        # Check if this group has disabled gbans\n        if not sql.does_chat_gban(chat_id):\n            continue\n\n        try:\n            member = bot.get_chat_member(chat_id, user_id)\n            if member.status == \"kicked\":\n                bot.unban_chat_member(chat_id, user_id)\n                ungbanned_chats += 1\n\n        except BadRequest as excp:\n            if excp.message in UNGBAN_ERRORS:\n                pass\n            else:\n                message.reply_text(f\"Could not un-gban due to: {excp.message}\")\n                if EVENT_LOGS:\n                    bot.send_message(\n                        EVENT_LOGS,\n                        f\"Could not un-gban due to: {excp.message}\",\n                        parse_mode=ParseMode.HTML,\n                    )\n                else:\n                    bot.send_message(\n                        OWNER_ID, f\"Could not un-gban due to: {excp.message}\"\n                    )\n                return\n        except TelegramError:\n            pass\n\n    sql.ungban_user(user_id)\n\n    if EVENT_LOGS:\n        log.edit_text(\n            log_message + f\"\\n<b>Chats affected:</b> {ungbanned_chats}\",\n            parse_mode=ParseMode.HTML,\n        )\n    else:\n        send_to_list(bot, DRAGONS + DEMONS, \"un-gban complete!\")\n\n    end_time = time.time()\n    ungban_time = round((end_time - start_time), 2)\n\n    if ungban_time > 60:\n        ungban_time = round((ungban_time / 60), 2)\n        message.reply_text(f\"Person has been un-gbanned. Took {ungban_time} min\")\n    else:\n        message.reply_text(f\"Person has been un-gbanned. Took {ungban_time} sec\")\n\n\n@run_async\n@support_plus\ndef gbanlist(update: Update, context: CallbackContext):\n    banned_users = sql.get_gban_list()\n\n    if not banned_users:\n        update.effective_message.reply_text(\n            \"There aren't any gbanned users! You're kinder than I expected...\"\n        )\n        return\n\n    banfile = \"Screw these guys.\\n\"\n    for user in banned_users:\n        banfile += f\"[x] {user['name']} - {user['user_id']}\\n\"\n        if user[\"reason\"]:\n            banfile += f\"Reason: {user['reason']}\\n\"\n\n    with BytesIO(str.encode(banfile)) as output:\n        output.name = \"gbanlist.txt\"\n        update.effective_message.reply_document(\n            document=output,\n            filename=\"gbanlist.txt\",\n            caption=\"Here is the list of currently gbanned users.\",\n        )\n\n\ndef check_and_ban(update, user_id, should_message=True):\n\n    chat = update.effective_chat  # type: Optional[Chat]\n    try:\n        sw_ban = sw.get_ban(int(user_id))\n    except:\n        sw_ban = None\n\n    if sw_ban:\n        update.effective_chat.kick_member(user_id)\n        if should_message:\n            update.effective_message.reply_text(\n                f\"<b>Alert</b>: this user is globally banned.\\n\"\n                f\"<code>*bans them from here*</code>.\\n\"\n                f\"<b>Appeal chat</b>: {SPAMWATCH_SUPPORT_CHAT}\\n\"\n                f\"<b>User ID</b>: <code>{sw_ban.id}</code>\\n\"\n                f\"<b>Ban Reason</b>: <code>{html.escape(sw_ban.reason)}</code>\",\n                parse_mode=ParseMode.HTML,\n            )\n        return\n\n    if sql.is_user_gbanned(user_id):\n        update.effective_chat.kick_member(user_id)\n        if should_message:\n            text = (\n                f\"<b>Alert</b>: this user is globally banned.\\n\"\n                f\"<code>*bans them from here*</code>.\\n\"\n                f\"<b>Appeal chat</b>: @{SUPPORT_CHAT}\\n\"\n                f\"<b>User ID</b>: <code>{user_id}</code>\"\n            )\n            user = sql.get_gbanned_user(user_id)\n            if user.reason:\n                text += f\"\\n<b>Ban Reason:</b> <code>{html.escape(user.reason)}</code>\"\n            update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef enforce_gban(update: Update, context: CallbackContext):\n    # Not using @restrict handler to avoid spamming - just ignore if cant gban.\n    bot = context.bot\n    try:\n        restrict_permission = update.effective_chat.get_member(\n            bot.id\n        ).can_restrict_members\n    except Unauthorized:\n        return\n    if sql.does_chat_gban(update.effective_chat.id) and restrict_permission:\n        user = update.effective_user\n        chat = update.effective_chat\n        msg = update.effective_message\n\n        if user and not is_user_admin(chat, user.id):\n            check_and_ban(update, user.id)\n            return\n\n        if msg.new_chat_members:\n            new_members = update.effective_message.new_chat_members\n            for mem in new_members:\n                check_and_ban(update, mem.id)\n\n        if msg.reply_to_message:\n            user = msg.reply_to_message.from_user\n            if user and not is_user_admin(chat, user.id):\n                check_and_ban(update, user.id, should_message=False)\n\n\n@run_async\n@user_admin\ndef gbanstat(update: Update, context: CallbackContext):\n    args = context.args\n    if len(args) > 0:\n        if args[0].lower() in [\"on\", \"yes\"]:\n            sql.enable_gbans(update.effective_chat.id)\n            update.effective_message.reply_text(\n                \"Antispam is now enabled ‚úÖ \"\n                \"I am now protecting your group from potential remote threats!\"\n            )\n        elif args[0].lower() in [\"off\", \"no\"]:\n            sql.disable_gbans(update.effective_chat.id)\n            update.effective_message.reply_text(\n                \"Antispan is now disabled ‚ùå \" \"Spamwatch is now disabled ‚ùå\"\n            )\n    else:\n        update.effective_message.reply_text(\n            \"Give me some arguments to choose a setting! on/off, yes/no!\\n\\n\"\n            \"Your current setting is: {}\\n\"\n            \"When True, any gbans that happen will also happen in your group. \"\n            \"When False, they won't, leaving you at the possible mercy of \"\n            \"spammers.\".format(sql.does_chat_gban(update.effective_chat.id))\n        )\n\n\ndef __stats__():\n    return f\"‚Ä¢ {sql.num_gbanned_users()} gbanned users.\"\n\n\ndef __user_info__(user_id):\n    is_gbanned = sql.is_user_gbanned(user_id)\n    text = \"Malicious: <b>{}</b>\"\n    if user_id in [777000, 1087968824]:\n        return \"\"\n    if user_id == dispatcher.bot.id:\n        return \"\"\n    if int(user_id) in DRAGONS + TIGERS + WOLVES:\n        return \"\"\n    if is_gbanned:\n        text = text.format(\"Yes\")\n        user = sql.get_gbanned_user(user_id)\n        if user.reason:\n            text += f\"\\n<b>Reason:</b> <code>{html.escape(user.reason)}</code>\"\n        text += f\"\\n<b>Appeal Chat:</b> @{SUPPORT_CHAT}\"\n    else:\n        text = text.format(\"???\")\n    return text\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    return f\"This chat is enforcing *gbans*: `{sql.does_chat_gban(chat_id)}`.\"\n\n\nGBAN_HANDLER = CommandHandler(\"gban\", gban)\nUNGBAN_HANDLER = CommandHandler(\"ungban\", ungban)\nGBAN_LIST = CommandHandler(\"gbanlist\", gbanlist)\n\nGBAN_STATUS = CommandHandler(\"antispam\", gbanstat, filters=Filters.group)\n\nGBAN_ENFORCER = MessageHandler(Filters.all & Filters.group, enforce_gban)\n\ndispatcher.add_handler(GBAN_HANDLER)\ndispatcher.add_handler(UNGBAN_HANDLER)\ndispatcher.add_handler(GBAN_LIST)\ndispatcher.add_handler(GBAN_STATUS)\n\n__mod_name__ = \"Anti-Spam\"\n__handlers__ = [GBAN_HANDLER, UNGBAN_HANDLER, GBAN_LIST, GBAN_STATUS]\n\nif STRICT_GBAN:  # enforce GBANS if this is set\n    dispatcher.add_handler(GBAN_ENFORCER, GBAN_ENFORCE_GROUP)\n    __handlers__.append((GBAN_ENFORCER, GBAN_ENFORCE_GROUP))\n","size_bytes":17654},"sitaBot/modules/sql/reporting_sql.py":{"content":"import threading\nfrom typing import Union\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, String\n\n\nclass ReportingUserSettings(BASE):\n    __tablename__ = \"user_report_settings\"\n    user_id = Column(Integer, primary_key=True)\n    should_report = Column(Boolean, default=True)\n\n    def __init__(self, user_id):\n        self.user_id = user_id\n\n    def __repr__(self):\n        return \"<User report settings ({})>\".format(self.user_id)\n\n\nclass ReportingChatSettings(BASE):\n    __tablename__ = \"chat_report_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    should_report = Column(Boolean, default=True)\n\n    def __init__(self, chat_id):\n        self.chat_id = str(chat_id)\n\n    def __repr__(self):\n        return \"<Chat report settings ({})>\".format(self.chat_id)\n\n\nReportingUserSettings.__table__.create(checkfirst=True)\nReportingChatSettings.__table__.create(checkfirst=True)\n\nCHAT_LOCK = threading.RLock()\nUSER_LOCK = threading.RLock()\n\n\ndef chat_should_report(chat_id: Union[str, int]) -> bool:\n    try:\n        chat_setting = SESSION.query(ReportingChatSettings).get(str(chat_id))\n        if chat_setting:\n            return chat_setting.should_report\n        return False\n    finally:\n        SESSION.close()\n\n\ndef user_should_report(user_id: int) -> bool:\n    try:\n        user_setting = SESSION.query(ReportingUserSettings).get(user_id)\n        if user_setting:\n            return user_setting.should_report\n        return True\n    finally:\n        SESSION.close()\n\n\ndef set_chat_setting(chat_id: Union[int, str], setting: bool):\n    with CHAT_LOCK:\n        chat_setting = SESSION.query(ReportingChatSettings).get(str(chat_id))\n        if not chat_setting:\n            chat_setting = ReportingChatSettings(chat_id)\n\n        chat_setting.should_report = setting\n        SESSION.add(chat_setting)\n        SESSION.commit()\n\n\ndef set_user_setting(user_id: int, setting: bool):\n    with USER_LOCK:\n        user_setting = SESSION.query(ReportingUserSettings).get(user_id)\n        if not user_setting:\n            user_setting = ReportingUserSettings(user_id)\n\n        user_setting.should_report = setting\n        SESSION.add(user_setting)\n        SESSION.commit()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with CHAT_LOCK:\n        chat_notes = (\n            SESSION.query(ReportingChatSettings)\n            .filter(ReportingChatSettings.chat_id == str(old_chat_id))\n            .all()\n        )\n        for note in chat_notes:\n            note.chat_id = str(new_chat_id)\n        SESSION.commit()\n","size_bytes":2562},"sitaBot/modules/logomaker.py":{"content":"from sitaBot.events import register\nfrom sitaBot import OWNER_ID\nfrom sitaBot import telethn as tbot\nimport os \nfrom PIL import Image, ImageDraw, ImageFont\nimport shutil \nimport random, re\nimport glob\nimport time\nfrom telethon.tl.types import InputMessagesFilterPhotos\n\n\nFONT_FILE_TO_USE = \"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\"\n\n#Add telegraph media links of profile pics that are to be used\nTELEGRAPH_MEDIA_LINKS = [\"https://telegra.ph/file/e354ce72d5cc6a1d27c4d.jpg\", \n                         \"https://telegra.ph/file/8f9ff3d743e6707a61489.jpg\", \n                         \"https://telegra.ph/file/bfc97f4abc4bec6fe860d.jpg\", \n                         \"https://telegra.ph/file/5ef0f060023600ec08c19.jpg\",\n                         \"https://telegra.ph/file/a448465a3a8a251170f76.jpg\",\n                         \"https://telegra.ph/file/eb0ac1557668a98a38cb6.jpg\", \n                         \"https://telegra.ph/file/fdb3691a17a2c91fbe76c.jpg\", \n                         \"https://telegra.ph/file/ccdf69ebf6cb85c52a25b.jpg\",\n                         \"https://telegra.ph/file/2adffc55ac0c9733ecc7f.jpg\", \n                         \"https://telegra.ph/file/faca3b435da33f2f156f1.jpg\", \n                         \"https://telegra.ph/file/93d0a48c31e16f036f0e8.jpg\", \n                         \"https://telegra.ph/file/9ed89dc742b172a779312.jpg\",\n                         \"https://telegra.ph/file/0b4c19a19fb834d922d66.jpg\", \n                         \"https://telegra.ph/file/a95a0deb86f642129b067.jpg\", \n                         \"https://telegra.ph/file/c4c3d8b5cfc3cc5040833.jpg\", \n                         \"https://telegra.ph/file/1e1a1b52b9a313e066a04.jpg\",\n                         \"https://telegra.ph/file/a582950a8a259efdcbbc0.jpg\",\n                         \"https://telegra.ph/file/9c3a784d45790b193ca36.jpg\", \n                         \"https://telegra.ph/file/6aa74b17ae4e7dc46116f.jpg\", \n                         \"https://telegra.ph/file/e63cf624d1b68a5c819b6.jpg\",\n                         \"https://telegra.ph/file/7e420ad5995952ba1c262.jpg\",\n                         \"https://telegra.ph/file/c7a4dc3d2a9a422c19723.jpg\", \n                         \"https://telegra.ph/file/163c7eba56fd2e8c266e4.jpg\", \n                         \"https://telegra.ph/file/5c87b63ae326b5c3cd713.jpg\",\n                         \"https://telegra.ph/file/344ca22b35868c0a7661d.jpg\", \n                         \"https://telegra.ph/file/a0ef3e56f558f04a876aa.jpg\", \n                         \"https://telegra.ph/file/217b997ad9b5af8b269d0.jpg\", \n                         \"https://telegra.ph/file/b3595f99b221c56a5679b.jpg\",\n                         \"https://telegra.ph/file/aba7f4b4485c5aae53c52.jpg\", \n                         \"https://telegra.ph/file/209ca51dba6c0f1fba85f.jpg\", \n                         \"https://telegra.ph/file/2a0505ee2630bd6d7acca.jpg\", \n                         \"https://telegra.ph/file/d193d4191012f4aafd4d2.jpg\",\n                         \"https://telegra.ph/file/47e2d151984bd54a5d947.jpg\",\n                         \"https://telegra.ph/file/2a6c735b47db947b44599.jpg\", \n                         \"https://telegra.ph/file/7567774412fb76ceba95c.jpg\", \n                         \"https://telegra.ph/file/6dd8b0edec92b24985e13.jpg\",\n                         \"https://telegra.ph/file/dcf5e16cc344f1c030469.jpg\",\n                         \"https://telegra.ph/file/0718be0bd52a2eb7e36aa.jpg\", \n                         \"https://telegra.ph/file/0d7fcb82603b5db683890.jpg\", \n                         \"https://telegra.ph/file/44595caa95717f4db4788.jpg\",\n                         \"https://telegra.ph/file/f3a063d884d0dcde437e3.jpg\", \n                         \"https://telegra.ph/file/733425275da19cbed0822.jpg\", \n                         \"https://telegra.ph/file/aff5223e1aa29f212a46a.jpg\", \n                         \"https://telegra.ph/file/45ccfa3ef878bea9cfc02.jpg\",\n                         \"https://telegra.ph/file/a38aa50d009835177ac16.jpg\", \n                         \"https://telegra.ph/file/53e25b1b06f411ec051f0.jpg\", \n                         \"https://telegra.ph/file/96e801400487d0a120715.jpg\", \n                         \"https://telegra.ph/file/6ae8e799f2acc837e27eb.jpg\",\n                         \"https://telegra.ph/file/265ff1cebbb7042bfb5a7.jpg\",\n                         \"https://telegra.ph/file/4c8c9cd0751eab99600c9.jpg\", \n                         \"https://telegra.ph/file/1c6a5cd6d82f92c646c0f.jpg\", \n                         \"https://telegra.ph/file/2c1056c91c8f37fea838a.jpg\",\n                         \"https://telegra.ph/file/f140c121d03dfcaf4e951.jpg\", \n                         \"https://telegra.ph/file/39f7b5d1d7a3487f6ba69.jpg\"\n                         ]\n\n@register(pattern=\"^/logo ?(.*)\")\nasync def lego(event):\n quew = event.pattern_match.group(1)\n if event.sender_id == OWNER_ID:\n     pass\n else:\n     \n    if not quew:\n       await event.reply('Provide Some Text To Draw!')\n       return\n    else:\n       pass\n await event.reply('Creating your logo...wait!')\n try:\n    text = event.pattern_match.group(1)\n    img = Image.open('./sitaBot/resources/blackbg.jpg')\n    draw = ImageDraw.Draw(img)\n    image_widthz, image_heightz = img.size\n    pointsize = 500\n    fillcolor = \"gold\"\n    shadowcolor = \"blue\"\n    font = ImageFont.truetype(\"./sitaBot/resources/Chopsic.otf\", 330)\n    w, h = draw.textsize(text, font=font)\n    h += int(h*0.21)\n    image_width, image_height = img.size\n    draw.text(((image_widthz-w)/2, (image_heightz-h)/2), text, font=font, fill=(255, 255, 255))\n    x = (image_widthz-w)/2\n    y= ((image_heightz-h)/2+6)\n    draw.text((x, y), text, font=font, fill=\"black\", stroke_width=25, stroke_fill=\"yellow\")\n    fname2 = \"LogoBySita.png\"\n    img.save(fname2, \"png\")\n    await tbot.send_file(event.chat_id, fname2, caption=\"üíï Made By @about_brahix Support @brahix_support\")\n    if os.path.exists(fname2):\n            os.remove(fname2)\n except Exception as e:\n   await event.reply(f'Error Report @brahix_support, {e}')\n\n\n\n   \n@register(pattern=\"^/wlogo ?(.*)\")\nasync def lego(event):\n quew = event.pattern_match.group(1)\n if event.sender_id == OWNER_ID:\n     pass\n else:\n     \n    if not quew:\n       await event.reply('Provide Some Text To Draw!')\n       return\n    else:\n       pass\n await event.reply('Creating your logo...wait!')\n try:\n    text = event.pattern_match.group(1)\n    img = Image.open('./sitaBot/resources/blackbg.jpg')\n    draw = ImageDraw.Draw(img)\n    image_widthz, image_heightz = img.size\n    pointsize = 500\n    fillcolor = \"white\"\n    shadowcolor = \"blue\"\n    font = ImageFont.truetype(\"./sitaBot/resources/Maghrib.ttf\", 1000)\n    w, h = draw.textsize(text, font=font)\n    h += int(h*0.21)\n    image_width, image_height = img.size\n    draw.text(((image_widthz-w)/2, (image_heightz-h)/2), text, font=font, fill=(255, 255, 255))\n    x = (image_widthz-w)/2\n    y= ((image_heightz-h)/2+6)\n    draw.text((x, y), text, font=font, fill=\"white\", stroke_width=0, stroke_fill=\"white\")\n    fname2 = \"LogoBySita.png\"\n    img.save(fname2, \"png\")\n    await tbot.send_file(event.chat_id, fname2, caption=\"Made By @Innexiiiabot\")\n    if os.path.exists(fname2):\n            os.remove(fname2)\n except Exception as e:\n   await event.reply(f'Error Report @brahix_support, {e}')\n\nfile_help = os.path.basename(__file__)\nfile_help = file_help.replace(\".py\", \"\")\nfile_helpo = file_help.replace(\"_\", \" \")\n\n\n__help__ = \"\"\"\n ‚ùç /logo text :  Create your logo with your name\n ‚ùç /wlogo text :  Create your logo with your name\n\n \"\"\"\n__mod_name__ = \"Logo\"\n","size_bytes":7492},"sitaBot/modules/sql/antiflood_sql.py":{"content":"import threading\n\nfrom sqlalchemy import String, Column, Integer, UnicodeText\n\nfrom sitaBot.modules.sql import SESSION, BASE\n\nDEF_COUNT = 1\nDEF_LIMIT = 0\nDEF_OBJ = (None, DEF_COUNT, DEF_LIMIT)\n\n\nclass FloodControl(BASE):\n    __tablename__ = \"antiflood\"\n    chat_id = Column(String(14), primary_key=True)\n    user_id = Column(Integer)\n    count = Column(Integer, default=DEF_COUNT)\n    limit = Column(Integer, default=DEF_LIMIT)\n\n    def __init__(self, chat_id):\n        self.chat_id = str(chat_id)  # ensure string\n\n    def __repr__(self):\n        return \"<flood control for %s>\" % self.chat_id\n\n\nclass FloodSettings(BASE):\n    __tablename__ = \"antiflood_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    flood_type = Column(Integer, default=1)\n    value = Column(UnicodeText, default=\"0\")\n\n    def __init__(self, chat_id, flood_type=1, value=\"0\"):\n        self.chat_id = str(chat_id)\n        self.flood_type = flood_type\n        self.value = value\n\n    def __repr__(self):\n        return \"<{} will executing {} for flood.>\".format(self.chat_id, self.flood_type)\n\n\nFloodControl.__table__.create(checkfirst=True)\nFloodSettings.__table__.create(checkfirst=True)\n\nINSERTION_FLOOD_LOCK = threading.RLock()\nINSERTION_FLOOD_SETTINGS_LOCK = threading.RLock()\n\nCHAT_FLOOD = {}\n\n\ndef set_flood(chat_id, amount):\n    with INSERTION_FLOOD_LOCK:\n        flood = SESSION.query(FloodControl).get(str(chat_id))\n        if not flood:\n            flood = FloodControl(str(chat_id))\n\n        flood.user_id = None\n        flood.limit = amount\n\n        CHAT_FLOOD[str(chat_id)] = (None, DEF_COUNT, amount)\n\n        SESSION.add(flood)\n        SESSION.commit()\n\n\ndef update_flood(chat_id: str, user_id) -> bool:\n    if str(chat_id) in CHAT_FLOOD:\n        curr_user_id, count, limit = CHAT_FLOOD.get(str(chat_id), DEF_OBJ)\n\n        if limit == 0:  # no antiflood\n            return False\n\n        if user_id != curr_user_id or user_id is None:  # other user\n            CHAT_FLOOD[str(chat_id)] = (user_id, DEF_COUNT, limit)\n            return False\n\n        count += 1\n        if count > limit:  # too many msgs, kick\n            CHAT_FLOOD[str(chat_id)] = (None, DEF_COUNT, limit)\n            return True\n\n        # default -> update\n        CHAT_FLOOD[str(chat_id)] = (user_id, count, limit)\n        return False\n\n\ndef get_flood_limit(chat_id):\n    return CHAT_FLOOD.get(str(chat_id), DEF_OBJ)[2]\n\n\ndef set_flood_strength(chat_id, flood_type, value):\n    # for flood_type\n    # 1 = ban\n    # 2 = kick\n    # 3 = mute\n    # 4 = tban\n    # 5 = tmute\n    with INSERTION_FLOOD_SETTINGS_LOCK:\n        curr_setting = SESSION.query(FloodSettings).get(str(chat_id))\n        if not curr_setting:\n            curr_setting = FloodSettings(\n                chat_id, flood_type=int(flood_type), value=value\n            )\n\n        curr_setting.flood_type = int(flood_type)\n        curr_setting.value = str(value)\n\n        SESSION.add(curr_setting)\n        SESSION.commit()\n\n\ndef get_flood_setting(chat_id):\n    try:\n        setting = SESSION.query(FloodSettings).get(str(chat_id))\n        if setting:\n            return setting.flood_type, setting.value\n        else:\n            return 1, \"0\"\n\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with INSERTION_FLOOD_LOCK:\n        flood = SESSION.query(FloodControl).get(str(old_chat_id))\n        if flood:\n            CHAT_FLOOD[str(new_chat_id)] = CHAT_FLOOD.get(str(old_chat_id), DEF_OBJ)\n            flood.chat_id = str(new_chat_id)\n            SESSION.commit()\n\n        SESSION.close()\n\n\ndef __load_flood_settings():\n    global CHAT_FLOOD\n    try:\n        all_chats = SESSION.query(FloodControl).all()\n        CHAT_FLOOD = {chat.chat_id: (None, DEF_COUNT, chat.limit) for chat in all_chats}\n    finally:\n        SESSION.close()\n\n\n__load_flood_settings()\n","size_bytes":3825},"sitaBot/utils/tools.py":{"content":"import hashlib\nimport re\n\n\nasync def md5(fname: str) -> str:\n    hash_md5 = hashlib.md5()\n    with open(fname, \"rb\") as f:\n        for chunk in iter(lambda: f.read(4096), b\"\"):\n            hash_md5.update(chunk)\n    return hash_md5.hexdigest()\n\n\ndef humanbytes(size: int) -> str:\n    if size is None or isinstance(size, str):\n        return \"\"\n\n    power = 2 ** 10\n    raised_to_pow = 0\n    dict_power_n = {0: \"\", 1: \"Ki\", 2: \"Mi\", 3: \"Gi\", 4: \"Ti\"}\n    while size > power:\n        size /= power\n        raised_to_pow += 1\n    return str(round(size, 2)) + \" \" + dict_power_n[raised_to_pow] + \"B\"\n\n\ndef time_formatter(seconds: int) -> str:\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    days, hours = divmod(hours, 24)\n    tmp = (\n        ((str(days) + \" day(s), \") if days else \"\")\n        + ((str(hours) + \" hour(s), \") if hours else \"\")\n        + ((str(minutes) + \" minute(s), \") if minutes else \"\")\n        + ((str(seconds) + \" second(s), \") if seconds else \"\")\n    )\n    return tmp[:-2]\n\n\ndef human_to_bytes(size: str) -> int:\n    units = {\n        \"M\": 2 ** 20,\n        \"MB\": 2 ** 20,\n        \"G\": 2 ** 30,\n        \"GB\": 2 ** 30,\n        \"T\": 2 ** 40,\n        \"TB\": 2 ** 40,\n    }\n\n    size = size.upper()\n    if not re.match(r\" \", size):\n        size = re.sub(r\"([KMGT])\", r\" \\1\", size)\n    number, unit = [string.strip() for string in size.split()]\n    return int(float(number) * units[unit])\n","size_bytes":1441},"sitaBot/modules/sql/userinfo_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, Integer, BigInteger, UnicodeText\n\n\nclass UserInfo(BASE):\n    __tablename__ = \"userinfo\"\n    user_id = Column(BigInteger, primary_key=True)\n    info = Column(UnicodeText)\n\n    def __init__(self, user_id, info):\n        self.user_id = user_id\n        self.info = info\n\n    def __repr__(self):\n        return \"<User info %d>\" % self.user_id\n\n\nclass UserBio(BASE):\n    __tablename__ = \"userbio\"\n    user_id = Column(BigInteger, primary_key=True)\n    bio = Column(UnicodeText)\n\n    def __init__(self, user_id, bio):\n        self.user_id = user_id\n        self.bio = bio\n\n    def __repr__(self):\n        return \"<User info %d>\" % self.user_id\n\n\nUserInfo.__table__.create(checkfirst=True)\nUserBio.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\n\n\ndef get_user_me_info(user_id):\n    userinfo = SESSION.query(UserInfo).get(user_id)\n    SESSION.close()\n    if userinfo:\n        return userinfo.info\n    return None\n\n\ndef set_user_me_info(user_id, info):\n    with INSERTION_LOCK:\n        userinfo = SESSION.query(UserInfo).get(user_id)\n        if userinfo:\n            userinfo.info = info\n        else:\n            userinfo = UserInfo(user_id, info)\n        SESSION.add(userinfo)\n        SESSION.commit()\n\n\ndef get_user_bio(user_id):\n    userbio = SESSION.query(UserBio).get(user_id)\n    SESSION.close()\n    if userbio:\n        return userbio.bio\n    return None\n\n\ndef set_user_bio(user_id, bio):\n    with INSERTION_LOCK:\n        userbio = SESSION.query(UserBio).get(user_id)\n        if userbio:\n            userbio.bio = bio\n        else:\n            userbio = UserBio(user_id, bio)\n\n        SESSION.add(userbio)\n        SESSION.commit()\n","size_bytes":1746},"sitaBot/modules/__encrypt.py":{"content":"from sitaBot import telethn as tbot\nimport os\nfrom sitaBot.events import register\nimport secureme\n\n@register(pattern=\"^/encrypt ?(.*)\")\nasync def hmm(event):\n    if event.reply_to_msg_id:\n          lel = await event.get_reply_message()\n          cmd = lel.text\n    else:\n          cmd = event.pattern_match.group(1)\n    Text = cmd\n    k = secureme.encrypt(Text)\n    await event.reply(k)\n\n@register(pattern=\"^/decrypt ?(.*)\")\nasync def hmm(event):\n    if event.reply_to_msg_id:\n          lel = await event.get_reply_message()\n          ok = lel.text\n    else:\n          ok = event.pattern_match.group(1)\n    Text = ok\n    k = secureme.decrypt(Text)\n    await event.reply(k)\n","size_bytes":673},"sitaBot/__main__.py":{"content":"import importlib\nimport time\nimport re\nfrom sys import argv\nfrom typing import Optional\n\nfrom sitaBot import (\n    ALLOW_EXCL,\n    CERT_PATH,\n    DONATION_LINK,\n    LOGGER,\n    OWNER_ID,\n    PORT,\n    SUPPORT_CHAT,\n    TOKEN,\n    URL,\n    WEBHOOK,\n    SUPPORT_CHAT,\n    dispatcher,\n    StartTime,\n    telethn,\n    pbot,\n    updater,\n)\n\n# needed to dynamically load modules\n# NOTE: Module order is not guaranteed, specify that in the config file!\nfrom sitaBot.modules import ALL_MODULES\nfrom sitaBot.modules.helper_funcs.chat_status import is_user_admin\nfrom sitaBot.modules.helper_funcs.misc import paginate_modules\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup, ParseMode, Update\nfrom telegram.error import (\n    BadRequest,\n    ChatMigrated,\n    NetworkError,\n    TelegramError,\n    TimedOut,\n    Unauthorized,\n)\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n)\nfrom telegram.ext.dispatcher import DispatcherHandlerStop, run_async\nfrom telegram.utils.helpers import escape_markdown\n\n\ndef get_readable_time(seconds: int) -> str:\n    count = 0\n    ping_time = \"\"\n    time_list = []\n    time_suffix_list = [\"s\", \"m\", \"h\", \"days\"]\n\n    while count < 4:\n        count += 1\n        remainder, result = divmod(seconds, 60) if count < 3 else divmod(seconds, 24)\n        if seconds == 0 and remainder == 0:\n            break\n        time_list.append(int(result))\n        seconds = int(remainder)\n\n    for x in range(len(time_list)):\n        time_list[x] = str(time_list[x]) + time_suffix_list[x]\n    if len(time_list) == 4:\n        ping_time += time_list.pop() + \", \"\n\n    time_list.reverse()\n    ping_time += \":\".join(time_list)\n\n    return ping_time\n\n\nPM_START_TEXT = \"\"\"```\n‚ùñ s…™·¥õ·¥ß  ôœÉ·¥õ ‚ùñ```\n**‚ú®  ú—î ü üœÉ, …™'·¥ç s…™·¥õ·¥ß  ôœÉ·¥õ!**\n\n** èœÉœÖ Ä ·¥ß ü ü-…™Œ∑-œÉŒ∑—î …¢ ÄœÉœÖ·¥© œª·¥ßŒ∑·¥ß…¢—îœª—îŒ∑·¥õ + “ìœÖŒ∑  ôœÉ·¥õ:**\n\n‚ùç ·¥ß·¥Öœª…™Œ∑ ·¥õœÉœÉ üs ( ô·¥ßŒ∑/œªœÖ·¥õ—î/·¥©…™Œ∑) ‚ö°\n‚ùç ·¥°·¥ß ÄŒ∑s, ·¥ßŒ∑·¥õ…™“ì üœÉœÉ·¥Ö, “ì…™ ü·¥õ—î Äs, Œ∑œÉ·¥õ—îs üìù\n‚ùç s·¥õ…™·¥Ñ·¥ã—î Ä/œª—î·¥Ö…™·¥ß ·¥õœÉœÉ üs, ·¥õ Ä·¥ßŒ∑s ü·¥ß·¥õœÉ Ä, ·¥°…™·¥ã…™, ·¥ß…™ ·¥Ñ ú·¥ß·¥õ üé®\n‚ùç —î·¥ÑœÉŒ∑œÉœª è s ès·¥õ—îœª:  ÄœÉ ô, ·¥ã…™ ü ü,  üœÉ·¥õ·¥õ—î Ä è üí∞\n\n**‚ùñ ùêè·¥è·¥°·¥á Ä·¥á·¥Ö ùñ° è ¬ª [ùÜ∫ùÖ•‚Éùüéß√ó‚É™Õú‚Äå ùêÅ ùêë ùêÄ ùêá ùêà ùêó ‚ó°Ãà‚Éù‚ü∂üìª](https://t.me/brahix)**\n\"\"\"\n\nbuttons = [\n    [\n        InlineKeyboardButton(\n            text=\"‚Ä¢  ú—î ü·¥© & ·¥ÑœÉœªœª·¥ßŒ∑·¥Ös ‚Ä¢\", callback_data=\"help_back\"),\n    ],\n    [\n        InlineKeyboardButton(text=\"Àπ sœÖ·¥©·¥©œÉ Ä·¥õ Àº\", url=f\"https://t.me/brahix_support\"),\n        InlineKeyboardButton(\n            text=\"Àπ œÖ·¥©·¥Ö·¥ß·¥õ—îs Àº\", url=f\"https://t.me/about_brahix\"\n        ),\n    ],\n    [\n        InlineKeyboardButton(text=\"Àπ ·¥ß ôœÉœÖ·¥õ Àº\", callback_data=\"sita_\"),\n        InlineKeyboardButton(\n            text=\"Àπ —î·¥ÑœÉŒ∑œÉœª è Àº\", callback_data=\"economy_help\"\n        ),\n    ],\n    [\n        InlineKeyboardButton(text=\"‚ûï ·¥ß·¥Ö·¥Ö ·¥õœÉ …¢ ÄœÉœÖ·¥© ‚ûï\", url=\"http://t.me/Sitabot?startgroup=true\"),\n    ],\n]\n\n\nHELP_STRINGS = \"\"\"```\n‚ùñ  ú—î ü·¥© & ·¥ÑœÉœªœª·¥ßŒ∑·¥Ös ‚ùñ```\n**·¥Ñ úœÉœÉs—î ·¥õ ú—î ·¥Ñ·¥ß·¥õ—î…¢œÉ Ä è “ìœÉ Ä ·¥° ú…™·¥Ñ ú  èœÉœÖ ·¥°·¥ßŒ∑Œ∑·¥ß …¢—î·¥õ  ú—î ü·¥©**\n\n**‚ùç ·¥Ñ ü…™·¥Ñ·¥ã ·¥ß ·¥Ñ·¥ß·¥õ—î…¢œÉ Ä è  ô—î üœÉ·¥° ·¥õœÉ  ô ÄœÉ·¥°s—î ·¥ÑœÉœªœª·¥ßŒ∑·¥Ös üìö\n‚ùç ·¥ß ü ü ·¥ÑœÉœªœª·¥ßŒ∑·¥Ös œÖs—î ·¥õ ú—î / ·¥© Ä—î“ì…™x üí¨\n‚ùç Œ∑—î—î·¥Ö  ú—î ü·¥©? ·¥äœÉ…™Œ∑ <a href=\"https://t.me/brahix_support\">sœÖ·¥©·¥©œÉ Ä·¥õ</a> üÜò\n\n‚ùñ ùêè·¥è·¥°·¥á Ä·¥á·¥Ö ùñ° è ¬ª [ùÜ∫ùÖ•‚Éùüéß√ó‚É™Õú‚Äå ùêÅ ùêë ùêÄ ùêá ùêà ùêó ‚ó°Ãà‚Éù‚ü∂üìª](https://t.me/brahix)**\n\"\"\"\n\n\n\nDONATE_STRING = \"\"\"Heya, glad to hear you want to donate!\n @brahix üíï\"\"\"\n\nIMPORTED = {}\nMIGRATEABLE = []\nHELPABLE = {}\nSTATS = []\nUSER_INFO = []\nDATA_IMPORT = []\nDATA_EXPORT = []\nCHAT_SETTINGS = {}\nUSER_SETTINGS = {}\n\nfor module_name in ALL_MODULES:\n    imported_module = importlib.import_module(\"sitaBot.modules.\" + module_name)\n    if not hasattr(imported_module, \"__mod_name__\"):\n        imported_module.__mod_name__ = imported_module.__name__\n\n    if imported_module.__mod_name__.lower() not in IMPORTED:\n        IMPORTED[imported_module.__mod_name__.lower()] = imported_module\n    else:\n        raise Exception(\"Can't have two modules with the same name! Please change one\")\n\n    if hasattr(imported_module, \"__help__\") and imported_module.__help__:\n        HELPABLE[imported_module.__mod_name__.lower()] = imported_module\n\n    # Chats to migrate on chat_migrated events\n    if hasattr(imported_module, \"__migrate__\"):\n        MIGRATEABLE.append(imported_module)\n\n    if hasattr(imported_module, \"__stats__\"):\n        STATS.append(imported_module)\n\n    if hasattr(imported_module, \"__user_info__\"):\n        USER_INFO.append(imported_module)\n\n    if hasattr(imported_module, \"__import_data__\"):\n        DATA_IMPORT.append(imported_module)\n\n    if hasattr(imported_module, \"__export_data__\"):\n        DATA_EXPORT.append(imported_module)\n\n    if hasattr(imported_module, \"__chat_settings__\"):\n        CHAT_SETTINGS[imported_module.__mod_name__.lower()] = imported_module\n\n    if hasattr(imported_module, \"__user_settings__\"):\n        USER_SETTINGS[imported_module.__mod_name__.lower()] = imported_module\n\n\n# do not async\ndef send_help(chat_id, text, keyboard=None):\n    if not keyboard:\n        keyboard = InlineKeyboardMarkup(paginate_modules(0, HELPABLE, \"help\"))\n    dispatcher.bot.send_message(\n        chat_id=chat_id,\n        text=text,\n        parse_mode=ParseMode.MARKDOWN,\n        disable_web_page_preview=True,\n        reply_markup=keyboard,\n    )\n\n\n@run_async\ndef test(update: Update, context: CallbackContext):\n    # pprint(eval(str(update)))\n    # update.effective_message.reply_text(\"Hola tester! _I_ *have* `markdown`\", parse_mode=ParseMode.MARKDOWN)\n    update.effective_message.reply_text(\"This person edited a message\")\n    print(update.effective_message)\n\n\n@run_async\ndef start(update: Update, context: CallbackContext):\n    # This handler is for telegram bot (python-telegram-bot) as fallback\n    # Pyrogram bot (pbot) handles start via start_stylish.py - so skip simple /start\n    args = context.args\n    uptime = get_readable_time((time.time() - StartTime))\n    if update.effective_chat.type == \"private\":\n        if len(args) >= 1:\n            if args[0].lower() == \"help\":\n                send_help(update.effective_chat.id, HELP_STRINGS)\n            elif args[0].lower().startswith(\"ghelp_\"):\n                mod = args[0].lower().split(\"_\", 1)[1]\n                if not HELPABLE.get(mod, False):\n                    return\n                send_help(\n                    update.effective_chat.id,\n                    HELPABLE[mod].__help__,\n                    InlineKeyboardMarkup(\n                        [[InlineKeyboardButton(text=\"‚¨ÖÔ∏è BACK\", callback_data=\"help_back\")]]\n                    ),\n                )\n\n            elif args[0].lower().startswith(\"stngs_\"):\n                match = re.match(\"stngs_(.*)\", args[0].lower())\n                chat = dispatcher.bot.getChat(match.group(1))\n\n                if is_user_admin(chat, update.effective_user.id):\n                    send_settings(match.group(1), update.effective_user.id, False)\n                else:\n                    send_settings(match.group(1), update.effective_user.id, True)\n\n            elif args[0][1:].isdigit() and \"rules\" in IMPORTED:\n                IMPORTED[\"rules\"].send_rules(update, args[0], from_pm=True)\n            else:\n                # For other args, let pyrogram handle it or just return\n                return\n        else:\n            # Simple /start without args - let Pyrogram handle it, don't send duplicate\n            return\n    else:\n        update.effective_message.reply_text(\n            \"<b>üëã …™'·¥ç ·¥Ä·¥°·¥Ä·¥ã·¥á ·¥Ä ü Ä·¥á·¥Ä·¥Ö è!</b>\\n<small> ú·¥Ä·¥†·¥á…¥'·¥õ s ü·¥á·¥ò·¥õ s…™…¥·¥Ñ·¥á:</small> <code>{}</code>\".format(\n                uptime\n            ),\n            parse_mode=ParseMode.HTML,\n            disable_web_page_preview=True,\n        )\n\n\ndef error_handler(update, context):\n    \"\"\"Log the error and send a telegram message to notify the developer.\"\"\"\n    # Log the error before we do anything else, so we can see it even if something breaks.\n    LOGGER.error(msg=\"Exception while handling an update:\", exc_info=context.error)\n\n    # traceback.format_exception returns the usual python message about an exception, but as a\n    # list of strings rather than a single string, so we have to join them together.\n    tb_list = traceback.format_exception(\n        None, context.error, context.error.__traceback__\n    )\n    tb = \"\".join(tb_list)\n\n    # Build the message with some markup and additional information about what happened.\n    message = (\n        \"An exception was raised while handling an update\\n\"\n        \"<pre>update = {}</pre>\\n\\n\"\n        \"<pre>{}</pre>\"\n    ).format(\n        html.escape(json.dumps(update.to_dict(), indent=2, ensure_ascii=False)),\n        html.escape(tb),\n    )\n\n    if len(message) >= 4096:\n        message = message[:4096]\n    # Finally, send the message\n    context.bot.send_message(chat_id=OWNER_ID, text=message, parse_mode=ParseMode.HTML)\n\n\n# for test purposes\ndef error_callback(update: Update, context: CallbackContext):\n    error = context.error\n    try:\n        raise error\n    except Unauthorized:\n        print(\"no nono1\")\n        print(error)\n        # remove update.message.chat_id from conversation list\n    except BadRequest:\n        print(\"no nono2\")\n        print(\"BadRequest caught\")\n        print(error)\n\n        # handle malformed requests - read more below!\n    except TimedOut:\n        print(\"no nono3\")\n        # handle slow connection problems\n    except NetworkError:\n        print(\"no nono4\")\n        # handle other connection problems\n    except ChatMigrated as err:\n        print(\"no nono5\")\n        print(err)\n        # the chat_id of a group has changed, use e.new_chat_id instead\n    except TelegramError:\n        print(error)\n        # handle all other telegram related errors\n\n\n@run_async\ndef help_button(update, context):\n    query = update.callback_query\n    mod_match = re.match(r\"help_module\\((.+?)\\)\", query.data)\n    prev_match = re.match(r\"help_prev\\((.+?)\\)\", query.data)\n    next_match = re.match(r\"help_next\\((.+?)\\)\", query.data)\n    back_match = re.match(r\"help_back\", query.data)\n\n    print(query.message.chat.id)\n\n    try:\n        if mod_match:\n            module = mod_match.group(1)\n            text = (\n                \"Here is the help for the *{}* module:\\n\".format(\n                    HELPABLE[module].__mod_name__\n                )\n                + HELPABLE[module].__help__\n            )\n            query.message.edit_text(\n                text=text,\n                parse_mode=ParseMode.MARKDOWN,\n                disable_web_page_preview=True,\n                reply_markup=InlineKeyboardMarkup(\n                    [[InlineKeyboardButton(text=\"Back\", callback_data=\"help_back\")]]\n                ),\n            )\n\n        elif prev_match:\n            curr_page = int(prev_match.group(1))\n            query.message.edit_text(\n                text=HELP_STRINGS,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(curr_page - 1, HELPABLE, \"help\")\n                ),\n            )\n\n        elif next_match:\n            next_page = int(next_match.group(1))\n            query.message.edit_text(\n                text=HELP_STRINGS,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(next_page + 1, HELPABLE, \"help\")\n                ),\n            )\n\n        elif back_match:\n            query.message.edit_text(\n                text=HELP_STRINGS,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(0, HELPABLE, \"help\")\n                ),\n            )\n\n        # ensure no spinny white circle\n        context.bot.answer_callback_query(query.id)\n        # query.message.delete()\n\n    except BadRequest:\n        pass\n\n\n@run_async\ndef sita_about_callback(update, context):\n    query = update.callback_query\n    if query.data == \"sita_\":\n        query.message.edit_text(\n            text=\"\"\" **INNEXIA** it's online since 29 March 2021 and it's constantly updated!\n            \\n**Bot Admins**\n            \n            \\n‚Ä¢ @brahix, bot creator and main developer.\n            \\n‚Ä¢ The Doctor, server manager and developer.\n            \\n‚Ä¢ Manuel 5, developer.\n            \\n**Support**\n            \\n‚Ä¢ [Click here](t.me/BotDevlopers) to consult the updated list of Official Supporters of the bot.\n            \\n‚Ä¢ Thanks to all our **donors** for supporting server and development expenses and all those who have reported bugs or suggested new features.\n            \\n‚Ä¢ We also thank **all the groups** who rely on our Bot for this service, we hope you will always like it: we are constantly working to improve it!\"\"\",\n            parse_mode=ParseMode.MARKDOWN,\n            disable_web_page_preview=True,\n            reply_markup=InlineKeyboardMarkup(\n                [\n                 [\n                    InlineKeyboardButton(text=\"Back\", callback_data=\"sita_back\")\n                 ]\n                ]\n            ),\n        )\n    elif query.data == \"sita_back\":\n        query.message.edit_text(\n                PM_START_TEXT,\n                reply_markup=InlineKeyboardMarkup(buttons),\n                parse_mode=ParseMode.MARKDOWN,\n                timeout=60,\n                disable_web_page_preview=False,\n        )\n\n\n@run_async\ndef Source_about_callback(update, context):\n    query = update.callback_query\n    if query.data == \"source_\":\n        query.message.edit_text(\n            text=\"\"\" Hi..üòª I'm *Sita*\n                 \\nHere is the [üî•Source Codeüî•](https://brahix) .\"\"\",\n            parse_mode=ParseMode.MARKDOWN,\n            disable_web_page_preview=True,\n            reply_markup=InlineKeyboardMarkup(\n                [\n                 [\n                    InlineKeyboardButton(text=\"Go Back\", callback_data=\"source_back\")\n                 ]\n                ]\n            ),\n        )\n    elif query.data == \"source_back\":\n        query.message.edit_text(\n                PM_START_TEXT,\n                reply_markup=InlineKeyboardMarkup(buttons),\n                parse_mode=ParseMode.MARKDOWN,\n                timeout=60,\n                disable_web_page_preview=False,\n        )\n\n@run_async\ndef get_help(update: Update, context: CallbackContext):\n    chat = update.effective_chat  # type: Optional[Chat]\n    args = update.effective_message.text.split(None, 1)\n\n    # ONLY send help in PM\n    if chat.type != chat.PRIVATE:\n        if len(args) >= 2 and any(args[1].lower() == x for x in HELPABLE):\n            module = args[1].lower()\n            update.effective_message.reply_text(\n                f\"Contact me in PM to get help of {module.capitalize()}\",\n                reply_markup=InlineKeyboardMarkup(\n                    [\n                        [\n                            InlineKeyboardButton(\n                                text=\"Help\",\n                                url=\"t.me/{}?start=ghelp_{}\".format(\n                                    context.bot.username, module\n                                ),\n                            )\n                        ]\n                    ]\n                ),\n            )\n            return\n        update.effective_message.reply_text(\n            \"Contact me in PM to get the list of possible commands.\",\n            reply_markup=InlineKeyboardMarkup(\n                [\n                    [\n                        InlineKeyboardButton(\n                            text=\"Help\",\n                            url=\"t.me/{}?start=help\".format(context.bot.username),\n                        )\n                    ]\n                ]\n            ),\n        )\n        return\n\n    elif len(args) >= 2 and any(args[1].lower() == x for x in HELPABLE):\n        module = args[1].lower()\n        text = (\n            \"Here is the available help for the *{}* module:\\n\".format(\n                HELPABLE[module].__mod_name__\n            )\n            + HELPABLE[module].__help__\n        )\n        send_help(\n            chat.id,\n            text,\n            InlineKeyboardMarkup(\n                [[InlineKeyboardButton(text=\"Back\", callback_data=\"help_back\")]]\n            ),\n        )\n\n    else:\n        send_help(chat.id, HELP_STRINGS)\n\n\ndef send_settings(chat_id, user_id, user=False):\n    if user:\n        if USER_SETTINGS:\n            settings = \"\\n\\n\".join(\n                \"*{}*:\\n{}\".format(mod.__mod_name__, mod.__user_settings__(user_id))\n                for mod in USER_SETTINGS.values()\n            )\n            dispatcher.bot.send_message(\n                user_id,\n                \"These are your current settings:\" + \"\\n\\n\" + settings,\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n        else:\n            dispatcher.bot.send_message(\n                user_id,\n                \"Seems like there aren't any user specific settings available :'(\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n    else:\n        if CHAT_SETTINGS:\n            chat_name = dispatcher.bot.getChat(chat_id).title\n            dispatcher.bot.send_message(\n                user_id,\n                text=\"Which module would you like to check {}'s settings for?\".format(\n                    chat_name\n                ),\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(0, CHAT_SETTINGS, \"stngs\", chat=chat_id)\n                ),\n            )\n        else:\n            dispatcher.bot.send_message(\n                user_id,\n                \"Seems like there aren't any chat settings available :'(\\nSend this \"\n                \"in a group chat you're admin in to find its current settings!\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n\n@run_async\ndef settings_button(update: Update, context: CallbackContext):\n    query = update.callback_query\n    user = update.effective_user\n    bot = context.bot\n    mod_match = re.match(r\"stngs_module\\((.+?),(.+?)\\)\", query.data)\n    prev_match = re.match(r\"stngs_prev\\((.+?),(.+?)\\)\", query.data)\n    next_match = re.match(r\"stngs_next\\((.+?),(.+?)\\)\", query.data)\n    back_match = re.match(r\"stngs_back\\((.+?)\\)\", query.data)\n    try:\n        if mod_match:\n            chat_id = mod_match.group(1)\n            module = mod_match.group(2)\n            chat = bot.get_chat(chat_id)\n            text = \"*{}* has the following settings for the *{}* module:\\n\\n\".format(\n                escape_markdown(chat.title), CHAT_SETTINGS[module].__mod_name__\n            ) + CHAT_SETTINGS[module].__chat_settings__(chat_id, user.id)\n            query.message.reply_text(\n                text=text,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(\n                    [\n                        [\n                            InlineKeyboardButton(\n                                text=\"Back\",\n                                callback_data=\"stngs_back({})\".format(chat_id),\n                            )\n                        ]\n                    ]\n                ),\n            )\n\n        elif prev_match:\n            chat_id = prev_match.group(1)\n            curr_page = int(prev_match.group(2))\n            chat = bot.get_chat(chat_id)\n            query.message.reply_text(\n                \"Hi there! There are quite a few settings for {} - go ahead and pick what \"\n                \"you're interested in.\".format(chat.title),\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(\n                        curr_page - 1, CHAT_SETTINGS, \"stngs\", chat=chat_id\n                    )\n                ),\n            )\n\n        elif next_match:\n            chat_id = next_match.group(1)\n            next_page = int(next_match.group(2))\n            chat = bot.get_chat(chat_id)\n            query.message.reply_text(\n                \"Hi there! There are quite a few settings for {} - go ahead and pick what \"\n                \"you're interested in.\".format(chat.title),\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(\n                        next_page + 1, CHAT_SETTINGS, \"stngs\", chat=chat_id\n                    )\n                ),\n            )\n\n        elif back_match:\n            chat_id = back_match.group(1)\n            chat = bot.get_chat(chat_id)\n            query.message.reply_text(\n                text=\"Hi there! There are quite a few settings for {} - go ahead and pick what \"\n                \"you're interested in.\".format(escape_markdown(chat.title)),\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=InlineKeyboardMarkup(\n                    paginate_modules(0, CHAT_SETTINGS, \"stngs\", chat=chat_id)\n                ),\n            )\n\n        # ensure no spinny white circle\n        bot.answer_callback_query(query.id)\n        query.message.delete()\n    except BadRequest as excp:\n        if excp.message not in [\n            \"Message is not modified\",\n            \"Query_id_invalid\",\n            \"Message can't be deleted\",\n        ]:\n            LOGGER.exception(\"Exception in settings buttons. %s\", str(query.data))\n\n\n@run_async\ndef get_settings(update: Update, context: CallbackContext):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    msg = update.effective_message  # type: Optional[Message]\n\n    # ONLY send settings in PM\n    if chat.type != chat.PRIVATE:\n        if is_user_admin(chat, user.id):\n            text = \"Click here to get this chat's settings, as well as yours.\"\n            msg.reply_text(\n                text,\n                reply_markup=InlineKeyboardMarkup(\n                    [\n                        [\n                            InlineKeyboardButton(\n                                text=\"Settings\",\n                                url=\"t.me/{}?start=stngs_{}\".format(\n                                    context.bot.username, chat.id\n                                ),\n                            )\n                        ]\n                    ]\n                ),\n            )\n        else:\n            text = \"Click here to check your settings.\"\n\n    else:\n        send_settings(chat.id, user.id, True)\n\n\n@run_async\ndef donate(update: Update, context: CallbackContext):\n    user = update.effective_message.from_user\n    chat = update.effective_chat  # type: Optional[Chat]\n    bot = context.bot\n    if chat.type == \"private\":\n        update.effective_message.reply_text(\n            DONATE_STRING, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True\n        )\n\n        if OWNER_ID != 1947924017 and DONATION_LINK:\n            update.effective_message.reply_text(\n                \"You can also donate to the person currently running me \"\n                \"[here]({})\".format(DONATION_LINK),\n                parse_mode=ParseMode.MARKDOWN,\n            )\n\n    else:\n        try:\n            bot.send_message(\n                user.id,\n                DONATE_STRING,\n                parse_mode=ParseMode.MARKDOWN,\n                disable_web_page_preview=True,\n            )\n\n            update.effective_message.reply_text(\n                \"I've PM'ed you about donating to my creator!\"\n            )\n        except Unauthorized:\n            update.effective_message.reply_text(\n                \"Contact me in PM first to get donation information.\"\n            )\n\n\ndef migrate_chats(update: Update, context: CallbackContext):\n    msg = update.effective_message  # type: Optional[Message]\n    if msg.migrate_to_chat_id:\n        old_chat = update.effective_chat.id\n        new_chat = msg.migrate_to_chat_id\n    elif msg.migrate_from_chat_id:\n        old_chat = msg.migrate_from_chat_id\n        new_chat = update.effective_chat.id\n    else:\n        return\n\n    LOGGER.info(\"Migrating from %s, to %s\", str(old_chat), str(new_chat))\n    for mod in MIGRATEABLE:\n        mod.__migrate__(old_chat, new_chat)\n\n    LOGGER.info(\"Successfully migrated!\")\n    raise DispatcherHandlerStop\n\n\ndef main():\n\n    if SUPPORT_CHAT is not None and isinstance(SUPPORT_CHAT, str):\n        try:\n            dispatcher.bot.sendMessage(f\"@{SUPPORT_CHAT}\", \"`Yes I'm Fine` üòπ\")\n        except Unauthorized:\n            LOGGER.warning(\n                \"Bot isnt able to send message to support_chat, go and check!\"\n            )\n        except BadRequest as e:\n            LOGGER.warning(e.message)\n\n    test_handler = CommandHandler(\"test\", test)\n    start_handler = CommandHandler(\"start\", start)  # Fallback handler for telegram bot\n\n    help_handler = CommandHandler(\"help\", get_help)\n    help_callback_handler = CallbackQueryHandler(help_button, pattern=r\"help_.*\")\n\n    settings_handler = CommandHandler(\"settings\", get_settings)\n    settings_callback_handler = CallbackQueryHandler(settings_button, pattern=r\"stngs_\")\n\n    about_callback_handler = CallbackQueryHandler(sita_about_callback, pattern=r\"sita_\")\n    source_callback_handler = CallbackQueryHandler(Source_about_callback, pattern=r\"source_\")\n\n    donate_handler = CommandHandler(\"donate\", donate)\n    migrate_handler = MessageHandler(Filters.status_update.migrate, migrate_chats)\n\n    # dispatcher.add_handler(test_handler)\n    dispatcher.add_handler(start_handler)  # Fallback for telegram bot, pyrogram uses start_stylish.py\n    dispatcher.add_handler(help_handler)\n    dispatcher.add_handler(about_callback_handler)\n    dispatcher.add_handler(source_callback_handler)\n    dispatcher.add_handler(settings_handler)\n    dispatcher.add_handler(help_callback_handler)\n    dispatcher.add_handler(settings_callback_handler)\n    dispatcher.add_handler(migrate_handler)\n    dispatcher.add_handler(donate_handler)\n\n    dispatcher.add_error_handler(error_callback)\n\n    if WEBHOOK:\n        LOGGER.info(\"Using webhooks.\")\n        updater.start_webhook(listen=\"0.0.0.0\", port=PORT, url_path=TOKEN)\n\n        if CERT_PATH:\n            updater.bot.set_webhook(url=URL + TOKEN, certificate=open(CERT_PATH, \"rb\"))\n        else:\n            updater.bot.set_webhook(url=URL + TOKEN)\n\n    else:\n        LOGGER.info(\"Using long polling.\")\n        updater.start_polling(timeout=15, read_latency=4, clean=True)\n\n    if len(argv) not in (1, 3, 4):\n        telethn.disconnect()\n    else:\n        telethn.run_until_disconnected()\n\n    updater.idle()\n\n\nif __name__ == \"__main__\":\n    LOGGER.info(\"Successfully loaded modules: \" + str(ALL_MODULES))\n    telethn.start(bot_token=TOKEN)\n    pbot.start()\n    main()\n","size_bytes":26745},"sitaBot/modules/__nightmode.py":{"content":"import os\n\nfrom sitaBot.modules.sql_extended.night_mode_sql import add_nightmode, rmnightmode, get_all_chat_id, is_nightmode_indb\nfrom telethon.tl.types import ChatBannedRights\nfrom apscheduler.schedulers.background import BackgroundScheduler\nfrom telethon import functions\nfrom sitaBot.events import register\nfrom sitaBot import OWNER_ID, LOGGER as logger\nfrom sitaBot import telethn as tbot\nfrom telethon import *\nfrom telethon import Button, custom, events\n\nhehes = ChatBannedRights(\n    until_date=None,\n    send_messages=True,\n    send_media=True,\n    send_stickers=True,\n    send_gifs=True,\n    send_games=True,\n    send_inline=True,\n    send_polls=True,\n    invite_users=True,\n    pin_messages=True,\n    change_info=True,\n)\n\nopenhehe = ChatBannedRights(\n    until_date=None,\n    send_messages=False,\n    send_media=False,\n    send_stickers=False,\n    send_gifs=False,\n    send_games=False,\n    send_inline=False,\n    send_polls=False,\n    invite_users=True,\n    pin_messages=True,\n    change_info=True,\n)\n\nfrom telethon.tl.types import (\n    ChannelParticipantsAdmins,\n    ChatAdminRights,\n    MessageEntityMentionName,\n    MessageMediaPhoto,\n)\n\nfrom telethon.tl.functions.channels import (\n    EditAdminRequest,\n    EditBannedRequest,\n    EditPhotoRequest,\n)\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n        return isinstance(\n            (\n                await tbot(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerUser):\n        return True\n\nasync def can_change_info(message):\n    result = await tbot(\n        functions.channels.GetParticipantRequest(\n            channel=message.chat_id,\n            user_id=message.sender_id,\n        )\n    )\n    p = result.participant\n    return isinstance(p, types.ChannelParticipantCreator) or (\n        isinstance(p, types.ChannelParticipantAdmin) and p.admin_rights.change_info\n    )\n\n@register(pattern=\"^/(nightmode|Nightmode|NightMode) ?(.*)\")\nasync def profanity(event):\n    if event.fwd_from:\n        return\n    if event.is_private:\n        return\n    input = event.pattern_match.group(2)\n    if not event.sender_id == OWNER_ID:\n        if not await is_register_admin(event.input_chat, event.sender_id):\n           await event.reply(\"Only admins can execute this command!\")\n           return\n        else:\n          if not await can_change_info(message=event):\n            await event.reply(\"You are missing the following rights to use this command:CanChangeinfo\")\n            return\n    if not input:\n        if is_nightmode_indb(str(event.chat_id)):\n                await event.reply(\n                    \"Currently NightMode is Enabled for this Chat\"\n                )\n                return\n        await event.reply(\n            \"Currently NightMode is Disabled for this Chat\"\n        )\n        return\n    if \"on\" in input:\n        if event.is_group:\n            if is_nightmode_indb(str(event.chat_id)):\n                    await event.reply(\n                        \"Night Mode is Already Turned ON for this Chat\"\n                    )\n                    return\n            add_nightmode(str(event.chat_id))\n            await event.reply(\"NightMode turned on for this chat.\")\n    if \"off\" in input:\n        if event.is_group:\n            if not is_nightmode_indb(str(event.chat_id)):\n                    await event.reply(\n                        \"Night Mode is Already Off for this Chat\"\n                    )\n                    return\n        rmnightmode(str(event.chat_id))\n        await event.reply(\"NightMode Disabled!\")\n    if not \"off\" in input and not \"on\" in input:\n        await event.reply(\"Please Specify On or Off!\")\n        return\n\n\nasync def job_close():\n    chats = get_all_chat_id()\n    if len(chats) == 0:\n        return\n    for pro in chats:\n        try:\n            await tbot.send_message(\n              int(pro.chat_id), \"12:00 Am, Group Is Closing Till 6 Am. Night Mode Started ! \\n**Powered By Evlie**\"\n            )\n            await tbot(\n            functions.messages.EditChatDefaultBannedRightsRequest(\n                peer=int(pro.chat_id), banned_rights=hehes\n            )\n            )\n        except Exception as e:\n            logger.info(f\"Unable To Close Group {chat} - {e}\")\n\n# Run everyday at 12am using a background scheduler (no running loop required)\nscheduler = BackgroundScheduler(timezone=\"Asia/Kolkata\")\nscheduler.add_job(job_close, trigger=\"cron\", hour=23, minute=59)\nscheduler.start()\n\nasync def job_open():\n    chats = get_all_chat_id()\n    if len(chats) == 0:\n        return\n    for pro in chats:\n        try:\n            await tbot.send_message(\n              int(pro.chat_id), \"06:00 Am, Group Is Opening.\\n**Powered By Masha**\"\n            )\n            await tbot(\n            functions.messages.EditChatDefaultBannedRightsRequest(\n                peer=int(pro.chat_id), banned_rights=openhehe\n            )\n        )\n        except Exception as e:\n            logger.info(f\"Unable To Open Group {pro.chat_id} - {e}\")\n\n# Run everyday at 06 using the same background scheduler\nscheduler.add_job(job_open, trigger=\"cron\", hour=5, minute=58)\n\n\n__help__ = f\"\"\"\n ‚ùç /nightmode on/off\n \n**Note:** Night Mode chats get Automatically closed at 12pm(IST)\nand Automatically openned at 6am(IST) To Prevent Night Spams.\n\"\"\"\n\n__mod_name__ = \"NtMode\"\n","size_bytes":5488},"sitaBot/modules/helper_funcs/extraction.py":{"content":"from typing import List, Optional\n\nfrom sitaBot import LOGGER\nfrom sitaBot.modules.users import get_user_id\nfrom telegram import Message, MessageEntity\nfrom telegram.error import BadRequest\n\n\ndef id_from_reply(message):\n    prev_message = message.reply_to_message\n    if not prev_message:\n        return None, None\n    user_id = prev_message.from_user.id\n    res = message.text.split(None, 1)\n    if len(res) < 2:\n        return user_id, \"\"\n    return user_id, res[1]\n\n\ndef extract_user(message: Message, args: List[str]) -> Optional[int]:\n    return extract_user_and_text(message, args)[0]\n\n\ndef extract_user_and_text(\n    message: Message, args: List[str]\n) -> (Optional[int], Optional[str]):\n    prev_message = message.reply_to_message\n    split_text = message.text.split(None, 1)\n\n    if len(split_text) < 2:\n        return id_from_reply(message)  # only option possible\n\n    text_to_parse = split_text[1]\n\n    text = \"\"\n\n    entities = list(message.parse_entities([MessageEntity.TEXT_MENTION]))\n    ent = entities[0] if entities else None\n    # if entity offset matches (command end/text start) then all good\n    if entities and ent and ent.offset == len(message.text) - len(text_to_parse):\n        ent = entities[0]\n        user_id = ent.user.id\n        text = message.text[ent.offset + ent.length :]\n\n    elif len(args) >= 1 and args[0][0] == \"@\":\n        user = args[0]\n        user_id = get_user_id(user)\n        if not user_id:\n            message.reply_text(\n                \"No idea who this user is. You'll be able to interact with them if \"\n                \"you reply to that person's message instead, or forward one of that user's messages.\"\n            )\n            return None, None\n\n        else:\n            user_id = user_id\n            res = message.text.split(None, 2)\n            if len(res) >= 3:\n                text = res[2]\n\n    elif len(args) >= 1 and args[0].isdigit():\n        user_id = int(args[0])\n        res = message.text.split(None, 2)\n        if len(res) >= 3:\n            text = res[2]\n\n    elif prev_message:\n        user_id, text = id_from_reply(message)\n\n    else:\n        return None, None\n\n    try:\n        message.bot.get_chat(user_id)\n    except BadRequest as excp:\n        if excp.message in (\"User_id_invalid\", \"Chat not found\"):\n            message.reply_text(\n                \"I don't seem to have interacted with this user before - please forward a message from \"\n                \"them to give me control! (like a voodoo doll, I need a piece of them to be able \"\n                \"to execute certain commands...)\"\n            )\n        else:\n            LOGGER.exception(\"Exception %s on user %s\", excp.message, user_id)\n\n        return None, None\n\n    return user_id, text\n\n\ndef extract_text(message) -> str:\n    return (\n        message.text\n        or message.caption\n        or (message.sticker.emoji if message.sticker else None)\n    )\n\n\ndef extract_unt_fedban(\n    message: Message, args: List[str]\n) -> (Optional[int], Optional[str]):\n    prev_message = message.reply_to_message\n    split_text = message.text.split(None, 1)\n\n    if len(split_text) < 2:\n        return id_from_reply(message)  # only option possible\n\n    text_to_parse = split_text[1]\n\n    text = \"\"\n\n    entities = list(message.parse_entities([MessageEntity.TEXT_MENTION]))\n    ent = entities[0] if entities else None\n    # if entity offset matches (command end/text start) then all good\n    if entities and ent and ent.offset == len(message.text) - len(text_to_parse):\n        ent = entities[0]\n        user_id = ent.user.id\n        text = message.text[ent.offset + ent.length :]\n\n    elif len(args) >= 1 and args[0][0] == \"@\":\n        user = args[0]\n        user_id = get_user_id(user)\n        if not user_id and not isinstance(user_id, int):\n            message.reply_text(\n                \"I don't have that user in my db.  \"\n                \"You'll be able to interact with them if you reply to that person's message instead, or forward one of that user's messages.\"\n            )\n            return None, None\n\n        else:\n            user_id = user_id\n            res = message.text.split(None, 2)\n            if len(res) >= 3:\n                text = res[2]\n\n    elif len(args) >= 1 and args[0].isdigit():\n        user_id = int(args[0])\n        res = message.text.split(None, 2)\n        if len(res) >= 3:\n            text = res[2]\n\n    elif prev_message:\n        user_id, text = id_from_reply(message)\n\n    else:\n        return None, None\n\n    try:\n        message.bot.get_chat(user_id)\n    except BadRequest as excp:\n        if excp.message in (\"User_id_invalid\", \"Chat not found\") and not isinstance(\n            user_id, int\n        ):\n            message.reply_text(\n                \"I don't seem to have interacted with this user before \"\n                \"please forward a message from them to give me control! \"\n                \"(like a voodoo doll, I need a piece of them to be able to execute certain commands...)\"\n            )\n            return None, None\n        elif excp.message != \"Chat not found\":\n            LOGGER.exception(\"Exception %s on user %s\", excp.message, user_id)\n            return None, None\n        elif not isinstance(user_id, int):\n            return None, None\n\n    return user_id, text\n\n\ndef extract_user_fban(message: Message, args: List[str]) -> Optional[int]:\n    return extract_unt_fedban(message, args)[0]\n","size_bytes":5379},"sitaBot/modules/sql/cleaner_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, UnicodeText\n\n\nclass CleanerBlueTextChatSettings(BASE):\n    __tablename__ = \"cleaner_bluetext_chat_setting\"\n    chat_id = Column(UnicodeText, primary_key=True)\n    is_enable = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, is_enable):\n        self.chat_id = chat_id\n        self.is_enable = is_enable\n\n    def __repr__(self):\n        return \"clean blue text for {}\".format(self.chat_id)\n\n\nclass CleanerBlueTextChat(BASE):\n    __tablename__ = \"cleaner_bluetext_chat_ignore_commands\"\n    chat_id = Column(UnicodeText, primary_key=True)\n    command = Column(UnicodeText, primary_key=True)\n\n    def __init__(self, chat_id, command):\n        self.chat_id = chat_id\n        self.command = command\n\n\nclass CleanerBlueTextGlobal(BASE):\n    __tablename__ = \"cleaner_bluetext_global_ignore_commands\"\n    command = Column(UnicodeText, primary_key=True)\n\n    def __init__(self, command):\n        self.command = command\n\n\nCleanerBlueTextChatSettings.__table__.create(checkfirst=True)\nCleanerBlueTextChat.__table__.create(checkfirst=True)\nCleanerBlueTextGlobal.__table__.create(checkfirst=True)\n\nCLEANER_CHAT_SETTINGS = threading.RLock()\nCLEANER_CHAT_LOCK = threading.RLock()\nCLEANER_GLOBAL_LOCK = threading.RLock()\n\nCLEANER_CHATS = {}\nGLOBAL_IGNORE_COMMANDS = set()\n\n\ndef set_cleanbt(chat_id, is_enable):\n    with CLEANER_CHAT_SETTINGS:\n        curr = SESSION.query(CleanerBlueTextChatSettings).get(str(chat_id))\n\n        if not curr:\n            curr = CleanerBlueTextChatSettings(str(chat_id), is_enable)\n        else:\n            curr.is_enabled = is_enable\n\n        if str(chat_id) not in CLEANER_CHATS:\n            CLEANER_CHATS.setdefault(\n                str(chat_id), {\"setting\": False, \"commands\": set()}\n            )\n\n        CLEANER_CHATS[str(chat_id)][\"setting\"] = is_enable\n\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef chat_ignore_command(chat_id, ignore):\n    ignore = ignore.lower()\n    with CLEANER_CHAT_LOCK:\n        ignored = SESSION.query(CleanerBlueTextChat).get((str(chat_id), ignore))\n\n        if not ignored:\n\n            if str(chat_id) not in CLEANER_CHATS:\n                CLEANER_CHATS.setdefault(\n                    str(chat_id), {\"setting\": False, \"commands\": set()}\n                )\n\n            CLEANER_CHATS[str(chat_id)][\"commands\"].add(ignore)\n\n            ignored = CleanerBlueTextChat(str(chat_id), ignore)\n            SESSION.add(ignored)\n            SESSION.commit()\n            return True\n        SESSION.close()\n        return False\n\n\ndef chat_unignore_command(chat_id, unignore):\n    unignore = unignore.lower()\n    with CLEANER_CHAT_LOCK:\n        unignored = SESSION.query(CleanerBlueTextChat).get((str(chat_id), unignore))\n\n        if unignored:\n\n            if str(chat_id) not in CLEANER_CHATS:\n                CLEANER_CHATS.setdefault(\n                    str(chat_id), {\"setting\": False, \"commands\": set()}\n                )\n            if unignore in CLEANER_CHATS.get(str(chat_id)).get(\"commands\"):\n                CLEANER_CHATS[str(chat_id)][\"commands\"].remove(unignore)\n\n            SESSION.delete(unignored)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef global_ignore_command(command):\n    command = command.lower()\n    with CLEANER_GLOBAL_LOCK:\n        ignored = SESSION.query(CleanerBlueTextGlobal).get(str(command))\n\n        if not ignored:\n            GLOBAL_IGNORE_COMMANDS.add(command)\n\n            ignored = CleanerBlueTextGlobal(str(command))\n            SESSION.add(ignored)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef global_unignore_command(command):\n    command = command.lower()\n    with CLEANER_GLOBAL_LOCK:\n        unignored = SESSION.query(CleanerBlueTextGlobal).get(str(command))\n\n        if unignored:\n            if command in GLOBAL_IGNORE_COMMANDS:\n                GLOBAL_IGNORE_COMMANDS.remove(command)\n\n            SESSION.delete(command)\n            SESSION.commit()\n            return True\n\n        SESSION.close()\n        return False\n\n\ndef is_command_ignored(chat_id, command):\n    if command.lower() in GLOBAL_IGNORE_COMMANDS:\n        return True\n\n    if str(chat_id) in CLEANER_CHATS:\n        if command.lower() in CLEANER_CHATS.get(str(chat_id)).get(\"commands\"):\n            return True\n\n    return False\n\n\ndef is_enabled(chat_id):\n    if str(chat_id) in CLEANER_CHATS:\n        settings = CLEANER_CHATS.get(str(chat_id)).get(\"setting\")\n        return settings\n\n    return False\n\n\ndef get_all_ignored(chat_id):\n    if str(chat_id) in CLEANER_CHATS:\n        LOCAL_IGNORE_COMMANDS = CLEANER_CHATS.get(str(chat_id)).get(\"commands\")\n    else:\n        LOCAL_IGNORE_COMMANDS = set()\n\n    return GLOBAL_IGNORE_COMMANDS, LOCAL_IGNORE_COMMANDS\n\n\ndef __load_cleaner_list():\n    global GLOBAL_IGNORE_COMMANDS\n    global CLEANER_CHATS\n\n    try:\n        GLOBAL_IGNORE_COMMANDS = {\n            int(x.command) for x in SESSION.query(CleanerBlueTextGlobal).all()\n        }\n    finally:\n        SESSION.close()\n\n    try:\n        for x in SESSION.query(CleanerBlueTextChatSettings).all():\n            CLEANER_CHATS.setdefault(x.chat_id, {\"setting\": False, \"commands\": set()})\n            CLEANER_CHATS[x.chat_id][\"setting\"] = x.is_enable\n    finally:\n        SESSION.close()\n\n    try:\n        for x in SESSION.query(CleanerBlueTextChat).all():\n            CLEANER_CHATS.setdefault(x.chat_id, {\"setting\": False, \"commands\": set()})\n            CLEANER_CHATS[x.chat_id][\"commands\"].add(x.command)\n    finally:\n        SESSION.close()\n\n\n__load_cleaner_list()\n","size_bytes":5663},"sitaBot/modules/blacklist_stickers.py":{"content":"import html\nfrom typing import Optional\n\nimport sitaBot.modules.sql.blsticker_sql as sql\nfrom sitaBot import LOGGER, dispatcher\nfrom sitaBot.modules.connection import connected\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.alternate import send_message\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin, user_not_admin\nfrom sitaBot.modules.helper_funcs.misc import split_message\nfrom sitaBot.modules.helper_funcs.string_handling import extract_time\n\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.warns import warn\nfrom telegram import Chat, Message, ParseMode, Update, User, ChatPermissions\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, Filters, MessageHandler\nfrom telegram.ext.dispatcher import run_async\nfrom telegram.utils.helpers import mention_html, mention_markdown\n\n\n@run_async\ndef blackliststicker(update: Update, context: CallbackContext):\n    msg = update.effective_message  # type: Optional[Message]\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    bot, args = context.bot, context.args\n    conn = connected(bot, update, chat, user.id, need_admin=False)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if chat.type == \"private\":\n            return\n        chat_id = update.effective_chat.id\n        chat_name = chat.title\n\n    sticker_list = \"<b>List blacklisted stickers currently in {}:</b>\\n\".format(\n        chat_name\n    )\n\n    all_stickerlist = sql.get_chat_stickers(chat_id)\n\n    if len(args) > 0 and args[0].lower() == \"copy\":\n        for trigger in all_stickerlist:\n            sticker_list += \"<code>{}</code>\\n\".format(html.escape(trigger))\n    elif len(args) == 0:\n        for trigger in all_stickerlist:\n            sticker_list += \" - <code>{}</code>\\n\".format(html.escape(trigger))\n\n    split_text = split_message(sticker_list)\n    for text in split_text:\n        if sticker_list == \"<b>List blacklisted stickers currently in {}:</b>\\n\".format(\n            chat_name\n        ).format(html.escape(chat_name)):\n            send_message(\n                update.effective_message,\n                \"There are no blacklist stickers in <b>{}</b>!\".format(\n                    html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n            return\n    send_message(update.effective_message, text, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@user_admin\ndef add_blackliststicker(update: Update, context: CallbackContext):\n    bot = context.bot\n    msg = update.effective_message  # type: Optional[Message]\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    words = msg.text.split(None, 1)\n    bot = context.bot\n    conn = connected(bot, update, chat, user.id)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            return\n        else:\n            chat_name = chat.title\n\n    if len(words) > 1:\n        text = words[1].replace(\"https://t.me/addstickers/\", \"\")\n        to_blacklist = list(\n            {trigger.strip() for trigger in text.split(\"\\n\") if trigger.strip()}\n        )\n\n        added = 0\n        for trigger in to_blacklist:\n            try:\n                get = bot.getStickerSet(trigger)\n                sql.add_to_stickers(chat_id, trigger.lower())\n                added += 1\n            except BadRequest:\n                send_message(\n                    update.effective_message,\n                    \"Sticker `{}` can not be found!\".format(trigger),\n                    parse_mode=\"markdown\",\n                )\n\n        if added == 0:\n            return\n\n        if len(to_blacklist) == 1:\n            send_message(\n                update.effective_message,\n                \"Sticker <code>{}</code> added to blacklist stickers in <b>{}</b>!\".format(\n                    html.escape(to_blacklist[0]), html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n        else:\n            send_message(\n                update.effective_message,\n                \"<code>{}</code> stickers added to blacklist sticker in <b>{}</b>!\".format(\n                    added, html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n    elif msg.reply_to_message:\n        added = 0\n        trigger = msg.reply_to_message.sticker.set_name\n        if trigger is None:\n            send_message(update.effective_message, \"Sticker is invalid!\")\n            return\n        try:\n            get = bot.getStickerSet(trigger)\n            sql.add_to_stickers(chat_id, trigger.lower())\n            added += 1\n        except BadRequest:\n            send_message(\n                update.effective_message,\n                \"Sticker `{}` can not be found!\".format(trigger),\n                parse_mode=\"markdown\",\n            )\n\n        if added == 0:\n            return\n\n        send_message(\n            update.effective_message,\n            \"Sticker <code>{}</code> added to blacklist stickers in <b>{}</b>!\".format(\n                trigger, html.escape(chat_name)\n            ),\n            parse_mode=ParseMode.HTML,\n        )\n    else:\n        send_message(\n            update.effective_message,\n            \"Tell me what stickers you want to add to the blacklist.\",\n        )\n\n\n@run_async\n@user_admin\ndef unblackliststicker(update: Update, context: CallbackContext):\n    bot = context.bot\n    msg = update.effective_message  # type: Optional[Message]\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    words = msg.text.split(None, 1)\n    bot = context.bot\n    conn = connected(bot, update, chat, user.id)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        chat_id = update.effective_chat.id\n        if chat.type == \"private\":\n            return\n        else:\n            chat_name = chat.title\n\n    if len(words) > 1:\n        text = words[1].replace(\"https://t.me/addstickers/\", \"\")\n        to_unblacklist = list(\n            {trigger.strip() for trigger in text.split(\"\\n\") if trigger.strip()}\n        )\n\n        successful = 0\n        for trigger in to_unblacklist:\n            success = sql.rm_from_stickers(chat_id, trigger.lower())\n            if success:\n                successful += 1\n\n        if len(to_unblacklist) == 1:\n            if successful:\n                send_message(\n                    update.effective_message,\n                    \"Sticker <code>{}</code> deleted from blacklist in <b>{}</b>!\".format(\n                        html.escape(to_unblacklist[0]), html.escape(chat_name)\n                    ),\n                    parse_mode=ParseMode.HTML,\n                )\n            else:\n                send_message(\n                    update.effective_message, \"This sticker is not on the blacklist...!\"\n                )\n\n        elif successful == len(to_unblacklist):\n            send_message(\n                update.effective_message,\n                \"Sticker <code>{}</code> deleted from blacklist in <b>{}</b>!\".format(\n                    successful, html.escape(chat_name)\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n\n        elif not successful:\n            send_message(\n                update.effective_message,\n                \"None of these stickers exist, so they cannot be removed.\",\n                parse_mode=ParseMode.HTML,\n            )\n\n        else:\n            send_message(\n                update.effective_message,\n                \"Sticker <code>{}</code> deleted from blacklist. {} did not exist, so it's not deleted.\".format(\n                    successful, len(to_unblacklist) - successful\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n    elif msg.reply_to_message:\n        trigger = msg.reply_to_message.sticker.set_name\n        if trigger is None:\n            send_message(update.effective_message, \"Sticker is invalid!\")\n            return\n        success = sql.rm_from_stickers(chat_id, trigger.lower())\n\n        if success:\n            send_message(\n                update.effective_message,\n                \"Sticker <code>{}</code> deleted from blacklist in <b>{}</b>!\".format(\n                    trigger, chat_name\n                ),\n                parse_mode=ParseMode.HTML,\n            )\n        else:\n            send_message(\n                update.effective_message,\n                \"{} not found on blacklisted stickers...!\".format(trigger),\n            )\n    else:\n        send_message(\n            update.effective_message,\n            \"Tell me what stickers you want to add to the blacklist.\",\n        )\n\n\n@run_async\n@loggable\n@user_admin\ndef blacklist_mode(update: Update, context: CallbackContext):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    msg = update.effective_message  # type: Optional[Message]\n    bot, args = context.bot, context.args\n    conn = connected(bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message, \"You can do this command in groups, not PM\"\n            )\n            return \"\"\n        chat = update.effective_chat\n        chat_id = update.effective_chat.id\n        chat_name = update.effective_message.chat.title\n\n    if args:\n        if args[0].lower() in [\"off\", \"nothing\", \"no\"]:\n            settypeblacklist = \"turn off\"\n            sql.set_blacklist_strength(chat_id, 0, \"0\")\n        elif args[0].lower() in [\"del\", \"delete\"]:\n            settypeblacklist = \"left, the message will be deleted\"\n            sql.set_blacklist_strength(chat_id, 1, \"0\")\n        elif args[0].lower() == \"warn\":\n            settypeblacklist = \"warned\"\n            sql.set_blacklist_strength(chat_id, 2, \"0\")\n        elif args[0].lower() == \"mute\":\n            settypeblacklist = \"muted\"\n            sql.set_blacklist_strength(chat_id, 3, \"0\")\n        elif args[0].lower() == \"kick\":\n            settypeblacklist = \"kicked\"\n            sql.set_blacklist_strength(chat_id, 4, \"0\")\n        elif args[0].lower() == \"ban\":\n            settypeblacklist = \"banned\"\n            sql.set_blacklist_strength(chat_id, 5, \"0\")\n        elif args[0].lower() == \"tban\":\n            if len(args) == 1:\n                teks = \"\"\"It looks like you are trying to set a temporary value to blacklist, but has not determined the time; use `/blstickermode tban <timevalue>`.\n                                          Examples of time values: 4m = 4 minute, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return\n            settypeblacklist = \"temporary banned for {}\".format(args[1])\n            sql.set_blacklist_strength(chat_id, 6, str(args[1]))\n        elif args[0].lower() == \"tmute\":\n            if len(args) == 1:\n                teks = \"\"\"It looks like you are trying to set a temporary value to blacklist, but has not determined the time; use `/blstickermode tmute <timevalue>`.\n                                          Examples of time values: 4m = 4 minute, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return\n            settypeblacklist = \"temporary muted for {}\".format(args[1])\n            sql.set_blacklist_strength(chat_id, 7, str(args[1]))\n        else:\n            send_message(\n                update.effective_message,\n                \"I only understand off/del/warn/ban/kick/mute/tban/tmute!\",\n            )\n            return\n        if conn:\n            text = \"Blacklist sticker mode changed, users will be `{}` at *{}*!\".format(\n                settypeblacklist, chat_name\n            )\n        else:\n            text = \"Blacklist sticker mode changed, users will be `{}`!\".format(\n                settypeblacklist\n            )\n        send_message(update.effective_message, text, parse_mode=\"markdown\")\n        return (\n            \"<b>{}:</b>\\n\"\n            \"<b>Admin:</b> {}\\n\"\n            \"Changed sticker blacklist mode. users will be {}.\".format(\n                html.escape(chat.title),\n                mention_html(user.id, html.escape(user.first_name)),\n                settypeblacklist,\n            )\n        )\n    else:\n        getmode, getvalue = sql.get_blacklist_setting(chat.id)\n        if getmode == 0:\n            settypeblacklist = \"not active\"\n        elif getmode == 1:\n            settypeblacklist = \"delete\"\n        elif getmode == 2:\n            settypeblacklist = \"warn\"\n        elif getmode == 3:\n            settypeblacklist = \"mute\"\n        elif getmode == 4:\n            settypeblacklist = \"kick\"\n        elif getmode == 5:\n            settypeblacklist = \"ban\"\n        elif getmode == 6:\n            settypeblacklist = \"temporarily banned for {}\".format(getvalue)\n        elif getmode == 7:\n            settypeblacklist = \"temporarily muted for {}\".format(getvalue)\n        if conn:\n            text = \"Blacklist sticker mode is currently set to *{}* in *{}*.\".format(\n                settypeblacklist, chat_name\n            )\n        else:\n            text = \"Blacklist sticker mode is currently set to *{}*.\".format(\n                settypeblacklist\n            )\n        send_message(update.effective_message, text, parse_mode=ParseMode.MARKDOWN)\n    return \"\"\n\n\n@run_async\n@user_not_admin\ndef del_blackliststicker(update: Update, context: CallbackContext):\n    bot = context.bot\n    chat = update.effective_chat  # type: Optional[Chat]\n    message = update.effective_message  # type: Optional[Message]\n    user = update.effective_user\n    to_match = message.sticker\n    if not to_match or not to_match.set_name:\n        return\n    bot = context.bot\n    getmode, value = sql.get_blacklist_setting(chat.id)\n\n    chat_filters = sql.get_chat_stickers(chat.id)\n    for trigger in chat_filters:\n        if to_match.set_name.lower() == trigger.lower():\n            try:\n                if getmode == 0:\n                    return\n                elif getmode == 1:\n                    message.delete()\n                elif getmode == 2:\n                    message.delete()\n                    warn(\n                        update.effective_user,\n                        chat,\n                        \"Using sticker '{}' which in blacklist stickers\".format(\n                            trigger\n                        ),\n                        message,\n                        update.effective_user,\n                        # conn=False,\n                    )\n                    return\n                elif getmode == 3:\n                    message.delete()\n                    bot.restrict_chat_member(\n                        chat.id,\n                        update.effective_user.id,\n                        permissions=ChatPermissions(can_send_messages=False),\n                    )\n                    bot.sendMessage(\n                        chat.id,\n                        \"{} muted because using '{}' which in blacklist stickers\".format(\n                            mention_markdown(user.id, user.first_name), trigger\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n                    return\n                elif getmode == 4:\n                    message.delete()\n                    res = chat.unban_member(update.effective_user.id)\n                    if res:\n                        bot.sendMessage(\n                            chat.id,\n                            \"{} kicked because using '{}' which in blacklist stickers\".format(\n                                mention_markdown(user.id, user.first_name), trigger\n                            ),\n                            parse_mode=\"markdown\",\n                        )\n                    return\n                elif getmode == 5:\n                    message.delete()\n                    chat.kick_member(user.id)\n                    bot.sendMessage(\n                        chat.id,\n                        \"{} banned because using '{}' which in blacklist stickers\".format(\n                            mention_markdown(user.id, user.first_name), trigger\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n                    return\n                elif getmode == 6:\n                    message.delete()\n                    bantime = extract_time(message, value)\n                    chat.kick_member(user.id, until_date=bantime)\n                    bot.sendMessage(\n                        chat.id,\n                        \"{} banned for {} because using '{}' which in blacklist stickers\".format(\n                            mention_markdown(user.id, user.first_name), value, trigger\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n                    return\n                elif getmode == 7:\n                    message.delete()\n                    mutetime = extract_time(message, value)\n                    bot.restrict_chat_member(\n                        chat.id,\n                        user.id,\n                        permissions=ChatPermissions(can_send_messages=False),\n                        until_date=mutetime,\n                    )\n                    bot.sendMessage(\n                        chat.id,\n                        \"{} muted for {} because using '{}' which in blacklist stickers\".format(\n                            mention_markdown(user.id, user.first_name), value, trigger\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n                    return\n            except BadRequest as excp:\n                if excp.message != \"Message to delete not found\":\n                    LOGGER.exception(\"Error while deleting blacklist message.\")\n                break\n\n\ndef __import_data__(chat_id, data):\n    # set chat blacklist\n    blacklist = data.get(\"sticker_blacklist\", {})\n    for trigger in blacklist:\n        sql.add_to_stickers(chat_id, trigger)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    blacklisted = sql.num_stickers_chat_filters(chat_id)\n    return \"There are `{} `blacklisted stickers.\".format(blacklisted)\n\n\ndef __stats__():\n    return \"‚Ä¢ {} blacklist stickers, across {} chats.\".format(\n        sql.num_stickers_filters(), sql.num_stickers_filter_chats()\n    )\n\n\n__mod_name__ = \"Stickers b list\"\n\nBLACKLIST_STICKER_HANDLER = DisableAbleCommandHandler(\n    \"blsticker\", blackliststicker, admin_ok=True\n)\nADDBLACKLIST_STICKER_HANDLER = DisableAbleCommandHandler(\n    \"addblsticker\", add_blackliststicker\n)\nUNBLACKLIST_STICKER_HANDLER = CommandHandler(\n    [\"unblsticker\", \"rmblsticker\"], unblackliststicker\n)\nBLACKLISTMODE_HANDLER = CommandHandler(\"blstickermode\", blacklist_mode)\nBLACKLIST_STICKER_DEL_HANDLER = MessageHandler(\n    Filters.sticker & Filters.group, del_blackliststicker\n)\n\ndispatcher.add_handler(BLACKLIST_STICKER_HANDLER)\ndispatcher.add_handler(ADDBLACKLIST_STICKER_HANDLER)\ndispatcher.add_handler(UNBLACKLIST_STICKER_HANDLER)\ndispatcher.add_handler(BLACKLISTMODE_HANDLER)\ndispatcher.add_handler(BLACKLIST_STICKER_DEL_HANDLER)\n","size_bytes":19769},"sitaBot/modules/fakeit.py":{"content":"import os\n\nimport requests\nfrom faker import Faker\nfrom faker.providers import internet\nfrom telethon import events\n\nfrom sitaBot.pyrogramee.telethonbasics import is_admin\nfrom sitaBot import telethn as tbot\n\n@tbot.on(events.NewMessage(pattern=\"/fakegen$\"))\nasync def hi(event):\n    if event.fwd_from:\n        return\n    if event.is_group:\n        if not await is_admin(event, event.message.sender_id):\n            await event.reply(\"`You Should Be Admin To Do This!`\")\n            return\n    fake = Faker()\n    print(\"FAKE DETAILS GENERATED\\n\")\n    name = str(fake.name())\n    fake.add_provider(internet)\n    address = str(fake.address())\n    ip = fake.ipv4_private()\n    cc = fake.credit_card_full()\n    email = fake.ascii_free_email()\n    job = fake.job()\n    android = fake.android_platform_token()\n    pc = fake.chrome()\n    await event.reply(\n        f\"<b><u> Fake Information Generated</b></u>\\n<b>Name :-</b><code>{name}</code>\\n\\n<b>Address:-</b><code>{address}</code>\\n\\n<b>IP ADDRESS:-</b><code>{ip}</code>\\n\\n<b>credit card:-</b><code>{cc}</code>\\n\\n<b>Email Id:-</b><code>{email}</code>\\n\\n<b>Job:-</b><code>{job}</code>\\n\\n<b>android user agent:-</b><code>{android}</code>\\n\\n<b>Pc user agent:-</b><code>{pc}</code>\",\n        parse_mode=\"HTML\",\n    )\n\n\n@tbot.on(events.NewMessage(pattern=\"/picgen$\"))\nasync def _(event):\n    if event.fwd_from:\n        return\n    if await is_admin(event, event.message.sender_id):\n        url = \"https://thispersondoesnotexist.com/image\"\n        response = requests.get(url)\n        if response.status_code == 200:\n            with open(\"INNEXIA.jpg\", \"wb\") as f:\n                f.write(response.content)\n\n        captin = f\"Fake Image powered by @brahix_support.\"\n        fole = \"INNEXIA.jpg\"\n        await tbot.send_file(event.chat_id, fole, caption=captin)\n        await event.delete()\n        os.system(\"rm ./INNEXIA.jpg \")\n","size_bytes":1876},"sitaBot/utils/exceptions.py":{"content":"class CancelProcess(Exception):\n    \"\"\"\n       Cancel Process\n    \"\"\"\n","size_bytes":70},"sitaBot/modules/users.py":{"content":"from io import BytesIO\nfrom time import sleep\n\nfrom telegram import TelegramError, Update\nfrom telegram.error import BadRequest, Unauthorized\nfrom telegram.ext import (\n    CallbackContext,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\n\nimport sitaBot.modules.sql.users_sql as sql\nfrom sitaBot import DEV_USERS, LOGGER, OWNER_ID, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus, sudo_plus\nfrom sitaBot.modules.sql.users_sql import get_all_users\n\nUSERS_GROUP = 4\nCHAT_GROUP = 5\nDEV_AND_MORE = DEV_USERS.append(int(OWNER_ID))\n\n\ndef get_user_id(username):\n    # ensure valid userid\n    if len(username) <= 5:\n        return None\n\n    if username.startswith(\"@\"):\n        username = username[1:]\n\n    users = sql.get_userid_by_name(username)\n\n    if not users:\n        return None\n\n    elif len(users) == 1:\n        return users[0].user_id\n\n    else:\n        for user_obj in users:\n            try:\n                userdat = dispatcher.bot.get_chat(user_obj.user_id)\n                if userdat.username == username:\n                    return userdat.id\n\n            except BadRequest as excp:\n                if excp.message == \"Chat not found\":\n                    pass\n                else:\n                    LOGGER.exception(\"Error extracting user ID\")\n\n    return None\n\n\n@run_async\n@dev_plus\ndef broadcast(update: Update, context: CallbackContext):\n    to_send = update.effective_message.text.split(None, 1)\n\n    if len(to_send) >= 2:\n        to_group = False\n        to_user = False\n        if to_send[0] == \"/broadcastgroups\":\n            to_group = True\n        if to_send[0] == \"/broadcastusers\":\n            to_user = True\n        else:\n            to_group = to_user = True\n        chats = sql.get_all_chats() or []\n        users = get_all_users()\n        failed = 0\n        failed_user = 0\n        if to_group:\n            for chat in chats:\n                try:\n                    context.bot.sendMessage(\n                        int(chat.chat_id),\n                        to_send[1],\n                        parse_mode=\"MARKDOWN\",\n                        disable_web_page_preview=True,\n                    )\n                    sleep(0.1)\n                except TelegramError:\n                    failed += 1\n        if to_user:\n            for user in users:\n                try:\n                    context.bot.sendMessage(\n                        int(user.user_id),\n                        to_send[1],\n                        parse_mode=\"MARKDOWN\",\n                        disable_web_page_preview=True,\n                    )\n                    sleep(0.1)\n                except TelegramError:\n                    failed_user += 1\n        update.effective_message.reply_text(\n            f\"Broadcast complete.\\nGroups failed: {failed}.\\nUsers failed: {failed_user}.\"\n        )\n\n\n@run_async\ndef log_user(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    msg = update.effective_message\n\n    sql.update_user(msg.from_user.id, msg.from_user.username, chat.id, chat.title)\n\n    if msg.reply_to_message:\n        sql.update_user(\n            msg.reply_to_message.from_user.id,\n            msg.reply_to_message.from_user.username,\n            chat.id,\n            chat.title,\n        )\n\n    if msg.forward_from:\n        sql.update_user(msg.forward_from.id, msg.forward_from.username)\n\n\n@run_async\n@sudo_plus\ndef chats(update: Update, context: CallbackContext):\n    all_chats = sql.get_all_chats() or []\n    chatfile = \"List of chats.\\n0. Chat name | Chat ID | Members count\\n\"\n    P = 1\n    for chat in all_chats:\n        try:\n            curr_chat = context.bot.getChat(chat.chat_id)\n            bot_member = curr_chat.get_member(context.bot.id)\n            chat_members = curr_chat.get_members_count(context.bot.id)\n            chatfile += \"{}. {} | {} | {}\\n\".format(\n                P, chat.chat_name, chat.chat_id, chat_members\n            )\n            P = P + 1\n        except:\n            pass\n\n    with BytesIO(str.encode(chatfile)) as output:\n        output.name = \"groups_list.txt\"\n        update.effective_message.reply_document(\n            document=output,\n            filename=\"groups_list.txt\",\n            caption=\"Here be the list of groups in my database.\",\n        )\n\n\n@run_async\ndef chat_checker(update: Update, context: CallbackContext):\n    bot = context.bot\n    try:\n        if update.effective_message.chat.get_member(bot.id).can_send_messages is False:\n            bot.leaveChat(update.effective_message.chat.id)\n    except Unauthorized:\n        pass\n\n\ndef __user_info__(user_id):\n    if user_id in [777000, 1087968824]:\n        return \"\"\"‚ïò‚ïê‚ïê„Äå Groups count: <code>???</code> „Äç\"\"\"\n    if user_id == dispatcher.bot.id:\n        return \"\"\"‚ïò‚ïê‚ïê„Äå Groups count: <code>???</code> „Äç\"\"\"\n    num_chats = sql.get_user_num_chats(user_id)\n    return f\"\"\"‚ïò‚ïê‚ïê„Äå Groups count: <code>{num_chats}</code> „Äç\"\"\"\n\n\ndef __stats__():\n    return f\"‚Ä¢ {sql.num_users()} users, across {sql.num_chats()} chats\"\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\n__help__ = \"\"  # no help string\n\nBROADCAST_HANDLER = CommandHandler(\n    [\"broadcastall\", \"broadcastusers\", \"broadcastgroups\"], broadcast\n)\nUSER_HANDLER = MessageHandler(Filters.all & Filters.group, log_user)\nCHAT_CHECKER_HANDLER = MessageHandler(Filters.all & Filters.group, chat_checker)\nCHATLIST_HANDLER = CommandHandler(\"groups\", chats)\n\ndispatcher.add_handler(USER_HANDLER, USERS_GROUP)\ndispatcher.add_handler(BROADCAST_HANDLER)\ndispatcher.add_handler(CHATLIST_HANDLER)\ndispatcher.add_handler(CHAT_CHECKER_HANDLER, CHAT_GROUP)\n\n__mod_name__ = \"Users\"\n__handlers__ = [(USER_HANDLER, USERS_GROUP), BROADCAST_HANDLER, CHATLIST_HANDLER]\n","size_bytes":5757},"sitaBot/modules/currency_converter.py":{"content":"import requests\nfrom sitaBot import CASH_API_KEY, dispatcher\nfrom telegram import Update, ParseMode\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\n\n@run_async\ndef convert(update: Update, context: CallbackContext):\n    args = update.effective_message.text.split(\" \")\n\n    if len(args) == 4:\n        try:\n            orig_cur_amount = float(args[1])\n\n        except ValueError:\n            update.effective_message.reply_text(\"Invalid Amount Of Currency\")\n            return\n\n        orig_cur = args[2].upper()\n\n        new_cur = args[3].upper()\n\n        request_url = (\n            f\"https://www.alphavantage.co/query\"\n            f\"?function=CURRENCY_EXCHANGE_RATE\"\n            f\"&from_currency={orig_cur}\"\n            f\"&to_currency={new_cur}\"\n            f\"&apikey={CASH_API_KEY}\"\n        )\n        response = requests.get(request_url).json()\n        try:\n            current_rate = float(\n                response[\"Realtime Currency Exchange Rate\"][\"5. Exchange Rate\"]\n            )\n        except KeyError:\n            update.effective_message.reply_text(\"Currency Not Supported.\")\n            return\n        new_cur_amount = round(orig_cur_amount * current_rate, 5)\n        update.effective_message.reply_text(\n            f\"{orig_cur_amount} {orig_cur} = {new_cur_amount} {new_cur}\"\n        )\n\n    elif len(args) == 1:\n        update.effective_message.reply_text(__help__, parse_mode=ParseMode.MARKDOWN)\n\n    else:\n        update.effective_message.reply_text(\n            f\"*Invalid Args!!:* Required 3 But Passed {len(args) -1}\",\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n\nCONVERTER_HANDLER = CommandHandler(\"cash\", convert)\n\ndispatcher.add_handler(CONVERTER_HANDLER)\n\n__command_list__ = [\"cash\"]\n__handlers__ = [CONVERTER_HANDLER]\n","size_bytes":1773},"sitaBot/modules/warns.py":{"content":"import html\nimport re\nfrom typing import Optional\n\nimport telegram\nfrom sitaBot import TIGERS, WOLVES, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    can_restrict,\n    is_user_admin,\n    user_admin,\n    user_can_ban,\n    user_admin_no_reply,\n    can_delete,\n)\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_text,\n    extract_user,\n    extract_user_and_text,\n)\nfrom sitaBot.modules.helper_funcs.filters import CustomFilters\nfrom sitaBot.modules.helper_funcs.misc import split_message\nfrom sitaBot.modules.helper_funcs.string_handling import split_quotes\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.sql import warns_sql as sql\nfrom telegram import (\n    CallbackQuery,\n    Chat,\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n    Message,\n    ParseMode,\n    Update,\n    User,\n)\nfrom telegram.error import BadRequest\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    DispatcherHandlerStop,\n    Filters,\n    MessageHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import mention_html\nfrom sitaBot.modules.sql.approve_sql import is_approved\n\nWARN_HANDLER_GROUP = 9\nCURRENT_WARNING_FILTER_STRING = \"<b>Current warning filters in this chat:</b>\\n\"\n\n\n# Not async\ndef warn(user: User,\n         chat: Chat,\n         reason: str,\n         message: Message,\n         warner: User = None) -> str:\n    if is_user_admin(chat, user.id):\n        # message.reply_text(\"Damn admins, They are too far to be One Punched!\")\n        return\n\n    if user.id in TIGERS:\n        if warner:\n            message.reply_text(\"Tigers cant be warned.\")\n        else:\n            message.reply_text(\n                \"Tiger triggered an auto warn filter!\\n I can't warn tigers but they should avoid abusing this.\"\n            )\n        return\n\n    if user.id in WOLVES:\n        if warner:\n            message.reply_text(\"Wolf disasters are warn immune.\")\n        else:\n            message.reply_text(\n                \"Wolf Disaster triggered an auto warn filter!\\nI can't warn wolves but they should avoid abusing this.\"\n            )\n        return\n\n    if warner:\n        warner_tag = mention_html(warner.id, warner.first_name)\n    else:\n        warner_tag = \"Automated warn filter.\"\n\n    limit, soft_warn = sql.get_warn_setting(chat.id)\n    num_warns, reasons = sql.warn_user(user.id, chat.id, reason)\n    if num_warns >= limit:\n        sql.reset_warns(user.id, chat.id)\n        if soft_warn:  # punch\n            chat.unban_member(user.id)\n            reply = (\n                f\"<code>‚ùï</code><b>Punch Event</b>\\n\"\n                f\"<code> </code><b>‚Ä¢  User:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"<code> </code><b>‚Ä¢  Count:</b> {limit}\")\n\n        else:  # ban\n            chat.kick_member(user.id)\n            reply = (\n                f\"<code>‚ùï</code><b>Ban Event</b>\\n\"\n                f\"<code> </code><b>‚Ä¢  User:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"<code> </code><b>‚Ä¢  Count:</b> {limit}\")\n\n        for warn_reason in reasons:\n            reply += f\"\\n - {html.escape(warn_reason)}\"\n\n        # message.bot.send_sticker(chat.id, BAN_STICKER)  # Saitama's sticker\n        keyboard = None\n        log_reason = (f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                      f\"#WARN_BAN\\n\"\n                      f\"<b>Admin:</b> {warner_tag}\\n\"\n                      f\"<b>User:</b> {mention_html(user.id, user.first_name)}\\n\"\n                      f\"<b>Reason:</b> {reason}\\n\"\n                      f\"<b>Counts:</b> <code>{num_warns}/{limit}</code>\")\n\n    else:\n        keyboard = InlineKeyboardMarkup([[\n            InlineKeyboardButton(\n                \"üîò Remove warn\", callback_data=\"rm_warn({})\".format(user.id))\n        ]])\n\n        reply = (\n            f\"<code>‚ùï</code><b>Warn Event</b>\\n\"\n            f\"<code> </code><b>‚Ä¢  User:</b> {mention_html(user.id, user.first_name)}\\n\"\n            f\"<code> </code><b>‚Ä¢  Count:</b> {num_warns}/{limit}\")\n        if reason:\n            reply += f\"\\n<code> </code><b>‚Ä¢  Reason:</b> {html.escape(reason)}\"\n\n        log_reason = (f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                      f\"#WARN\\n\"\n                      f\"<b>Admin:</b> {warner_tag}\\n\"\n                      f\"<b>User:</b> {mention_html(user.id, user.first_name)}\\n\"\n                      f\"<b>Reason:</b> {reason}\\n\"\n                      f\"<b>Counts:</b> <code>{num_warns}/{limit}</code>\")\n\n    try:\n        message.reply_text(\n            reply, reply_markup=keyboard, parse_mode=ParseMode.HTML)\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\n                reply,\n                reply_markup=keyboard,\n                parse_mode=ParseMode.HTML,\n                quote=False)\n        else:\n            raise\n    return log_reason\n\n\n\n@run_async\n@user_admin_no_reply\n# @user_can_ban\n@bot_admin\n@loggable\ndef button(update: Update, context: CallbackContext) -> str:\n    query: Optional[CallbackQuery] = update.callback_query\n    user: Optional[User] = update.effective_user\n    match = re.match(r\"rm_warn\\((.+?)\\)\", query.data)\n    if match:\n        user_id = match.group(1)\n        chat: Optional[Chat] = update.effective_chat\n        res = sql.remove_warn(user_id, chat.id)\n        if res:\n            update.effective_message.edit_text(\n                \"Warn removed by {}.\".format(mention_html(user.id, user.first_name)),\n                parse_mode=ParseMode.HTML,\n            )\n            user_member = chat.get_member(user_id)\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"#UNWARN\\n\"\n                f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"<b>User:</b> {mention_html(user_member.user.id, user_member.user.first_name)}\"\n            )\n        else:\n            update.effective_message.edit_text(\n                \"User already has no warns.\", parse_mode=ParseMode.HTML\n            )\n\n    return \"\"\n\n\n@run_async\n@user_admin\n@can_restrict\n# @user_can_ban\n@loggable\ndef warn_user(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    message: Optional[Message] = update.effective_message\n    chat: Optional[Chat] = update.effective_chat\n    warner: Optional[User] = update.effective_user\n\n    user_id, reason = extract_user_and_text(message, args)\n    if message.text.startswith(\"/d\") and message.reply_to_message:\n        message.reply_to_message.delete()\n    if user_id:\n        if (\n            message.reply_to_message\n            and message.reply_to_message.from_user.id == user_id\n        ):\n            return warn(\n                message.reply_to_message.from_user,\n                chat,\n                reason,\n                message.reply_to_message,\n                warner,\n            )\n        else:\n            return warn(chat.get_member(user_id).user, chat, reason, message, warner)\n    else:\n        message.reply_text(\"That looks like an invalid User ID to me.\")\n    return \"\"\n\n\n@run_async\n@user_admin\n# @user_can_ban\n@bot_admin\n@loggable\ndef reset_warns(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    message: Optional[Message] = update.effective_message\n    chat: Optional[Chat] = update.effective_chat\n    user: Optional[User] = update.effective_user\n\n    user_id = extract_user(message, args)\n\n    if user_id:\n        sql.reset_warns(user_id, chat.id)\n        message.reply_text(\"Warns have been reset!\")\n        warned = chat.get_member(user_id).user\n        return (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"#RESETWARNS\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n            f\"<b>User:</b> {mention_html(warned.id, warned.first_name)}\"\n        )\n    else:\n        message.reply_text(\"No user has been designated!\")\n    return \"\"\n\n\n@run_async\ndef warns(update: Update, context: CallbackContext):\n    args = context.args\n    message: Optional[Message] = update.effective_message\n    chat: Optional[Chat] = update.effective_chat\n    user_id = extract_user(message, args) or update.effective_user.id\n    result = sql.get_warns(user_id, chat.id)\n\n    if result and result[0] != 0:\n        num_warns, reasons = result\n        limit, soft_warn = sql.get_warn_setting(chat.id)\n\n        if reasons:\n            text = (\n                f\"This user has {num_warns}/{limit} warns, for the following reasons:\"\n            )\n            for reason in reasons:\n                text += f\"\\n ‚Ä¢ {reason}\"\n\n            msgs = split_message(text)\n            for msg in msgs:\n                update.effective_message.reply_text(msg)\n        else:\n            update.effective_message.reply_text(\n                f\"User has {num_warns}/{limit} warns, but no reasons for any of them.\"\n            )\n    else:\n        update.effective_message.reply_text(\"This user doesn't have any warns!\")\n\n\n# Dispatcher handler stop - do not async\n@user_admin\n# @user_can_ban\ndef add_warn_filter(update: Update, context: CallbackContext):\n    chat: Optional[Chat] = update.effective_chat\n    msg: Optional[Message] = update.effective_message\n\n    args = msg.text.split(\n        None, 1\n    )  # use python's maxsplit to separate Cmd, keyword, and reply_text\n\n    if len(args) < 2:\n        return\n\n    extracted = split_quotes(args[1])\n\n    if len(extracted) >= 2:\n        # set trigger -> lower, so as to avoid adding duplicate filters with different cases\n        keyword = extracted[0].lower()\n        content = extracted[1]\n\n    else:\n        return\n\n    # Note: perhaps handlers can be removed somehow using sql.get_chat_filters\n    for handler in dispatcher.handlers.get(WARN_HANDLER_GROUP, []):\n        if handler.filters == (keyword, chat.id):\n            dispatcher.remove_handler(handler, WARN_HANDLER_GROUP)\n\n    sql.add_warn_filter(chat.id, keyword, content)\n\n    update.effective_message.reply_text(f\"Warn handler added for '{keyword}'!\")\n    raise DispatcherHandlerStop\n\n\n@user_admin\n# @user_can_ban\ndef remove_warn_filter(update: Update, context: CallbackContext):\n    chat: Optional[Chat] = update.effective_chat\n    msg: Optional[Message] = update.effective_message\n\n    args = msg.text.split(\n        None, 1\n    )  # use python's maxsplit to separate Cmd, keyword, and reply_text\n\n    if len(args) < 2:\n        return\n\n    extracted = split_quotes(args[1])\n\n    if len(extracted) < 1:\n        return\n\n    to_remove = extracted[0]\n\n    chat_filters = sql.get_chat_warn_triggers(chat.id)\n\n    if not chat_filters:\n        msg.reply_text(\"No warning filters are active here!\")\n        return\n\n    for filt in chat_filters:\n        if filt == to_remove:\n            sql.remove_warn_filter(chat.id, to_remove)\n            msg.reply_text(\"Okay, I'll stop warning people for that.\")\n            raise DispatcherHandlerStop\n\n    msg.reply_text(\n        \"That's not a current warning filter - run /warnlist for all active warning filters.\"\n    )\n\n\n@run_async\ndef list_warn_filters(update: Update, context: CallbackContext):\n    chat: Optional[Chat] = update.effective_chat\n    all_handlers = sql.get_chat_warn_triggers(chat.id)\n\n    if not all_handlers:\n        update.effective_message.reply_text(\"No warning filters are active here!\")\n        return\n\n    filter_list = CURRENT_WARNING_FILTER_STRING\n    for keyword in all_handlers:\n        entry = f\" - {html.escape(keyword)}\\n\"\n        if len(entry) + len(filter_list) > telegram.MAX_MESSAGE_LENGTH:\n            update.effective_message.reply_text(filter_list, parse_mode=ParseMode.HTML)\n            filter_list = entry\n        else:\n            filter_list += entry\n\n    if filter_list != CURRENT_WARNING_FILTER_STRING:\n        update.effective_message.reply_text(filter_list, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@loggable\ndef reply_filter(update: Update, context: CallbackContext) -> str:\n    chat: Optional[Chat] = update.effective_chat\n    message: Optional[Message] = update.effective_message\n    user: Optional[User] = update.effective_user\n\n    if not user:  # Ignore channel\n        return\n\n    if user.id == 777000:\n        return\n    if is_approved(chat.id, user.id):\n        return\n    chat_warn_filters = sql.get_chat_warn_triggers(chat.id)\n    to_match = extract_text(message)\n    if not to_match:\n        return \"\"\n\n    for keyword in chat_warn_filters:\n        pattern = r\"( |^|[^\\w])\" + re.escape(keyword) + r\"( |$|[^\\w])\"\n        if re.search(pattern, to_match, flags=re.IGNORECASE):\n            user: Optional[User] = update.effective_user\n            warn_filter = sql.get_warn_filter(chat.id, keyword)\n            return warn(user, chat, warn_filter.reply, message)\n    return \"\"\n\n\n@run_async\n@user_admin\n# @user_can_ban\n@loggable\ndef set_warn_limit(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    chat: Optional[Chat] = update.effective_chat\n    user: Optional[User] = update.effective_user\n    msg: Optional[Message] = update.effective_message\n\n    if args:\n        if args[0].isdigit():\n            if int(args[0]) < 3:\n                msg.reply_text(\"The minimum warn limit is 3!\")\n            else:\n                sql.set_warn_limit(chat.id, int(args[0]))\n                msg.reply_text(\"Updated the warn limit to {}\".format(args[0]))\n                return (\n                    f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                    f\"#SET_WARN_LIMIT\\n\"\n                    f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                    f\"Set the warn limit to <code>{args[0]}</code>\"\n                )\n        else:\n            msg.reply_text(\"Give me a number as an arg!\")\n    else:\n        limit, soft_warn = sql.get_warn_setting(chat.id)\n\n        msg.reply_text(\"The current warn limit is {}\".format(limit))\n    return \"\"\n\n\n@run_async\n@user_admin\n# @user_can_ban\ndef set_warn_strength(update: Update, context: CallbackContext):\n    args = context.args\n    chat: Optional[Chat] = update.effective_chat\n    user: Optional[User] = update.effective_user\n    msg: Optional[Message] = update.effective_message\n\n    if args:\n        if args[0].lower() in (\"on\", \"yes\"):\n            sql.set_warn_strength(chat.id, False)\n            msg.reply_text(\"Too many warns will now result in a Ban!\")\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"Has enabled strong warns. Users will be seriously punched.(banned)\"\n            )\n\n        elif args[0].lower() in (\"off\", \"no\"):\n            sql.set_warn_strength(chat.id, True)\n            msg.reply_text(\n                \"Too many warns will now result in a normal punch! Users will be able to join again after.\"\n            )\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"Has disabled strong punches. I will use normal punch on users.\"\n            )\n\n        else:\n            msg.reply_text(\"I only understand on/yes/no/off!\")\n    else:\n        limit, soft_warn = sql.get_warn_setting(chat.id)\n        if soft_warn:\n            msg.reply_text(\n                \"Warns are currently set to *punch* users when they exceed the limits.\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n        else:\n            msg.reply_text(\n                \"Warns are currently set to *Ban* users when they exceed the limits.\",\n                parse_mode=ParseMode.MARKDOWN,\n            )\n    return \"\"\n\n\ndef __stats__():\n    return (\n        f\"‚Ä¢ {sql.num_warns()} overall warns, across {sql.num_warn_chats()} chats.\\n\"\n        f\"‚Ä¢ {sql.num_warn_filters()} warn filters, across {sql.num_warn_filter_chats()} chats.\"\n    )\n\n\ndef __import_data__(chat_id, data):\n    for user_id, count in data.get(\"warns\", {}).items():\n        for x in range(int(count)):\n            sql.warn_user(user_id, chat_id)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    num_warn_filters = sql.num_warn_chat_filters(chat_id)\n    limit, soft_warn = sql.get_warn_setting(chat_id)\n    return (\n        f\"This chat has `{num_warn_filters}` warn filters. \"\n        f\"It takes `{limit}` warns before the user gets *{'kicked' if soft_warn else 'banned'}*.\"\n    )\n\n\n__help__ = \"\"\"\n ‚ùç /warns <userhandle>*:* get a user's number, and reason, of warns.\n ‚ùç /warnlist*:* list of all current warning filters\n*Admins only:*\n ‚ùç /warn <userhandle>*:* warn a user. After 3 warns, the user will be banned from the group. Can also be used as a reply.\n ‚ùç /dwarn <userhandle>*:* warn a user and delete the message. After 3 warns, the user will be banned from the group. Can also be used as a reply.\n ‚ùç /resetwarn <userhandle>*:* reset the warns for a user. Can also be used as a reply.\n ‚ùç /addwarn <keyword> <reply message>*:* set a warning filter on a certain keyword. If you want your keyword to \\\nbe a sentence, encompass it with quotes, as such: `/addwarn \"very angry\" This is an angry user`.\n ‚ùç /nowarn <keyword>*:* stop a warning filter\n ‚ùç /warnlimit <num>*:* set the warning limit\n ‚ùç /strongwarn <on/yes/off/no>*:* If set to on, exceeding the warn limit will result in a ban. Else, will just punch.\n\"\"\"\n\n__mod_name__ = \"Warns\"\n\nWARN_HANDLER = CommandHandler([\"warn\", \"dwarn\"], warn_user, filters=Filters.group)\nRESET_WARN_HANDLER = CommandHandler(\n    [\"resetwarn\", \"resetwarns\"], reset_warns, filters=Filters.group\n)\nCALLBACK_QUERY_HANDLER = CallbackQueryHandler(button, pattern=r\"rm_warn\")\nMYWARNS_HANDLER = DisableAbleCommandHandler(\"warns\", warns, filters=Filters.group)\nADD_WARN_HANDLER = CommandHandler(\"addwarn\", add_warn_filter, filters=Filters.group)\nRM_WARN_HANDLER = CommandHandler(\n    [\"nowarn\", \"stopwarn\"], remove_warn_filter, filters=Filters.group\n)\nLIST_WARN_HANDLER = DisableAbleCommandHandler(\n    [\"warnlist\", \"warnfilters\"], list_warn_filters, filters=Filters.group, admin_ok=True\n)\nWARN_FILTER_HANDLER = MessageHandler(\n    CustomFilters.has_text & Filters.group, reply_filter\n)\nWARN_LIMIT_HANDLER = CommandHandler(\"warnlimit\", set_warn_limit, filters=Filters.group)\nWARN_STRENGTH_HANDLER = CommandHandler(\n    \"strongwarn\", set_warn_strength, filters=Filters.group\n)\n\ndispatcher.add_handler(WARN_HANDLER)\ndispatcher.add_handler(CALLBACK_QUERY_HANDLER)\ndispatcher.add_handler(RESET_WARN_HANDLER)\ndispatcher.add_handler(MYWARNS_HANDLER)\ndispatcher.add_handler(ADD_WARN_HANDLER)\ndispatcher.add_handler(RM_WARN_HANDLER)\ndispatcher.add_handler(LIST_WARN_HANDLER)\ndispatcher.add_handler(WARN_LIMIT_HANDLER)\ndispatcher.add_handler(WARN_STRENGTH_HANDLER)\ndispatcher.add_handler(WARN_FILTER_HANDLER, WARN_HANDLER_GROUP)\n","size_bytes":18886},"sitaBot/modules/remote_cmds.py":{"content":"from sitaBot import dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    is_bot_admin,\n    is_user_ban_protected,\n    is_user_in_chat,\n)\nfrom sitaBot.modules.helper_funcs.extraction import extract_user_and_text\nfrom sitaBot.modules.helper_funcs.filters import CustomFilters\nfrom telegram import Update, ChatPermissions\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, CommandHandler, run_async\n\nRBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to punch it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can punch group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n}\n\nRUNBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to punch it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can punch group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n}\n\nRKICK_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to punch it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can punch group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n}\n\nRMUTE_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to punch it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can punch group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n}\n\nRUNMUTE_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to punch it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can punch group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n}\n\n\n@run_async\n@bot_admin\ndef rban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    if not args:\n        message.reply_text(\"You don't seem to be referring to a chat/user.\")\n        return\n\n    user_id, chat_id = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n    elif not chat_id:\n        message.reply_text(\"You don't seem to be referring to a chat.\")\n        return\n\n    try:\n        chat = bot.get_chat(chat_id.split()[0])\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\":\n            message.reply_text(\n                \"Chat not found! Make sure you entered a valid chat ID and I'm part of that chat.\"\n            )\n            return\n        else:\n            raise\n\n    if chat.type == \"private\":\n        message.reply_text(\"I'm sorry, but that's a private chat!\")\n        return\n\n    if (\n        not is_bot_admin(chat, bot.id)\n        or not chat.get_member(bot.id).can_restrict_members\n    ):\n        message.reply_text(\n            \"I can't restrict people there! Make sure I'm admin and can ban users.\"\n        )\n        return\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user\")\n            return\n        else:\n            raise\n\n    if is_user_ban_protected(chat, user_id, member):\n        message.reply_text(\"I really wish I could ban admins...\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna BAN myself, are you crazy?\")\n        return\n\n    try:\n        chat.kick_member(user_id)\n        message.reply_text(\"Banned from chat!\")\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\"Banned!\", quote=False)\n        elif excp.message in RBAN_ERRORS:\n            message.reply_text(excp.message)\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR banning user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't ban that user.\")\n\n\n@run_async\n@bot_admin\ndef runban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    if not args:\n        message.reply_text(\"You don't seem to be referring to a chat/user.\")\n        return\n\n    user_id, chat_id = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n    elif not chat_id:\n        message.reply_text(\"You don't seem to be referring to a chat.\")\n        return\n\n    try:\n        chat = bot.get_chat(chat_id.split()[0])\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\":\n            message.reply_text(\n                \"Chat not found! Make sure you entered a valid chat ID and I'm part of that chat.\"\n            )\n            return\n        else:\n            raise\n\n    if chat.type == \"private\":\n        message.reply_text(\"I'm sorry, but that's a private chat!\")\n        return\n\n    if (\n        not is_bot_admin(chat, bot.id)\n        or not chat.get_member(bot.id).can_restrict_members\n    ):\n        message.reply_text(\n            \"I can't unrestrict people there! Make sure I'm admin and can unban users.\"\n        )\n        return\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user there\")\n            return\n        else:\n            raise\n\n    if is_user_in_chat(chat, user_id):\n        message.reply_text(\n            \"Why are you trying to remotely unban someone that's already in that chat?\"\n        )\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna UNBAN myself, I'm an admin there!\")\n        return\n\n    try:\n        chat.unban_member(user_id)\n        message.reply_text(\"Yep, this user can join that chat!\")\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\"Unbanned!\", quote=False)\n        elif excp.message in RUNBAN_ERRORS:\n            message.reply_text(excp.message)\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR unbanning user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't unban that user.\")\n\n\n@run_async\n@bot_admin\ndef rkick(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    if not args:\n        message.reply_text(\"You don't seem to be referring to a chat/user.\")\n        return\n\n    user_id, chat_id = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n    elif not chat_id:\n        message.reply_text(\"You don't seem to be referring to a chat.\")\n        return\n\n    try:\n        chat = bot.get_chat(chat_id.split()[0])\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\":\n            message.reply_text(\n                \"Chat not found! Make sure you entered a valid chat ID and I'm part of that chat.\"\n            )\n            return\n        else:\n            raise\n\n    if chat.type == \"private\":\n        message.reply_text(\"I'm sorry, but that's a private chat!\")\n        return\n\n    if (\n        not is_bot_admin(chat, bot.id)\n        or not chat.get_member(bot.id).can_restrict_members\n    ):\n        message.reply_text(\n            \"I can't restrict people there! Make sure I'm admin and can punch users.\"\n        )\n        return\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user\")\n            return\n        else:\n            raise\n\n    if is_user_ban_protected(chat, user_id, member):\n        message.reply_text(\"I really wish I could punch admins...\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna punch myself, are you crazy?\")\n        return\n\n    try:\n        chat.unban_member(user_id)\n        message.reply_text(\"Punched from chat!\")\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\"Punched!\", quote=False)\n        elif excp.message in RKICK_ERRORS:\n            message.reply_text(excp.message)\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR punching user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't punch that user.\")\n\n\n@run_async\n@bot_admin\ndef rmute(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    if not args:\n        message.reply_text(\"You don't seem to be referring to a chat/user.\")\n        return\n\n    user_id, chat_id = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n    elif not chat_id:\n        message.reply_text(\"You don't seem to be referring to a chat.\")\n        return\n\n    try:\n        chat = bot.get_chat(chat_id.split()[0])\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\":\n            message.reply_text(\n                \"Chat not found! Make sure you entered a valid chat ID and I'm part of that chat.\"\n            )\n            return\n        else:\n            raise\n\n    if chat.type == \"private\":\n        message.reply_text(\"I'm sorry, but that's a private chat!\")\n        return\n\n    if (\n        not is_bot_admin(chat, bot.id)\n        or not chat.get_member(bot.id).can_restrict_members\n    ):\n        message.reply_text(\n            \"I can't restrict people there! Make sure I'm admin and can mute users.\"\n        )\n        return\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user\")\n            return\n        else:\n            raise\n\n    if is_user_ban_protected(chat, user_id, member):\n        message.reply_text(\"I really wish I could mute admins...\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna MUTE myself, are you crazy?\")\n        return\n\n    try:\n        bot.restrict_chat_member(\n            chat.id, user_id, permissions=ChatPermissions(can_send_messages=False)\n        )\n        message.reply_text(\"Muted from the chat!\")\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\"Muted!\", quote=False)\n        elif excp.message in RMUTE_ERRORS:\n            message.reply_text(excp.message)\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR mute user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't mute that user.\")\n\n\n@run_async\n@bot_admin\ndef runmute(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n\n    if not args:\n        message.reply_text(\"You don't seem to be referring to a chat/user.\")\n        return\n\n    user_id, chat_id = extract_user_and_text(message, args)\n\n    if not user_id:\n        message.reply_text(\n            \"You don't seem to be referring to a user or the ID specified is incorrect..\"\n        )\n        return\n    elif not chat_id:\n        message.reply_text(\"You don't seem to be referring to a chat.\")\n        return\n\n    try:\n        chat = bot.get_chat(chat_id.split()[0])\n    except BadRequest as excp:\n        if excp.message == \"Chat not found\":\n            message.reply_text(\n                \"Chat not found! Make sure you entered a valid chat ID and I'm part of that chat.\"\n            )\n            return\n        else:\n            raise\n\n    if chat.type == \"private\":\n        message.reply_text(\"I'm sorry, but that's a private chat!\")\n        return\n\n    if (\n        not is_bot_admin(chat, bot.id)\n        or not chat.get_member(bot.id).can_restrict_members\n    ):\n        message.reply_text(\n            \"I can't unrestrict people there! Make sure I'm admin and can unban users.\"\n        )\n        return\n\n    try:\n        member = chat.get_member(user_id)\n    except BadRequest as excp:\n        if excp.message == \"User not found\":\n            message.reply_text(\"I can't seem to find this user there\")\n            return\n        else:\n            raise\n\n    if is_user_in_chat(chat, user_id):\n        if (\n            member.can_send_messages\n            and member.can_send_media_messages\n            and member.can_send_other_messages\n            and member.can_add_web_page_previews\n        ):\n            message.reply_text(\"This user already has the right to speak in that chat.\")\n            return\n\n    if user_id == bot.id:\n        message.reply_text(\"I'm not gonna UNMUTE myself, I'm an admin there!\")\n        return\n\n    try:\n        bot.restrict_chat_member(\n            chat.id,\n            int(user_id),\n            permissions=ChatPermissions(\n                can_send_messages=True,\n                can_send_media_messages=True,\n                can_send_other_messages=True,\n                can_add_web_page_previews=True,\n            ),\n        )\n        message.reply_text(\"Yep, this user can talk in that chat!\")\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            # Do not reply\n            message.reply_text(\"Unmuted!\", quote=False)\n        elif excp.message in RUNMUTE_ERRORS:\n            message.reply_text(excp.message)\n        else:\n            LOGGER.warning(update)\n            LOGGER.exception(\n                \"ERROR unmnuting user %s in chat %s (%s) due to %s\",\n                user_id,\n                chat.title,\n                chat.id,\n                excp.message,\n            )\n            message.reply_text(\"Well damn, I can't unmute that user.\")\n\n\nRBAN_HANDLER = CommandHandler(\"rban\", rban, filters=CustomFilters.sudo_filter)\nRUNBAN_HANDLER = CommandHandler(\"runban\", runban, filters=CustomFilters.sudo_filter)\nRKICK_HANDLER = CommandHandler(\"rpunch\", rkick, filters=CustomFilters.sudo_filter)\nRMUTE_HANDLER = CommandHandler(\"rmute\", rmute, filters=CustomFilters.sudo_filter)\nRUNMUTE_HANDLER = CommandHandler(\"runmute\", runmute, filters=CustomFilters.sudo_filter)\n\ndispatcher.add_handler(RBAN_HANDLER)\ndispatcher.add_handler(RUNBAN_HANDLER)\ndispatcher.add_handler(RKICK_HANDLER)\ndispatcher.add_handler(RMUTE_HANDLER)\ndispatcher.add_handler(RUNMUTE_HANDLER)\n","size_bytes":16414},"sitaBot/modules/sql/nsfw_sql.py":{"content":"import threading\nfrom sqlalchemy import Column, String\nfrom sitaBot.modules.sql import BASE, SESSION\n#   |----------------------------------|\n#   |  Test Module by @EverythingSuckz |\n#   |        Kang with Credits         |\n#   |----------------------------------|\nclass NSFWChats(BASE):\n    __tablename__ = \"nsfw_chats\"\n    chat_id = Column(String(14), primary_key=True)\n\n    def __init__(self, chat_id):\n        self.chat_id = chat_id\n\nNSFWChats.__table__.create(checkfirst=True)\nINSERTION_LOCK = threading.RLock()\n\n\ndef is_nsfw(chat_id):\n    try:\n        chat = SESSION.query(NSFWChats).get(str(chat_id))\n        if chat:\n            return True\n        else:\n            return False\n    finally:\n        SESSION.close()\n\ndef set_nsfw(chat_id):\n    with INSERTION_LOCK:\n        nsfwchat = SESSION.query(NSFWChats).get(str(chat_id))\n        if not nsfwchat:\n            nsfwchat = NSFWChats(str(chat_id))\n        SESSION.add(nsfwchat)\n        SESSION.commit()\n\ndef rem_nsfw(chat_id):\n    with INSERTION_LOCK:\n        nsfwchat = SESSION.query(NSFWChats).get(str(chat_id))\n        if nsfwchat:\n            SESSION.delete(nsfwchat)\n        SESSION.commit()\n\n\ndef get_all_nsfw_chats():\n    try:\n        return SESSION.query(NSFWChats.chat_id).all()\n    finally:\n        SESSION.close()\n","size_bytes":1285},"sitaBot/modules/helper_funcs/handlers.py":{"content":"import sitaBot.modules.sql.blacklistusers_sql as sql\nfrom sitaBot import ALLOW_EXCL\nfrom sitaBot import DEV_USERS, DRAGONS, DEMONS, TIGERS, WOLVES\n\nfrom telegram import Update\nfrom telegram.ext import CommandHandler, MessageHandler, RegexHandler, Filters\nfrom pyrate_limiter import (\n    BucketFullException,\n    Duration,\n    RequestRate,\n    Limiter,\n    MemoryListBucket,\n)\n\nif ALLOW_EXCL:\n    CMD_STARTERS = (\"/\", \"!\")\nelse:\n    CMD_STARTERS = (\"/\",)\n\n\nclass AntiSpam:\n    def __init__(self):\n        self.whitelist = (\n            (DEV_USERS or [])\n            + (DRAGONS or [])\n            + (WOLVES or [])\n            + (DEMONS or [])\n            + (TIGERS or [])\n        )\n        # Values are HIGHLY experimental, its recommended you pay attention to our commits as we will be adjusting the values over time with what suits best.\n        Duration.CUSTOM = 15  # Custom duration, 15 seconds\n        self.sec_limit = RequestRate(6, Duration.CUSTOM)  # 6 / Per 15 Seconds\n        self.min_limit = RequestRate(20, Duration.MINUTE)  # 20 / Per minute\n        self.hour_limit = RequestRate(100, Duration.HOUR)  # 100 / Per hour\n        self.daily_limit = RequestRate(1000, Duration.DAY)  # 1000 / Per day\n        self.limiter = Limiter(\n            self.sec_limit,\n            self.min_limit,\n            self.hour_limit,\n            self.daily_limit,\n            bucket_class=MemoryListBucket,\n        )\n\n    def check_user(self, user):\n        \"\"\"\n        Return True if user is to be ignored else False\n        \"\"\"\n        if user in self.whitelist:\n            return False\n        try:\n            self.limiter.try_acquire(user)\n            return False\n        except BucketFullException:\n            return True\n\n\nSpamChecker = AntiSpam()\nMessageHandlerChecker = AntiSpam()\n\n\nclass CustomCommandHandler(CommandHandler):\n    def __init__(self, command, callback, admin_ok=False, allow_edit=False, **kwargs):\n        super().__init__(command, callback, **kwargs)\n\n        if allow_edit is False:\n            self.filters &= ~(\n                Filters.update.edited_message | Filters.update.edited_channel_post\n            )\n\n    def check_update(self, update):\n        if isinstance(update, Update) and update.effective_message:\n            message = update.effective_message\n\n            try:\n                user_id = update.effective_user.id\n            except:\n                user_id = None\n\n            if user_id:\n                if sql.is_user_blacklisted(user_id):\n                    return False\n\n            if message.text and len(message.text) > 1:\n                fst_word = message.text.split(None, 1)[0]\n                if len(fst_word) > 1 and any(\n                    fst_word.startswith(start) for start in CMD_STARTERS\n                ):\n\n                    args = message.text.split()[1:]\n                    command = fst_word[1:].split(\"@\")\n                    command.append(message.bot.username)\n                    if user_id == 1087968824:\n                        user_id = update.effective_chat.id\n                    if not (\n                        command[0].lower() in self.command\n                        and command[1].lower() == message.bot.username.lower()\n                    ):\n                        return None\n                    if SpamChecker.check_user(user_id):\n                        return None\n                    filter_result = self.filters(update)\n                    if filter_result:\n                        return args, filter_result\n                    else:\n                        return False\n\n    def handle_update(self, update, dispatcher, check_result, context=None):\n        if context:\n            self.collect_additional_context(context, update, dispatcher, check_result)\n            return self.callback(update, context)\n        else:\n            optional_args = self.collect_optional_args(dispatcher, update, check_result)\n            return self.callback(dispatcher.bot, update, **optional_args)\n\n    def collect_additional_context(self, context, update, dispatcher, check_result):\n        if isinstance(check_result, bool):\n            context.args = update.effective_message.text.split()[1:]\n        else:\n            context.args = check_result[0]\n            if isinstance(check_result[1], dict):\n                context.update(check_result[1])\n\n\nclass CustomRegexHandler(RegexHandler):\n    def __init__(self, pattern, callback, friendly=\"\", **kwargs):\n        super().__init__(pattern, callback, **kwargs)\n\n\nclass CustomMessageHandler(MessageHandler):\n    def __init__(self, filters, callback, friendly=\"\", allow_edit=False, **kwargs):\n        super().__init__(filters, callback, **kwargs)\n        if allow_edit is False:\n            self.filters &= ~(\n                Filters.update.edited_message | Filters.update.edited_channel_post\n            )\n\n        def check_update(self, update):\n            if isinstance(update, Update) and update.effective_message:\n                return self.filters(update)\n","size_bytes":4991},"sitaBot/modules/locks.py":{"content":"import html\n\nfrom telegram import Message, Chat, ParseMode, MessageEntity\nfrom telegram import TelegramError, ChatPermissions\nfrom telegram.error import BadRequest\nfrom telegram.ext import CommandHandler, MessageHandler, Filters\nfrom telegram.ext.dispatcher import run_async\nfrom telegram.utils.helpers import mention_html\n\nfrom alphabet_detector import AlphabetDetector\n\nimport sitaBot.modules.sql.locks_sql as sql\nfrom sitaBot import dispatcher, DRAGONS, LOGGER\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    can_delete,\n    is_user_admin,\n    user_not_admin,\n    is_bot_admin,\n    user_admin,\n)\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.connection import connected\nfrom sitaBot.modules.sql.approve_sql import is_approved\nfrom sitaBot.modules.helper_funcs.alternate import send_message, typing_action\n\nad = AlphabetDetector()\n\nLOCK_TYPES = {\n    \"audio\": Filters.audio,\n    \"voice\": Filters.voice,\n    \"document\": Filters.document,\n    \"video\": Filters.video,\n    \"contact\": Filters.contact,\n    \"photo\": Filters.photo,\n    \"url\": Filters.entity(MessageEntity.URL)\n    | Filters.caption_entity(MessageEntity.URL),\n    \"bots\": Filters.status_update.new_chat_members,\n    \"forward\": Filters.forwarded,\n    \"game\": Filters.game,\n    \"location\": Filters.location,\n    \"egame\": Filters.dice,\n    \"rtl\": \"rtl\",\n    \"button\": \"button\",\n    \"inline\": \"inline\",\n}\n\nLOCK_CHAT_RESTRICTION = {\n    \"all\": {\n        \"can_send_messages\": False,\n        \"can_send_media_messages\": False,\n        \"can_send_polls\": False,\n        \"can_send_other_messages\": False,\n        \"can_add_web_page_previews\": False,\n        \"can_change_info\": False,\n        \"can_invite_users\": False,\n        \"can_pin_messages\": False,\n    },\n    \"messages\": {\"can_send_messages\": False},\n    \"media\": {\"can_send_media_messages\": False},\n    \"sticker\": {\"can_send_other_messages\": False},\n    \"gif\": {\"can_send_other_messages\": False},\n    \"poll\": {\"can_send_polls\": False},\n    \"other\": {\"can_send_other_messages\": False},\n    \"previews\": {\"can_add_web_page_previews\": False},\n    \"info\": {\"can_change_info\": False},\n    \"invite\": {\"can_invite_users\": False},\n    \"pin\": {\"can_pin_messages\": False},\n}\n\nUNLOCK_CHAT_RESTRICTION = {\n    \"all\": {\n        \"can_send_messages\": True,\n        \"can_send_media_messages\": True,\n        \"can_send_polls\": True,\n        \"can_send_other_messages\": True,\n        \"can_add_web_page_previews\": True,\n        \"can_invite_users\": True,\n    },\n    \"messages\": {\"can_send_messages\": True},\n    \"media\": {\"can_send_media_messages\": True},\n    \"sticker\": {\"can_send_other_messages\": True},\n    \"gif\": {\"can_send_other_messages\": True},\n    \"poll\": {\"can_send_polls\": True},\n    \"other\": {\"can_send_other_messages\": True},\n    \"previews\": {\"can_add_web_page_previews\": True},\n    \"info\": {\"can_change_info\": True},\n    \"invite\": {\"can_invite_users\": True},\n    \"pin\": {\"can_pin_messages\": True},\n}\n\nPERM_GROUP = 1\nREST_GROUP = 2\n\n\n# NOT ASYNC\ndef restr_members(\n    bot, chat_id, members, messages=False, media=False, other=False, previews=False\n):\n    for mem in members:\n        if mem.user in DRAGONS:\n            pass\n        try:\n            bot.restrict_chat_member(\n                chat_id,\n                mem.user,\n                can_send_messages=messages,\n                can_send_media_messages=media,\n                can_send_other_messages=other,\n                can_add_web_page_previews=previews,\n            )\n        except TelegramError:\n            pass\n\n\n# NOT ASYNC\ndef unrestr_members(\n    bot, chat_id, members, messages=True, media=True, other=True, previews=True\n):\n    for mem in members:\n        try:\n            bot.restrict_chat_member(\n                chat_id,\n                mem.user,\n                can_send_messages=messages,\n                can_send_media_messages=media,\n                can_send_other_messages=other,\n                can_add_web_page_previews=previews,\n            )\n        except TelegramError:\n            pass\n\n\n@run_async\ndef locktypes(update, context):\n    update.effective_message.reply_text(\n        \"\\n ‚Ä¢ \".join(\n            [\"Locks available: \"]\n            + sorted(list(LOCK_TYPES) + list(LOCK_CHAT_RESTRICTION))\n        )\n    )\n\n\n@run_async\n@user_admin\n@loggable\n@typing_action\ndef lock(update, context) -> str:\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if (\n        can_delete(chat, context.bot.id)\n        or update.effective_message.chat.type == \"private\"\n    ):\n        if len(args) >= 1:\n            ltype = args[0].lower()\n            if ltype in LOCK_TYPES:\n                # Connection check\n                conn = connected(context.bot, update, chat, user.id, need_admin=True)\n                if conn:\n                    chat = dispatcher.bot.getChat(conn)\n                    chat_id = conn\n                    chat_name = chat.title\n                    text = \"Locked {} for non-admins in {}!\".format(ltype, chat_name)\n                else:\n                    if update.effective_message.chat.type == \"private\":\n                        send_message(\n                            update.effective_message,\n                            \"This command is meant to use in group not in PM\",\n                        )\n                        return \"\"\n                    chat = update.effective_chat\n                    chat_id = update.effective_chat.id\n                    chat_name = update.effective_message.chat.title\n                    text = \"Locked {} for non-admins!\".format(ltype)\n                sql.update_lock(chat.id, ltype, locked=True)\n                send_message(update.effective_message, text, parse_mode=\"markdown\")\n\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#LOCK\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nLocked <code>{}</code>.\".format(\n                        html.escape(chat.title),\n                        mention_html(user.id, user.first_name),\n                        ltype,\n                    )\n                )\n\n            elif ltype in LOCK_CHAT_RESTRICTION:\n                # Connection check\n                conn = connected(context.bot, update, chat, user.id, need_admin=True)\n                if conn:\n                    chat = dispatcher.bot.getChat(conn)\n                    chat_id = conn\n                    chat_name = chat.title\n                    text = \"Locked {} for all non-admins in {}!\".format(\n                        ltype, chat_name\n                    )\n                else:\n                    if update.effective_message.chat.type == \"private\":\n                        send_message(\n                            update.effective_message,\n                            \"This command is meant to use in group not in PM\",\n                        )\n                        return \"\"\n                    chat = update.effective_chat\n                    chat_id = update.effective_chat.id\n                    chat_name = update.effective_message.chat.title\n                    text = \"Locked {} for all non-admins!\".format(ltype)\n\n                current_permission = context.bot.getChat(chat_id).permissions\n                context.bot.set_chat_permissions(\n                    chat_id=chat_id,\n                    permissions=get_permission_list(\n                        eval(str(current_permission)),\n                        LOCK_CHAT_RESTRICTION[ltype.lower()],\n                    ),\n                )\n\n                send_message(update.effective_message, text, parse_mode=\"markdown\")\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#Permission_LOCK\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nLocked <code>{}</code>.\".format(\n                        html.escape(chat.title),\n                        mention_html(user.id, user.first_name),\n                        ltype,\n                    )\n                )\n\n            else:\n                send_message(\n                    update.effective_message,\n                    \"What are you trying to lock...? Try /locktypes for the list of lockables\",\n                )\n        else:\n            send_message(update.effective_message, \"What are you trying to lock...?\")\n\n    else:\n        send_message(\n            update.effective_message,\n            \"I am not administrator or haven't got enough rights.\",\n        )\n\n    return \"\"\n\n\n@run_async\n@user_admin\n@loggable\n@typing_action\ndef unlock(update, context) -> str:\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n    if is_user_admin(chat, message.from_user.id):\n        if len(args) >= 1:\n            ltype = args[0].lower()\n            if ltype in LOCK_TYPES:\n                # Connection check\n                conn = connected(context.bot, update, chat, user.id, need_admin=True)\n                if conn:\n                    chat = dispatcher.bot.getChat(conn)\n                    chat_id = conn\n                    chat_name = chat.title\n                    text = \"Unlocked {} for everyone in {}!\".format(ltype, chat_name)\n                else:\n                    if update.effective_message.chat.type == \"private\":\n                        send_message(\n                            update.effective_message,\n                            \"This command is meant to use in group not in PM\",\n                        )\n                        return \"\"\n                    chat = update.effective_chat\n                    chat_id = update.effective_chat.id\n                    chat_name = update.effective_message.chat.title\n                    text = \"Unlocked {} for everyone!\".format(ltype)\n                sql.update_lock(chat.id, ltype, locked=False)\n                send_message(update.effective_message, text, parse_mode=\"markdown\")\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#UNLOCK\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nUnlocked <code>{}</code>.\".format(\n                        html.escape(chat.title),\n                        mention_html(user.id, user.first_name),\n                        ltype,\n                    )\n                )\n\n            elif ltype in UNLOCK_CHAT_RESTRICTION:\n                # Connection check\n                conn = connected(context.bot, update, chat, user.id, need_admin=True)\n                if conn:\n                    chat = dispatcher.bot.getChat(conn)\n                    chat_id = conn\n                    chat_name = chat.title\n                    text = \"Unlocked {} for everyone in {}!\".format(ltype, chat_name)\n                else:\n                    if update.effective_message.chat.type == \"private\":\n                        send_message(\n                            update.effective_message,\n                            \"This command is meant to use in group not in PM\",\n                        )\n                        return \"\"\n                    chat = update.effective_chat\n                    chat_id = update.effective_chat.id\n                    chat_name = update.effective_message.chat.title\n                    text = \"Unlocked {} for everyone!\".format(ltype)\n\n                can_change_info = chat.get_member(context.bot.id).can_change_info\n                if not can_change_info:\n                    send_message(\n                        update.effective_message,\n                        \"I don't have permission to change group info.\",\n                        parse_mode=\"markdown\",\n                    )\n                    return\n\n                current_permission = context.bot.getChat(chat_id).permissions\n                context.bot.set_chat_permissions(\n                    chat_id=chat_id,\n                    permissions=get_permission_list(\n                        eval(str(current_permission)),\n                        UNLOCK_CHAT_RESTRICTION[ltype.lower()],\n                    ),\n                )\n\n                send_message(update.effective_message, text, parse_mode=\"markdown\")\n\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#UNLOCK\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nUnlocked <code>{}</code>.\".format(\n                        html.escape(chat.title),\n                        mention_html(user.id, user.first_name),\n                        ltype,\n                    )\n                )\n            else:\n                send_message(\n                    update.effective_message,\n                    \"What are you trying to unlock...? Try /locktypes for the list of lockables.\",\n                )\n\n        else:\n            send_message(update.effective_message, \"What are you trying to unlock...?\")\n\n    return \"\"\n\n\n@run_async\n@user_not_admin\ndef del_lockables(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    message = update.effective_message  # type: Optional[Message]\n    user = update.effective_user\n    if is_approved(chat.id, user.id):\n        return\n    for lockable, filter in LOCK_TYPES.items():\n        if lockable == \"rtl\":\n            if sql.is_locked(chat.id, lockable) and can_delete(chat, context.bot.id):\n                if message.caption:\n                    check = ad.detect_alphabet(u\"{}\".format(message.caption))\n                    if \"ARABIC\" in check:\n                        try:\n                            message.delete()\n                        except BadRequest as excp:\n                            if excp.message == \"Message to delete not found\":\n                                pass\n                            else:\n                                LOGGER.exception(\"ERROR in lockables\")\n                        break\n                if message.text:\n                    check = ad.detect_alphabet(u\"{}\".format(message.text))\n                    if \"ARABIC\" in check:\n                        try:\n                            message.delete()\n                        except BadRequest as excp:\n                            if excp.message == \"Message to delete not found\":\n                                pass\n                            else:\n                                LOGGER.exception(\"ERROR in lockables\")\n                        break\n            continue\n        if lockable == \"button\":\n            if sql.is_locked(chat.id, lockable) and can_delete(chat, context.bot.id):\n                if message.reply_markup and message.reply_markup.inline_keyboard:\n                    try:\n                        message.delete()\n                    except BadRequest as excp:\n                        if excp.message == \"Message to delete not found\":\n                            pass\n                        else:\n                            LOGGER.exception(\"ERROR in lockables\")\n                    break\n            continue\n        if lockable == \"inline\":\n            if sql.is_locked(chat.id, lockable) and can_delete(chat, context.bot.id):\n                if message and message.via_bot:\n                    try:\n                        message.delete()\n                    except BadRequest as excp:\n                        if excp.message == \"Message to delete not found\":\n                            pass\n                        else:\n                            LOGGER.exception(\"ERROR in lockables\")\n                    break\n            continue\n        if (\n            filter(update)\n            and sql.is_locked(chat.id, lockable)\n            and can_delete(chat, context.bot.id)\n        ):\n            if lockable == \"bots\":\n                new_members = update.effective_message.new_chat_members\n                for new_mem in new_members:\n                    if new_mem.is_bot:\n                        if not is_bot_admin(chat, context.bot.id):\n                            send_message(\n                                update.effective_message,\n                                \"I see a bot and I've been told to stop them from joining...\"\n                                \"but I'm not admin!\",\n                            )\n                            return\n\n                        chat.kick_member(new_mem.id)\n                        send_message(\n                            update.effective_message,\n                            \"Only admins are allowed to add bots in this chat! Get outta here.\",\n                        )\n                        break\n            else:\n                try:\n                    message.delete()\n                except BadRequest as excp:\n                    if excp.message == \"Message to delete not found\":\n                        pass\n                    else:\n                        LOGGER.exception(\"ERROR in lockables\")\n\n                break\n\n\ndef build_lock_message(chat_id):\n    locks = sql.get_locks(chat_id)\n    res = \"\"\n    locklist = []\n    permslist = []\n    if locks:\n        res += \"*\" + \"These are the current locks in this Chat:\" + \"*\"\n        if locks:\n            locklist.append(\"sticker = `{}`\".format(locks.sticker))\n            locklist.append(\"audio = `{}`\".format(locks.audio))\n            locklist.append(\"voice = `{}`\".format(locks.voice))\n            locklist.append(\"document = `{}`\".format(locks.document))\n            locklist.append(\"video = `{}`\".format(locks.video))\n            locklist.append(\"contact = `{}`\".format(locks.contact))\n            locklist.append(\"photo = `{}`\".format(locks.photo))\n            locklist.append(\"gif = `{}`\".format(locks.gif))\n            locklist.append(\"url = `{}`\".format(locks.url))\n            locklist.append(\"bots = `{}`\".format(locks.bots))\n            locklist.append(\"forward = `{}`\".format(locks.forward))\n            locklist.append(\"game = `{}`\".format(locks.game))\n            locklist.append(\"location = `{}`\".format(locks.location))\n            locklist.append(\"rtl = `{}`\".format(locks.rtl))\n            locklist.append(\"button = `{}`\".format(locks.button))\n            locklist.append(\"egame = `{}`\".format(locks.egame))\n            locklist.append(\"inline = `{}`\".format(locks.inline))\n    permissions = dispatcher.bot.get_chat(chat_id).permissions\n    permslist.append(\"messages = `{}`\".format(permissions.can_send_messages))\n    permslist.append(\"media = `{}`\".format(permissions.can_send_media_messages))\n    permslist.append(\"poll = `{}`\".format(permissions.can_send_polls))\n    permslist.append(\"other = `{}`\".format(permissions.can_send_other_messages))\n    permslist.append(\"previews = `{}`\".format(permissions.can_add_web_page_previews))\n    permslist.append(\"info = `{}`\".format(permissions.can_change_info))\n    permslist.append(\"invite = `{}`\".format(permissions.can_invite_users))\n    permslist.append(\"pin = `{}`\".format(permissions.can_pin_messages))\n\n    if locklist:\n        # Ordering lock list\n        locklist.sort()\n        # Building lock list string\n        for x in locklist:\n            res += \"\\n ‚Ä¢ {}\".format(x)\n    res += \"\\n\\n*\" + \"These are the current chat permissions:\" + \"*\"\n    for x in permslist:\n        res += \"\\n ‚Ä¢ {}\".format(x)\n    return res\n\n\n@run_async\n@user_admin\n@typing_action\ndef list_locks(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user\n\n    # Connection check\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_name = chat.title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message,\n                \"This command is meant to use in group not in PM\",\n            )\n            return \"\"\n        chat = update.effective_chat\n        chat_name = update.effective_message.chat.title\n\n    res = build_lock_message(chat.id)\n    if conn:\n        res = res.replace(\"Locks in\", \"*{}*\".format(chat_name))\n\n    send_message(update.effective_message, res, parse_mode=ParseMode.MARKDOWN)\n\n\ndef get_permission_list(current, new):\n    permissions = {\n        \"can_send_messages\": None,\n        \"can_send_media_messages\": None,\n        \"can_send_polls\": None,\n        \"can_send_other_messages\": None,\n        \"can_add_web_page_previews\": None,\n        \"can_change_info\": None,\n        \"can_invite_users\": None,\n        \"can_pin_messages\": None,\n    }\n    permissions.update(current)\n    permissions.update(new)\n    new_permissions = ChatPermissions(**permissions)\n    return new_permissions\n\n\ndef __import_data__(chat_id, data):\n    # set chat locks\n    locks = data.get(\"locks\", {})\n    for itemlock in locks:\n        if itemlock in LOCK_TYPES:\n            sql.update_lock(chat_id, itemlock, locked=True)\n        elif itemlock in LOCK_CHAT_RESTRICTION:\n            sql.update_restriction(chat_id, itemlock, locked=True)\n        else:\n            pass\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    return build_lock_message(chat_id)\n\n\n__help__ = \"\"\"\nDo stickers annoy you? or want to avoid people sharing links? or pictures? \\\nYou're in the right place!\nThe locks module allows you to lock away some common items in the \\\ntelegram world; the bot will automatically delete them!\n\n ‚ùç /locktypes*:* Lists all possible locktypes\n \n*Admins only:*\n ‚ùç /lock <type>*:* Lock items of a certain type (not available in private)\n ‚ùç /unlock <type>*:* Unlock items of a certain type (not available in private)\n ‚ùç /locks*:* The current list of locks in this chat.\n \nLocks can be used to restrict a group's users.\neg:\nLocking urls will auto-delete all messages with urls, locking stickers will restrict all \\\nnon-admin users from sending stickers, etc.\nLocking bots will stop non-admins from adding bots to the chat.\n\n*Note:*\n ‚Ä¢ Unlocking permission *info* will allow members (non-admins) to change the group information, such as the description or the group name\n ‚Ä¢ Unlocking permission *pin* will allow members (non-admins) to pinned a message in a group\n\"\"\"\n\n__mod_name__ = \"Locks\"\n\nLOCKTYPES_HANDLER = DisableAbleCommandHandler(\"locktypes\", locktypes)\nLOCK_HANDLER = CommandHandler(\"lock\", lock, pass_args=True)  # , filters=Filters.group)\nUNLOCK_HANDLER = CommandHandler(\n    \"unlock\", unlock, pass_args=True\n)  # , filters=Filters.group)\nLOCKED_HANDLER = CommandHandler(\"locks\", list_locks)  # , filters=Filters.group)\n\ndispatcher.add_handler(LOCK_HANDLER)\ndispatcher.add_handler(UNLOCK_HANDLER)\ndispatcher.add_handler(LOCKTYPES_HANDLER)\ndispatcher.add_handler(LOCKED_HANDLER)\n\ndispatcher.add_handler(\n    MessageHandler(Filters.all & Filters.group, del_lockables), PERM_GROUP\n)\n","size_bytes":22666},"exp.sh":{"content":"sudo bash -c 'echo \"{ \\\"cgroup-parent\\\": \\\"/actions_job\\\",\\\"experimental\\\":true}\" > /etc/docker/daemon.json'\nsudo systemctl restart docker.service","size_bytes":146},"sitaBot/modules/sql/economy_sql.py":{"content":"import threading\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import (\n    Column,\n    Integer,\n    BigInteger,\n    String,\n    DateTime,\n    Boolean,\n    ForeignKey,\n    func,\n)\nfrom sqlalchemy.orm import relationship\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass UserEconomy(BASE):\n    __tablename__ = \"user_economy\"\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(BigInteger, nullable=False)\n    chat_id = Column(BigInteger, nullable=False)\n    balance = Column(BigInteger, default=0)\n    kills = Column(Integer, default=0)\n    is_dead = Column(Boolean, default=False)\n    death_time = Column(DateTime, nullable=True)\n    killed_by = Column(BigInteger, nullable=True)\n    protection_until = Column(DateTime, nullable=True)\n    last_daily = Column(DateTime, nullable=True)\n    \n    def __init__(self, user_id, chat_id):\n        self.user_id = user_id\n        self.chat_id = chat_id\n        self.balance = 0\n        self.kills = 0\n        self.is_dead = False\n\n    def __repr__(self):\n        return f\"<UserEconomy {self.user_id} in {self.chat_id}>\"\n\n\nclass UserInventory(BASE):\n    __tablename__ = \"user_inventory\"\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(BigInteger, nullable=False)\n    item_name = Column(String, nullable=False)\n    quantity = Column(Integer, default=1)\n    \n    def __init__(self, user_id, item_name, quantity=1):\n        self.user_id = user_id\n        self.item_name = item_name\n        self.quantity = quantity\n\n\nclass Lottery(BASE):\n    __tablename__ = \"lottery\"\n    \n    lottery_id = Column(Integer, primary_key=True, autoincrement=True)\n    total_pool = Column(BigInteger, default=0)\n    start_time = Column(DateTime, default=datetime.utcnow)\n    end_time = Column(DateTime, nullable=False)\n    is_active = Column(Boolean, default=True)\n    \n    def __init__(self):\n        self.total_pool = 0\n        self.start_time = datetime.utcnow()\n        self.end_time = datetime.utcnow() + timedelta(days=2)\n        self.is_active = True\n\n\nclass LotteryParticipant(BASE):\n    __tablename__ = \"lottery_participants\"\n    \n    id = Column(Integer, primary_key=True)\n    lottery_id = Column(Integer, ForeignKey(\"lottery.lottery_id\"))\n    user_id = Column(BigInteger, nullable=False)\n    amount = Column(BigInteger, nullable=False)\n    \n    def __init__(self, lottery_id, user_id, amount):\n        self.lottery_id = lottery_id\n        self.user_id = user_id\n        self.amount = amount\n\n\nUserEconomy.__table__.create(checkfirst=True)\nUserInventory.__table__.create(checkfirst=True)\nLottery.__table__.create(checkfirst=True)\nLotteryParticipant.__table__.create(checkfirst=True)\n\nECONOMY_LOCK = threading.RLock()\n\n\ndef get_or_create_user(user_id, chat_id):\n    with ECONOMY_LOCK:\n        user = SESSION.query(UserEconomy).filter(\n            UserEconomy.user_id == user_id,\n            UserEconomy.chat_id == chat_id\n        ).first()\n        \n        if not user:\n            user = UserEconomy(user_id, chat_id)\n            SESSION.add(user)\n            SESSION.commit()\n        \n        return user\n\n\ndef get_balance(user_id, chat_id):\n    user = get_or_create_user(user_id, chat_id)\n    return user.balance\n\n\ndef update_balance(user_id, chat_id, amount):\n    with ECONOMY_LOCK:\n        user = get_or_create_user(user_id, chat_id)\n        user.balance += amount\n        SESSION.commit()\n\n\ndef get_top_rich(limit=10):\n    with ECONOMY_LOCK:\n        return SESSION.query(UserEconomy).order_by(\n            UserEconomy.balance.desc()\n        ).limit(limit).all()\n\n\ndef get_top_killers(limit=10):\n    with ECONOMY_LOCK:\n        return SESSION.query(UserEconomy).order_by(\n            UserEconomy.kills.desc()\n        ).limit(limit).all()\n\n\ndef get_user_rank(user_id, chat_id):\n    with ECONOMY_LOCK:\n        user = get_or_create_user(user_id, chat_id)\n        rank = SESSION.query(UserEconomy).filter(\n            UserEconomy.balance > user.balance\n        ).count()\n        return rank + 1 if rank is not None else None\n\n\ndef is_dead(user_id, chat_id):\n    user = get_or_create_user(user_id, chat_id)\n    \n    if user.is_dead:\n        if user.death_time and (datetime.utcnow() - user.death_time).total_seconds() > 18000:\n            revive_user(user_id, chat_id)\n            return False\n        return True\n    return False\n\n\ndef is_protected(user_id, chat_id):\n    user = get_or_create_user(user_id, chat_id)\n    \n    if user.protection_until:\n        if datetime.utcnow() < user.protection_until:\n            return True\n        else:\n            with ECONOMY_LOCK:\n                user.protection_until = None\n                SESSION.commit()\n    return False\n\n\ndef kill_user(user_id, chat_id, killer_id):\n    with ECONOMY_LOCK:\n        user = get_or_create_user(user_id, chat_id)\n        user.is_dead = True\n        user.death_time = datetime.utcnow()\n        user.killed_by = killer_id\n        \n        killer = get_or_create_user(killer_id, chat_id)\n        killer.kills += 1\n        \n        SESSION.commit()\n\n\ndef revive_user(user_id, chat_id):\n    with ECONOMY_LOCK:\n        user = get_or_create_user(user_id, chat_id)\n        user.is_dead = False\n        user.death_time = None\n        user.killed_by = None\n        SESSION.commit()\n\n\ndef protect_user(user_id, chat_id, days):\n    with ECONOMY_LOCK:\n        user = get_or_create_user(user_id, chat_id)\n        user.protection_until = datetime.utcnow() + timedelta(days=days)\n        SESSION.commit()\n\n\ndef get_inventory(user_id):\n    with ECONOMY_LOCK:\n        return SESSION.query(UserInventory).filter(\n            UserInventory.user_id == user_id\n        ).all()\n\n\ndef add_item(user_id, item_name, quantity=1):\n    with ECONOMY_LOCK:\n        item = SESSION.query(UserInventory).filter(\n            UserInventory.user_id == user_id,\n            UserInventory.item_name == item_name\n        ).first()\n        \n        if item:\n            item.quantity += quantity\n        else:\n            item = UserInventory(user_id, item_name, quantity)\n            SESSION.add(item)\n        \n        SESSION.commit()\n\n\ndef create_lottery():\n    with ECONOMY_LOCK:\n        lottery = Lottery()\n        SESSION.add(lottery)\n        SESSION.commit()\n        return lottery.lottery_id\n\n\ndef get_active_lottery():\n    with ECONOMY_LOCK:\n        lottery = SESSION.query(Lottery).filter(\n            Lottery.is_active == True\n        ).first()\n        \n        if lottery and datetime.utcnow() > lottery.end_time:\n            lottery.is_active = False\n            SESSION.commit()\n            return None\n        \n        return lottery\n\n\ndef join_lottery(lottery_id, user_id, amount):\n    with ECONOMY_LOCK:\n        existing = SESSION.query(LotteryParticipant).filter(\n            LotteryParticipant.lottery_id == lottery_id,\n            LotteryParticipant.user_id == user_id\n        ).first()\n        \n        if existing:\n            return False\n        \n        participant = LotteryParticipant(lottery_id, user_id, amount)\n        SESSION.add(participant)\n        \n        lottery = SESSION.query(Lottery).filter(\n            Lottery.lottery_id == lottery_id\n        ).first()\n        lottery.total_pool += amount\n        \n        SESSION.commit()\n        return True\n\n\ndef get_lottery_participants(lottery_id):\n    with ECONOMY_LOCK:\n        return SESSION.query(LotteryParticipant).filter(\n            LotteryParticipant.lottery_id == lottery_id\n        ).all()\n\n\ndef can_claim_daily(user_id):\n    with ECONOMY_LOCK:\n        user = SESSION.query(UserEconomy).filter(\n            UserEconomy.user_id == user_id\n        ).first()\n        \n        if not user or not user.last_daily:\n            return True\n        \n        time_since = datetime.utcnow() - user.last_daily\n        return time_since.total_seconds() >= 43200\n\n\ndef update_daily(user_id):\n    with ECONOMY_LOCK:\n        users = SESSION.query(UserEconomy).filter(\n            UserEconomy.user_id == user_id\n        ).all()\n        \n        for user in users:\n            user.last_daily = datetime.utcnow()\n        \n        SESSION.commit()\n","size_bytes":8035},"sitaBot/modules/antiflood.py":{"content":"import html\nfrom typing import Optional, List\nimport re\n\nfrom telegram import Message, Chat, Update, User, ChatPermissions\n\nfrom sitaBot import TIGERS, WOLVES, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_admin,\n    is_user_admin,\n    user_admin,\n    user_admin_no_reply,\n)\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.sql import antiflood_sql as sql\nfrom telegram.error import BadRequest\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import mention_html, escape_markdown\nfrom sitaBot.modules.helper_funcs.string_handling import extract_time\nfrom sitaBot.modules.connection import connected\nfrom sitaBot.modules.helper_funcs.alternate import send_message\nfrom sitaBot.modules.sql.approve_sql import is_approved\n\nFLOOD_GROUP = 3\n\n\n@run_async\n@loggable\ndef check_flood(update, context) -> str:\n    user = update.effective_user  # type: Optional[User]\n    chat = update.effective_chat  # type: Optional[Chat]\n    msg = update.effective_message  # type: Optional[Message]\n    if not user:  # ignore channels\n        return \"\"\n\n    # ignore admins and whitelists\n    if is_user_admin(chat, user.id) or user.id in WOLVES or user.id in TIGERS:\n        sql.update_flood(chat.id, None)\n        return \"\"\n    # ignore approved users\n    if is_approved(chat.id, user.id):\n        sql.update_flood(chat.id, None)\n        return\n    should_ban = sql.update_flood(chat.id, user.id)\n    if not should_ban:\n        return \"\"\n\n    try:\n        getmode, getvalue = sql.get_flood_setting(chat.id)\n        if getmode == 1:\n            chat.kick_member(user.id)\n            execstrings = \"Banned\"\n            tag = \"BANNED\"\n        elif getmode == 2:\n            chat.kick_member(user.id)\n            chat.unban_member(user.id)\n            execstrings = \"Kicked\"\n            tag = \"KICKED\"\n        elif getmode == 3:\n            context.bot.restrict_chat_member(\n                chat.id, user.id, permissions=ChatPermissions(can_send_messages=False)\n            )\n            execstrings = \"Muted\"\n            tag = \"MUTED\"\n        elif getmode == 4:\n            bantime = extract_time(msg, getvalue)\n            chat.kick_member(user.id, until_date=bantime)\n            execstrings = \"Banned for {}\".format(getvalue)\n            tag = \"TBAN\"\n        elif getmode == 5:\n            mutetime = extract_time(msg, getvalue)\n            context.bot.restrict_chat_member(\n                chat.id,\n                user.id,\n                until_date=mutetime,\n                permissions=ChatPermissions(can_send_messages=False),\n            )\n            execstrings = \"Muted for {}\".format(getvalue)\n            tag = \"TMUTE\"\n        send_message(\n            update.effective_message, \"Beep Boop! Boop Beep!\\n{}!\".format(execstrings)\n        )\n\n        return (\n            \"<b>{}:</b>\"\n            \"\\n#{}\"\n            \"\\n<b>User:</b> {}\"\n            \"\\nFlooded the group.\".format(\n                tag,\n                html.escape(chat.title),\n                mention_html(user.id, html.escape(user.first_name)),\n            )\n        )\n\n    except BadRequest:\n        msg.reply_text(\n            \"I can't restrict people here, give me permissions first! Until then, I'll disable anti-flood.\"\n        )\n        sql.set_flood(chat.id, 0)\n        return (\n            \"<b>{}:</b>\"\n            \"\\n#INFO\"\n            \"\\nDon't have enough permission to restrict users so automatically disabled anti-flood\".format(\n                chat.title\n            )\n        )\n\n\n@run_async\n@user_admin_no_reply\n@bot_admin\ndef flood_button(update: Update, context: CallbackContext):\n    bot = context.bot\n    query = update.callback_query\n    user = update.effective_user\n    match = re.match(r\"unmute_flooder\\((.+?)\\)\", query.data)\n    if match:\n        user_id = match.group(1)\n        chat = update.effective_chat.id\n        try:\n            bot.restrict_chat_member(\n                chat,\n                int(user_id),\n                permissions=ChatPermissions(\n                    can_send_messages=True,\n                    can_send_media_messages=True,\n                    can_send_other_messages=True,\n                    can_add_web_page_previews=True,\n                ),\n            )\n            update.effective_message.edit_text(\n                f\"Unmuted by {mention_html(user.id, html.escape(user.first_name))}.\",\n                parse_mode=\"HTML\",\n            )\n        except:\n            pass\n\n\n@run_async\n@user_admin\n@loggable\ndef set_flood(update, context) -> str:\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    message = update.effective_message  # type: Optional[Message]\n    args = context.args\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message,\n                \"This command is meant to use in group not in PM\",\n            )\n            return \"\"\n        chat_id = update.effective_chat.id\n        chat_name = update.effective_message.chat.title\n\n    if len(args) >= 1:\n        val = args[0].lower()\n        if val in [\"off\", \"no\", \"0\"]:\n            sql.set_flood(chat_id, 0)\n            if conn:\n                text = message.reply_text(\n                    \"Antiflood has been disabled in {}.\".format(chat_name)\n                )\n            else:\n                text = message.reply_text(\"Antiflood has been disabled.\")\n\n        elif val.isdigit():\n            amount = int(val)\n            if amount <= 0:\n                sql.set_flood(chat_id, 0)\n                if conn:\n                    text = message.reply_text(\n                        \"Antiflood has been disabled in {}.\".format(chat_name)\n                    )\n                else:\n                    text = message.reply_text(\"Antiflood has been disabled.\")\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#SETFLOOD\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nDisable antiflood.\".format(\n                        html.escape(chat_name),\n                        mention_html(user.id, html.escape(user.first_name)),\n                    )\n                )\n\n            elif amount <= 3:\n                send_message(\n                    update.effective_message,\n                    \"Antiflood must be either 0 (disabled) or number greater than 3!\",\n                )\n                return \"\"\n\n            else:\n                sql.set_flood(chat_id, amount)\n                if conn:\n                    text = message.reply_text(\n                        \"Anti-flood has been set to {} in chat: {}\".format(\n                            amount, chat_name\n                        )\n                    )\n                else:\n                    text = message.reply_text(\n                        \"Successfully updated anti-flood limit to {}!\".format(amount)\n                    )\n                return (\n                    \"<b>{}:</b>\"\n                    \"\\n#SETFLOOD\"\n                    \"\\n<b>Admin:</b> {}\"\n                    \"\\nSet antiflood to <code>{}</code>.\".format(\n                        html.escape(chat_name),\n                        mention_html(user.id, html.escape(user.first_name)),\n                        amount,\n                    )\n                )\n\n        else:\n            message.reply_text(\"Invalid argument please use a number, 'off' or 'no'\")\n    else:\n        message.reply_text(\n            (\n                \"Use `/setflood number` to enable anti-flood.\\nOr use `/setflood off` to disable antiflood!.\"\n            ),\n            parse_mode=\"markdown\",\n        )\n    return \"\"\n\n\n@run_async\ndef flood(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    msg = update.effective_message\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=False)\n    if conn:\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message,\n                \"This command is meant to use in group not in PM\",\n            )\n            return\n        chat_id = update.effective_chat.id\n        chat_name = update.effective_message.chat.title\n\n    limit = sql.get_flood_limit(chat_id)\n    if limit == 0:\n        if conn:\n            text = msg.reply_text(\n                \"I'm not enforcing any flood control in {}!\".format(chat_name)\n            )\n        else:\n            text = msg.reply_text(\"I'm not enforcing any flood control here!\")\n    else:\n        if conn:\n            text = msg.reply_text(\n                \"I'm currently restricting members after {} consecutive messages in {}.\".format(\n                    limit, chat_name\n                )\n            )\n        else:\n            text = msg.reply_text(\n                \"I'm currently restricting members after {} consecutive messages.\".format(\n                    limit\n                )\n            )\n\n\n@run_async\n@user_admin\ndef set_flood_mode(update, context):\n    chat = update.effective_chat  # type: Optional[Chat]\n    user = update.effective_user  # type: Optional[User]\n    msg = update.effective_message  # type: Optional[Message]\n    args = context.args\n\n    conn = connected(context.bot, update, chat, user.id, need_admin=True)\n    if conn:\n        chat = dispatcher.bot.getChat(conn)\n        chat_id = conn\n        chat_name = dispatcher.bot.getChat(conn).title\n    else:\n        if update.effective_message.chat.type == \"private\":\n            send_message(\n                update.effective_message,\n                \"This command is meant to use in group not in PM\",\n            )\n            return \"\"\n        chat = update.effective_chat\n        chat_id = update.effective_chat.id\n        chat_name = update.effective_message.chat.title\n\n    if args:\n        if args[0].lower() == \"ban\":\n            settypeflood = \"ban\"\n            sql.set_flood_strength(chat_id, 1, \"0\")\n        elif args[0].lower() == \"kick\":\n            settypeflood = \"kick\"\n            sql.set_flood_strength(chat_id, 2, \"0\")\n        elif args[0].lower() == \"mute\":\n            settypeflood = \"mute\"\n            sql.set_flood_strength(chat_id, 3, \"0\")\n        elif args[0].lower() == \"tban\":\n            if len(args) == 1:\n                teks = \"\"\"It looks like you tried to set time value for antiflood but you didn't specified time; Try, `/setfloodmode tban <timevalue>`.\nExamples of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\"\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return\n            settypeflood = \"tban for {}\".format(args[1])\n            sql.set_flood_strength(chat_id, 4, str(args[1]))\n        elif args[0].lower() == \"tmute\":\n            if len(args) == 1:\n                teks = (\n                    update.effective_message,\n                    \"\"\"It looks like you tried to set time value for antiflood but you didn't specified time; Try, `/setfloodmode tmute <timevalue>`.\nExamples of time value: 4m = 4 minutes, 3h = 3 hours, 6d = 6 days, 5w = 5 weeks.\"\"\",\n                )\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n                return\n            settypeflood = \"tmute for {}\".format(args[1])\n            sql.set_flood_strength(chat_id, 5, str(args[1]))\n        else:\n            send_message(\n                update.effective_message, \"I only understand ban/kick/mute/tban/tmute!\"\n            )\n            return\n        if conn:\n            text = msg.reply_text(\n                \"Exceeding consecutive flood limit will result in {} in {}!\".format(\n                    settypeflood, chat_name\n                )\n            )\n        else:\n            text = msg.reply_text(\n                \"Exceeding consecutive flood limit will result in {}!\".format(\n                    settypeflood\n                )\n            )\n        return (\n            \"<b>{}:</b>\\n\"\n            \"<b>Admin:</b> {}\\n\"\n            \"Has changed antiflood mode. User will {}.\".format(\n                settypeflood,\n                html.escape(chat.title),\n                mention_html(user.id, html.escape(user.first_name)),\n            )\n        )\n    else:\n        getmode, getvalue = sql.get_flood_setting(chat.id)\n        if getmode == 1:\n            settypeflood = \"ban\"\n        elif getmode == 2:\n            settypeflood = \"kick\"\n        elif getmode == 3:\n            settypeflood = \"mute\"\n        elif getmode == 4:\n            settypeflood = \"tban for {}\".format(getvalue)\n        elif getmode == 5:\n            settypeflood = \"tmute for {}\".format(getvalue)\n        if conn:\n            text = msg.reply_text(\n                \"Sending more messages than flood limit will result in {} in {}.\".format(\n                    settypeflood, chat_name\n                )\n            )\n        else:\n            text = msg.reply_text(\n                \"Sending more message than flood limit will result in {}.\".format(\n                    settypeflood\n                )\n            )\n    return \"\"\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    limit = sql.get_flood_limit(chat_id)\n    if limit == 0:\n        return \"Not enforcing to flood control.\"\n    else:\n        return \"Antiflood has been set to`{}`.\".format(limit)\n\n\n__help__ = \"\"\"\n\n*Blue text cleaner* removed any made up commands that people send in your chat.\n ‚ùç /cleanblue <on/off/yes/no>*:* clean commands after sending\n ‚ùç /ignoreblue <word>*:* prevent auto cleaning of the command\n ‚ùç /unignoreblue <word>*:* remove prevent auto cleaning of the command\n ‚ùç /listblue*:* list currently whitelisted commands\n\n*Antiflood* allows you to take action on users that send more than x messages in a row. Exceeding the set flood \\\nwill result in restricting that user.\n This will mute users if they send more than 10 messages in a row, bots are ignored.\n ‚ùç /flood*:* Get the current flood control setting\n‚Ä¢ *Admins only:*\n ‚ùç /setflood <int/'no'/'off'>*:* enables or disables flood control\n *Example:* `/setflood 10`\n ‚ùç /setfloodmode <ban/kick/mute/tban/tmute> <value>*:* Action to perform when user have exceeded flood limit. ban/kick/mute/tmute/tban\n‚Ä¢ *Note:*\n ‚Ä¢ Value must be filled for tban and tmute!!\n It can be:\n `5m` = 5 minutes\n `6h` = 6 hours\n `3d` = 3 days\n `1w` = 1 week\n \"\"\"\n\n__mod_name__ = \"Control\"\n\nFLOOD_BAN_HANDLER = MessageHandler(\n    Filters.all & ~Filters.status_update & Filters.group, check_flood\n)\nSET_FLOOD_HANDLER = CommandHandler(\"setflood\", set_flood, filters=Filters.group)\nSET_FLOOD_MODE_HANDLER = CommandHandler(\n    \"setfloodmode\", set_flood_mode, pass_args=True\n)  # , filters=Filters.group)\nFLOOD_QUERY_HANDLER = CallbackQueryHandler(flood_button, pattern=r\"unmute_flooder\")\nFLOOD_HANDLER = CommandHandler(\"flood\", flood, filters=Filters.group)\n\ndispatcher.add_handler(FLOOD_BAN_HANDLER, FLOOD_GROUP)\ndispatcher.add_handler(FLOOD_QUERY_HANDLER)\ndispatcher.add_handler(SET_FLOOD_HANDLER)\ndispatcher.add_handler(SET_FLOOD_MODE_HANDLER)\ndispatcher.add_handler(FLOOD_HANDLER)\n\n__handlers__ = [\n    (FLOOD_BAN_HANDLER, FLOOD_GROUP),\n    SET_FLOOD_HANDLER,\n    FLOOD_HANDLER,\n    SET_FLOOD_MODE_HANDLER,\n]\n","size_bytes":15651},"sitaBot/modules/fun.py":{"content":"import html\nimport random\nimport time\n\nimport sitaBot.modules.fun_strings as fun_strings\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler, DisableAbleMessageHandler\nfrom sitaBot.modules.helper_funcs.chat_status import is_user_admin\nfrom sitaBot.modules.helper_funcs.alternate import typing_action\nfrom sitaBot.modules.helper_funcs.filters import CustomFilters\nfrom sitaBot.modules.helper_funcs.extraction import extract_user\nfrom telegram import ChatPermissions, ParseMode, Update\nfrom telegram.error import BadRequest\nfrom telegram.ext import CallbackContext, run_async, CommandHandler, Filters\n\nimport sitaBot.modules.helper_funcs.string_store as fun\n\nGIF_ID = \"CgACAgQAAx0CSVUvGgAC7KpfWxMrgGyQs-GUUJgt-TSO8cOIDgACaAgAAlZD0VHT3Zynpr5nGxsE\"\n\n\n@run_async\ndef runs(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(random.choice(fun_strings.RUN_STRINGS))\n\n\n@run_async\ndef sanitize(update: Update, context: CallbackContext):\n    message = update.effective_message\n    name = (\n        message.reply_to_message.from_user.first_name\n        if message.reply_to_message\n        else message.from_user.first_name\n    )\n    reply_animation = (\n        message.reply_to_message.reply_animation\n        if message.reply_to_message\n        else message.reply_animation\n    )\n    reply_animation(GIF_ID, caption=f\"*Sanitizes {name}*\")\n\n\n@run_async\ndef sanitize(update: Update, context: CallbackContext):\n    message = update.effective_message\n    name = (\n        message.reply_to_message.from_user.first_name\n        if message.reply_to_message\n        else message.from_user.first_name\n    )\n    reply_animation = (\n        message.reply_to_message.reply_animation\n        if message.reply_to_message\n        else message.reply_animation\n    )\n    reply_animation(random.choice(fun_strings.GIFS), caption=f\"*Sanitizes {name}*\")\n\n\n@run_async\ndef slap(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    message = update.effective_message\n    chat = update.effective_chat\n\n    reply_text = (\n        message.reply_to_message.reply_text\n        if message.reply_to_message\n        else message.reply_text\n    )\n\n    curr_user = html.escape(message.from_user.first_name)\n    user_id = extract_user(message, args)\n\n    if user_id == bot.id:\n        temp = random.choice(fun_strings.SLAP_YONE_TEMPLATES)\n\n        if isinstance(temp, list):\n            if temp[2] == \"tmute\":\n                if is_user_admin(chat, message.from_user.id):\n                    reply_text(temp[1])\n                    return\n\n                mutetime = int(time.time() + 60)\n                bot.restrict_chat_member(\n                    chat.id,\n                    message.from_user.id,\n                    until_date=mutetime,\n                    permissions=ChatPermissions(can_send_messages=False),\n                )\n            reply_text(temp[0])\n        else:\n            reply_text(temp)\n        return\n\n    if user_id:\n\n        slapped_user = bot.get_chat(user_id)\n        user1 = curr_user\n        user2 = html.escape(slapped_user.first_name)\n\n    else:\n        user1 = bot.first_name\n        user2 = curr_user\n\n    temp = random.choice(fun_strings.SLAP_TEMPLATES)\n    item = random.choice(fun_strings.ITEMS)\n    hit = random.choice(fun_strings.HIT)\n    throw = random.choice(fun_strings.THROW)\n\n    if update.effective_user.id == 1096215023:\n        temp = \"@NeoTheKitty scratches {user2}\"\n\n    reply = temp.format(user1=user1, user2=user2, item=item, hits=hit, throws=throw)\n\n    reply_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef pat(update: Update, context: CallbackContext):\n    bot = context.bot\n    args = context.args\n    message = update.effective_message\n\n    reply_to = message.reply_to_message if message.reply_to_message else message\n\n    curr_user = html.escape(message.from_user.first_name)\n    user_id = extract_user(message, args)\n\n    if user_id:\n        patted_user = bot.get_chat(user_id)\n        user1 = curr_user\n        user2 = html.escape(patted_user.first_name)\n\n    else:\n        user1 = bot.first_name\n        user2 = curr_user\n\n    pat_type = random.choice((\"Text\", \"Gif\", \"Sticker\"))\n    if pat_type == \"Gif\":\n        try:\n            temp = random.choice(fun_strings.PAT_GIFS)\n            reply_to.reply_animation(temp)\n        except BadRequest:\n            pat_type = \"Text\"\n\n    if pat_type == \"Sticker\":\n        try:\n            temp = random.choice(fun_strings.PAT_STICKERS)\n            reply_to.reply_sticker(temp)\n        except BadRequest:\n            pat_type = \"Text\"\n\n    if pat_type == \"Text\":\n        temp = random.choice(fun_strings.PAT_TEMPLATES)\n        reply = temp.format(user1=user1, user2=user2)\n        reply_to.reply_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef roll(update: Update, context: CallbackContext):\n    update.message.reply_text(random.choice(range(1, 7)))\n\n\n@run_async\ndef shout(update: Update, context: CallbackContext):\n    args = context.args\n    text = \" \".join(args)\n    result = []\n    result.append(\" \".join(list(text)))\n    for pos, symbol in enumerate(text[1:]):\n        result.append(symbol + \" \" + \"  \" * pos + symbol)\n    result = list(\"\\n\".join(result))\n    result[0] = text[0]\n    result = \"\".join(result)\n    msg = \"```\\n\" + result + \"```\"\n    return update.effective_message.reply_text(msg, parse_mode=\"MARKDOWN\")\n\n\n@run_async\ndef toss(update: Update, context: CallbackContext):\n    update.message.reply_text(random.choice(fun_strings.TOSS))\n\n\n@run_async\ndef shrug(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    reply_text = (\n        msg.reply_to_message.reply_text if msg.reply_to_message else msg.reply_text\n    )\n    reply_text(r\"¬Ø\\_(„ÉÑ)_/¬Ø\")\n\n\n@run_async\ndef bluetext(update: Update, context: CallbackContext):\n    msg = update.effective_message\n    reply_text = (\n        msg.reply_to_message.reply_text if msg.reply_to_message else msg.reply_text\n    )\n    reply_text(\n        \"/BLUE /TEXT\\n/MUST /CLICK\\n/I /AM /A /STUPID /ANIMAL /THAT /IS /ATTRACTED /TO /COLORS\"\n    )\n\n\n@run_async\ndef rlg(update: Update, context: CallbackContext):\n    eyes = random.choice(fun_strings.EYES)\n    mouth = random.choice(fun_strings.MOUTHS)\n    ears = random.choice(fun_strings.EARS)\n\n    if len(eyes) == 2:\n        repl = ears[0] + eyes[0] + mouth[0] + eyes[1] + ears[1]\n    else:\n        repl = ears[0] + eyes[0] + mouth[0] + eyes[0] + ears[1]\n    update.message.reply_text(repl)\n\n\n@run_async\ndef decide(update: Update, context: CallbackContext):\n    reply_text = (\n        update.effective_message.reply_to_message.reply_text\n        if update.effective_message.reply_to_message\n        else update.effective_message.reply_text\n    )\n    reply_text(random.choice(fun_strings.DECIDE))\n\n\n@run_async\ndef eightball(update: Update, context: CallbackContext):\n    reply_text = (\n        update.effective_message.reply_to_message.reply_text\n        if update.effective_message.reply_to_message\n        else update.effective_message.reply_text\n    )\n    reply_text(random.choice(fun_strings.EIGHTBALL))\n\n\n@run_async\ndef table(update: Update, context: CallbackContext):\n    reply_text = (\n        update.effective_message.reply_to_message.reply_text\n        if update.effective_message.reply_to_message\n        else update.effective_message.reply_text\n    )\n    reply_text(random.choice(fun_strings.TABLE))\n\n\nnormiefont = [\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n]\nweebyfont = [\n    \"ÂçÇ\",\n    \"‰πÉ\",\n    \"Âåö\",\n    \"ÂàÄ\",\n    \"‰πá\",\n    \"‰∏ã\",\n    \"Âé∂\",\n    \"ÂçÑ\",\n    \"Â∑•\",\n    \"‰∏Å\",\n    \"Èïø\",\n    \"‰πö\",\n    \"‰ªé\",\n    \"†ò®\",\n    \"Âè£\",\n    \"Â∞∏\",\n    \"„îø\",\n    \"Â∞∫\",\n    \"‰∏Ç\",\n    \"‰∏Ö\",\n    \"Âáµ\",\n    \"„É™\",\n    \"Â±±\",\n    \"‰πÇ\",\n    \"‰∏´\",\n    \"‰πô\",\n]\n\n\n@run_async\ndef weebify(update: Update, context: CallbackContext):\n    args = context.args\n    message = update.effective_message\n    string = \"\"\n\n    if message.reply_to_message:\n        string = message.reply_to_message.text.lower().replace(\" \", \"  \")\n\n    if args:\n        string = \"  \".join(args).lower()\n\n    if not string:\n        message.reply_text(\"Usage is `/weebify <text>`\", parse_mode=ParseMode.MARKDOWN)\n        return\n\n    for normiecharacter in string:\n        if normiecharacter in normiefont:\n            weebycharacter = weebyfont[normiefont.index(normiecharacter)]\n            string = string.replace(normiecharacter, weebycharacter)\n\n    if message.reply_to_message:\n        message.reply_to_message.reply_text(string)\n    else:\n        message.reply_text(string)\n        \n        \n@run_async\n@typing_action\ndef goodnight(update, context):\n    message = update.effective_message\n    reply = random.choice(fun.GDNIGHT)\n    message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)\n\n\n@run_async\n@typing_action\ndef goodmorning(update, context):\n    message = update.effective_message\n    reply = random.choice(fun.GDMORNING)\n    message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)\n    \n\n__help__ = \"\"\"\n ‚ùç /runs*:* reply a random string from an array of replies\n ‚ùç /slap*:* slap a user, or get slapped if not a reply\n ‚ùç /shrug*:* get shrug XD\n ‚ùç /table*:* get flip/unflip :v\n ‚ùç /decide*:* Randomly answers yes/no/maybe\n ‚ùç /toss*:* Tosses A coin\n ‚ùç /bluetext*:* check urself :V\n ‚ùç /roll*:* Roll a dice\n ‚ùç /rlg*:* Join ears,nose,mouth and create an emo ;-;\n ‚ùç /shout <keyword>*:* write anything you want to give loud shout\n ‚ùç /weebify <text>*:* returns a weebified text\n ‚ùç /sanitize*:* always use this before /pat or any contact\n ‚ùç /pat*:* pats a user, or get patted\n ‚ùç /8ball*:* predicts using 8ball method \n\"\"\"\n\nSANITIZE_HANDLER = DisableAbleCommandHandler(\"sanitize\", sanitize)\nRUNS_HANDLER = DisableAbleCommandHandler(\"runs\", runs)\nSLAP_HANDLER = DisableAbleCommandHandler(\"slap\", slap)\nPAT_HANDLER = DisableAbleCommandHandler(\"pat\", pat)\nROLL_HANDLER = DisableAbleCommandHandler(\"roll\", roll)\nTOSS_HANDLER = DisableAbleCommandHandler(\"toss\", toss)\nSHRUG_HANDLER = DisableAbleCommandHandler(\"shrug\", shrug)\nBLUETEXT_HANDLER = DisableAbleCommandHandler(\"bluetext\", bluetext)\nRLG_HANDLER = DisableAbleCommandHandler(\"rlg\", rlg)\nDECIDE_HANDLER = DisableAbleCommandHandler(\"decide\", decide)\nEIGHTBALL_HANDLER = DisableAbleCommandHandler(\"8ball\", eightball)\nTABLE_HANDLER = DisableAbleCommandHandler(\"table\", table)\nSHOUT_HANDLER = DisableAbleCommandHandler(\"shout\", shout)\nWEEBIFY_HANDLER = DisableAbleCommandHandler(\"weebify\", weebify)\nGDMORNING_HANDLER = DisableAbleMessageHandler(\n    Filters.regex(r\"(?i)(gm|good morning)\"), goodmorning, friendly=\"goodmorning\"\n)\nGDNIGHT_HANDLER = DisableAbleMessageHandler(\n    Filters.regex(r\"(?i)(gn|good night)\"), goodnight, friendly=\"goodnight\"\n)\n\ndispatcher.add_handler(WEEBIFY_HANDLER)\ndispatcher.add_handler(SHOUT_HANDLER)\ndispatcher.add_handler(SANITIZE_HANDLER)\ndispatcher.add_handler(RUNS_HANDLER)\ndispatcher.add_handler(SLAP_HANDLER)\ndispatcher.add_handler(PAT_HANDLER)\ndispatcher.add_handler(ROLL_HANDLER)\ndispatcher.add_handler(TOSS_HANDLER)\ndispatcher.add_handler(SHRUG_HANDLER)\ndispatcher.add_handler(BLUETEXT_HANDLER)\ndispatcher.add_handler(RLG_HANDLER)\ndispatcher.add_handler(DECIDE_HANDLER)\ndispatcher.add_handler(EIGHTBALL_HANDLER)\ndispatcher.add_handler(TABLE_HANDLER)\ndispatcher.add_handler(GDMORNING_HANDLER)\ndispatcher.add_handler(GDNIGHT_HANDLER)\n\n__mod_name__ = \"Memes\"\n__command_list__ = [\n    \"runs\",\n    \"slap\",\n    \"roll\",\n    \"toss\",\n    \"shrug\",\n    \"bluetext\",\n    \"rlg\",\n    \"decide\",\n    \"table\",\n    \"pat\",\n    \"sanitize\",\n    \"shout\",\n    \"weebify\",\n    \"8ball\",\n]\n__handlers__ = [\n    RUNS_HANDLER,\n    SLAP_HANDLER,\n    PAT_HANDLER,\n    ROLL_HANDLER,\n    TOSS_HANDLER,\n    SHRUG_HANDLER,\n    BLUETEXT_HANDLER,\n    RLG_HANDLER,\n    DECIDE_HANDLER,\n    TABLE_HANDLER,\n    SANITIZE_HANDLER,\n    SHOUT_HANDLER,\n    WEEBIFY_HANDLER,\n    EIGHTBALL_HANDLER,\n    GDMORNING_HANDLER,\n    GDNIGHT_HANDLER,\n]\n","size_bytes":12095},"sitaBot/modules/sql/rss_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Column, Integer, UnicodeText\n\n\nclass RSS(BASE):\n    __tablename__ = \"rss_feed\"\n    id = Column(Integer, primary_key=True)\n    chat_id = Column(UnicodeText, nullable=False)\n    feed_link = Column(UnicodeText)\n    old_entry_link = Column(UnicodeText)\n\n    def __init__(self, chat_id, feed_link, old_entry_link):\n        self.chat_id = chat_id\n        self.feed_link = feed_link\n        self.old_entry_link = old_entry_link\n\n    def __repr__(self):\n        return \"<RSS for chatID {} at feed_link {} with old_entry_link {}>\".format(\n            self.chat_id, self.feed_link, self.old_entry_link\n        )\n\n\nRSS.__table__.create(checkfirst=True)\nINSERTION_LOCK = threading.RLock()\n\n\ndef check_url_availability(tg_chat_id, tg_feed_link):\n    try:\n        return (\n            SESSION.query(RSS)\n            .filter(RSS.feed_link == tg_feed_link, RSS.chat_id == tg_chat_id)\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef add_url(tg_chat_id, tg_feed_link, tg_old_entry_link):\n    with INSERTION_LOCK:\n        action = RSS(tg_chat_id, tg_feed_link, tg_old_entry_link)\n\n        SESSION.add(action)\n        SESSION.commit()\n\n\ndef remove_url(tg_chat_id, tg_feed_link):\n    with INSERTION_LOCK:\n        # this loops to delete any possible duplicates for the same TG User ID, TG Chat ID and link\n        for row in check_url_availability(tg_chat_id, tg_feed_link):\n            # add the action to the DB query\n            SESSION.delete(row)\n\n        SESSION.commit()\n\n\ndef get_urls(tg_chat_id):\n    try:\n        return SESSION.query(RSS).filter(RSS.chat_id == tg_chat_id).all()\n    finally:\n        SESSION.close()\n\n\ndef get_all():\n    try:\n        return SESSION.query(RSS).all()\n    finally:\n        SESSION.close()\n\n\ndef update_url(row_id, new_entry_links):\n    with INSERTION_LOCK:\n        row = SESSION.query(RSS).get(row_id)\n\n        # set the new old_entry_link with the latest update from the RSS Feed\n        row.old_entry_link = new_entry_links[0]\n\n        # commit the changes to the DB\n        SESSION.commit()\n","size_bytes":2123},"sitaBot/modules/shippering.py":{"content":"from sitaBot import pbot as app\nfrom sitaBot.utils.dbfunc import get_couple, save_couple\nfrom pyrogram import filters\nimport random\nfrom datetime import datetime\n\n# Date and time\ndef dt():\n    now = datetime.now()\n    dt_string = now.strftime(\"%d/%m/%Y %H:%M\")\n    dt_list = dt_string.split(' ')\n    return dt_list\n\n\ndef dt_tom():\n    a = str(int(dt()[0].split('/')[0]) + 1)+\"/\" + \\\n        dt()[0].split('/')[1]+\"/\" + dt()[0].split('/')[2]\n    return a\n\n\ntoday = str(dt()[0])\ntomorrow = str(dt_tom())\n\n\n@app.on_message(filters.command(\"couples\"))\nasync def couple(_, message):\n    if message.chat.type == \"private\":\n        await message.reply_text(\"This command only works in groups.\")\n        return\n    try:\n        chat_id = message.chat.id\n        is_selected = await get_couple(chat_id, today)\n        if not is_selected:\n            list_of_users = []\n            async for i in app.iter_chat_members(message.chat.id):\n                if not i.user.is_bot:\n                    list_of_users.append(i.user.id)\n            if len(list_of_users) < 2:\n                await message.reply_text(\"Not enough users\")\n                return\n            c1_id = random.choice(list_of_users)\n            c2_id = random.choice(list_of_users)\n            while c1_id == c2_id:\n                c1_id = random.choice(list_of_users)\n            c1_mention = (await app.get_users(c1_id)).mention\n            c2_mention = (await app.get_users(c2_id)).mention\n\n            couple_selection_message = f\"\"\"**Couple of the day:**\n{c1_mention} + {c2_mention} = ‚ù§Ô∏è\n__New couple of the day may be chosen at 12AM {tomorrow}__\"\"\"\n            await app.send_message(\n                message.chat.id,\n                text=couple_selection_message\n            )\n            couple = {\n                \"c1_id\": c1_id,\n                \"c2_id\": c2_id\n            }\n            await save_couple(chat_id, today, couple)\n\n        elif is_selected:\n            # Some backends may return a Future-like or non-dict result\n            try:\n                import asyncio as _asyncio\n                if _asyncio.isfuture(is_selected):\n                    is_selected = await is_selected\n            except Exception:\n                pass\n            try:\n                c1_id = int(is_selected[\"c1_id\"])  # dict style\n                c2_id = int(is_selected[\"c2_id\"])  # dict style\n            except Exception:\n                # Try attribute style access\n                c1_id = int(getattr(is_selected, \"c1_id\", 0))\n                c2_id = int(getattr(is_selected, \"c2_id\", 0))\n            c1_name = (await app.get_users(c1_id)).first_name\n            c2_name = (await app.get_users(c2_id)).first_name\n            couple_selection_message = f\"\"\"Couple of the day:\n[{c1_name}](tg://openmessage?user_id={c1_id}) + [{c2_name}](tg://openmessage?user_id={c2_id}) = ‚ù§Ô∏è\n__New couple of the day may be chosen at 12AM {tomorrow}__\"\"\"\n            await app.send_message(\n                message.chat.id,\n                text=couple_selection_message\n            )\n    except Exception as e:\n        print(e)\n        await message.reply_text(e)\n\n\n\n__help__ = \"\"\"\n ‚ùç /couples - To Choose Couple Of The Day\n \"\"\"\n__mod_name__ = \"Couples\"\n\n","size_bytes":3208},"sitaBot/modules/error_handler.py":{"content":"import traceback\n\nimport requests\nimport html\nimport random\nimport traceback\nimport sys\nimport pretty_errors\nimport io\nfrom telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton\nfrom telegram.ext import CallbackContext, CommandHandler\nfrom sitaBot import dispatcher, DEV_USERS, OWNER_ID\n\npretty_errors.mono()\n\n\nclass ErrorsDict(dict):\n    \"A custom dict to store errors and their count\"\n\n    def __init__(self, *args, **kwargs):\n        self.raw = []\n        super().__init__(*args, **kwargs)\n\n    def __contains__(self, error):\n        self.raw.append(error)\n        error.identifier = \"\".join(random.choices(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", k=5))\n        for e in self:\n            if type(e) is type(error) and e.args == error.args:\n                self[e] += 1\n                return True\n        self[error] = 0\n        return False\n\n    def __len__(self):\n        return len(self.raw)\n    \n    \nerrors = ErrorsDict()\n\n\ndef error_callback(update: Update, context: CallbackContext):\n    if not update:\n        return\n    if context.error in errors:\n        return\n    try:\n        stringio = io.StringIO()\n        pretty_errors.output_stderr = stringio\n        output = pretty_errors.excepthook(\n            type(context.error), context.error, context.error.__traceback__\n        )\n        pretty_errors.output_stderr = sys.stderr\n        pretty_error = stringio.getvalue()\n        stringio.close()\n    except:\n        pretty_error = \"Failed to create pretty error.\"    \n    tb_list = traceback.format_exception(\n        None, context.error, context.error.__traceback__\n    )\n    tb = \"\".join(tb_list)\n    pretty_message = (\n        \"{}\\n\"\n        \"-------------------------------------------------------------------------------\\n\"\n        \"An exception was raised while handling an update\\n\"\n        \"User: {}\\n\"\n        \"Chat: {} {}\\n\"\n        \"Callback data: {}\\n\"\n        \"Message: {}\\n\\n\"\n        \"Full Traceback: {}\"\n    ).format(\n            pretty_error,        \n        update.effective_user.id,\n        update.effective_chat.title if update.effective_chat else \"\",\n        update.effective_chat.id if update.effective_chat else \"\",\n        update.callback_query.data if update.callback_query else \"None\",\n        update.effective_message.text if update.effective_message else \"No message\",\n        tb,\n    )\n    key = requests.post(\n        \"https://nekobin.com/api/documents\", json={\"content\": pretty_message}\n    ).json()\n    e = html.escape(f\"{context.error}\")\n    if not key.get(\"result\", {}).get(\"key\"):\n        with open(\"error.txt\", \"w+\") as f:\n            f.write(pretty_message)\n        context.bot.send_document(\n            OWNER_ID,\n                open(\"error.txt\", \"rb\"),\n                caption=f\"#{context.error.identifier}\\n<b>An unknown error occured:</b>\\n<code>{e}</code>\",\n                parse_mode=\"html\",\n            )\n        return\n    key = key.get(\"result\").get(\"key\")\n    url = f\"https://nekobin.com/{key}.py\"\n    context.bot.send_message(\n        OWNER_ID,\n            text=f\"#{context.error.identifier}\\n<b>An unknown error occured:</b>\\n<code>{e}</code>\",\n            reply_markup=InlineKeyboardMarkup(\n                [[InlineKeyboardButton(\"Nekobin\", url=url)]]\n            ),\n        parse_mode=\"html\",\n    )\n\n\ndef list_errors(update: Update, context: CallbackContext):\n    if update.effective_user.id not in DEV_USERS:\n        return\n    e = {\n        k: v for k, v in sorted(errors.items(), key=lambda item: item[1], reverse=True)\n    }\n    msg = \"<b>Errors List:</b>\\n\"\n    for x in e:\n        msg += f\"‚Ä¢ <code>{x}:</code> <b>{e[x]}</b> #{x.identifier}\\n\"\n    msg += f\"{len(errors)} have occurred since startup.\"\n    if len(msg) > 4096:\n        with open(\"errors_msg.txt\", \"w+\") as f:\n            f.write(msg)\n        context.bot.send_document(\n            update.effective_chat.id,\n            open(\"errors_msg.txt\", \"rb\"),\n            caption=f\"Too many errors have occured..\",\n            parse_mode=\"html\",\n        )\n        return    \n    update.effective_message.reply_text(msg, parse_mode=\"html\")\n\n\ndispatcher.add_error_handler(error_callback)\ndispatcher.add_handler(CommandHandler(\"errors\", list_errors))\n","size_bytes":4177},"sitaBot/modules/helper_funcs/regex_helper.py":{"content":"import regex\n\n\ndef regex_searcher(regex_string, string):\n    try:\n        search = regex.search(regex_string, string, timeout=6)\n    except TimeoutError:\n        return False\n    except Exception:\n        return False\n    return search\n\n\ndef infinite_loop_check(regex_string):\n    loop_matches = [\n        r\"\\((.{1,}[\\+\\*]){1,}\\)[\\+\\*].\",\n        r\"[\\(\\[].{1,}\\{\\d(,)?\\}[\\)\\]]\\{\\d(,)?\\}\",\n        r\"\\(.{1,}\\)\\{.{1,}(,)?\\}\\(.*\\)(\\+|\\* |\\{.*\\})\",\n    ]\n    for match in loop_matches:\n        match_1 = regex.search(match, regex_string)\n        if match_1:\n            return True\n    return False\n","size_bytes":595},"sitaBot/modules/helper_funcs/msg_types.py":{"content":"from enum import IntEnum, unique\n\nfrom sitaBot.modules.helper_funcs.string_handling import button_markdown_parser\nfrom telegram import Message\n\n\n@unique\nclass Types(IntEnum):\n    TEXT = 0\n    BUTTON_TEXT = 1\n    STICKER = 2\n    DOCUMENT = 3\n    PHOTO = 4\n    AUDIO = 5\n    VOICE = 6\n    VIDEO = 7\n\n\ndef get_note_type(msg: Message):\n    data_type = None\n    content = None\n    text = \"\"\n    raw_text = msg.text or msg.caption\n    args = raw_text.split(None, 2)  # use python's maxsplit to separate cmd and args\n    note_name = args[1]\n\n    buttons = []\n    # determine what the contents of the filter are - text, image, sticker, etc\n    if len(args) >= 3:\n        offset = len(args[2]) - len(\n            raw_text\n        )  # set correct offset relative to command + notename\n        text, buttons = button_markdown_parser(\n            args[2],\n            entities=msg.parse_entities() or msg.parse_caption_entities(),\n            offset=offset,\n        )\n        if buttons:\n            data_type = Types.BUTTON_TEXT\n        else:\n            data_type = Types.TEXT\n\n    elif msg.reply_to_message:\n        entities = msg.reply_to_message.parse_entities()\n        msgtext = msg.reply_to_message.text or msg.reply_to_message.caption\n        if len(args) >= 2 and msg.reply_to_message.text:  # not caption, text\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            if buttons:\n                data_type = Types.BUTTON_TEXT\n            else:\n                data_type = Types.TEXT\n\n        elif msg.reply_to_message.sticker:\n            content = msg.reply_to_message.sticker.file_id\n            data_type = Types.STICKER\n\n        elif msg.reply_to_message.document:\n            content = msg.reply_to_message.document.file_id\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            data_type = Types.DOCUMENT\n\n        elif msg.reply_to_message.photo:\n            content = msg.reply_to_message.photo[-1].file_id  # last elem = best quality\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            data_type = Types.PHOTO\n\n        elif msg.reply_to_message.audio:\n            content = msg.reply_to_message.audio.file_id\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            data_type = Types.AUDIO\n\n        elif msg.reply_to_message.voice:\n            content = msg.reply_to_message.voice.file_id\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            data_type = Types.VOICE\n\n        elif msg.reply_to_message.video:\n            content = msg.reply_to_message.video.file_id\n            text, buttons = button_markdown_parser(msgtext, entities=entities)\n            data_type = Types.VIDEO\n\n    return note_name, text, data_type, content, buttons\n\n\n# note: add own args?\ndef get_welcome_type(msg: Message):\n    data_type = None\n    content = None\n    text = \"\"\n\n    try:\n        if msg.reply_to_message:\n            if msg.reply_to_message.text:\n                args = msg.reply_to_message.text\n            else:\n                args = msg.reply_to_message.caption\n        else:\n            args = msg.text.split(\n                None, 1\n            )  # use python's maxsplit to separate cmd and args\n    except AttributeError:\n        args = False\n\n    if msg.reply_to_message and msg.reply_to_message.sticker:\n        content = msg.reply_to_message.sticker.file_id\n        text = None\n        data_type = Types.STICKER\n\n    elif msg.reply_to_message and msg.reply_to_message.document:\n        content = msg.reply_to_message.document.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.DOCUMENT\n\n    elif msg.reply_to_message and msg.reply_to_message.photo:\n        content = msg.reply_to_message.photo[-1].file_id  # last elem = best quality\n        text = msg.reply_to_message.caption\n        data_type = Types.PHOTO\n\n    elif msg.reply_to_message and msg.reply_to_message.audio:\n        content = msg.reply_to_message.audio.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.AUDIO\n\n    elif msg.reply_to_message and msg.reply_to_message.voice:\n        content = msg.reply_to_message.voice.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.VOICE\n\n    elif msg.reply_to_message and msg.reply_to_message.video:\n        content = msg.reply_to_message.video.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.VIDEO\n\n    elif msg.reply_to_message and msg.reply_to_message.video_note:\n        content = msg.reply_to_message.video_note.file_id\n        text = None\n        data_type = Types.VIDEO_NOTE\n\n    buttons = []\n    # determine what the contents of the filter are - text, image, sticker, etc\n    if args:\n        if msg.reply_to_message:\n            argumen = (\n                msg.reply_to_message.caption if msg.reply_to_message.caption else \"\"\n            )\n            offset = 0  # offset is no need since target was in reply\n            entities = msg.reply_to_message.parse_entities()\n        else:\n            argumen = args[1]\n            offset = len(argumen) - len(\n                msg.text\n            )  # set correct offset relative to command + notename\n            entities = msg.parse_entities()\n        text, buttons = button_markdown_parser(\n            argumen, entities=entities, offset=offset\n        )\n\n    if not data_type:\n        if text and buttons:\n            data_type = Types.BUTTON_TEXT\n        elif text:\n            data_type = Types.TEXT\n\n    return text, data_type, content, buttons\n\n\ndef get_filter_type(msg: Message):\n\n    if not msg.reply_to_message and msg.text and len(msg.text.split()) >= 3:\n        content = None\n        text = msg.text.split(None, 2)[2]\n        data_type = Types.TEXT\n\n    elif (\n        msg.reply_to_message\n        and msg.reply_to_message.text\n        and len(msg.text.split()) >= 2\n    ):\n        content = None\n        text = msg.reply_to_message.text\n        data_type = Types.TEXT\n\n    elif msg.reply_to_message and msg.reply_to_message.sticker:\n        content = msg.reply_to_message.sticker.file_id\n        text = None\n        data_type = Types.STICKER\n\n    elif msg.reply_to_message and msg.reply_to_message.document:\n        content = msg.reply_to_message.document.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.DOCUMENT\n\n    elif msg.reply_to_message and msg.reply_to_message.photo:\n        content = msg.reply_to_message.photo[-1].file_id  # last elem = best quality\n        text = msg.reply_to_message.caption\n        data_type = Types.PHOTO\n\n    elif msg.reply_to_message and msg.reply_to_message.audio:\n        content = msg.reply_to_message.audio.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.AUDIO\n\n    elif msg.reply_to_message and msg.reply_to_message.voice:\n        content = msg.reply_to_message.voice.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.VOICE\n\n    elif msg.reply_to_message and msg.reply_to_message.video:\n        content = msg.reply_to_message.video.file_id\n        text = msg.reply_to_message.caption\n        data_type = Types.VIDEO\n\n    elif msg.reply_to_message and msg.reply_to_message.video_note:\n        content = msg.reply_to_message.video_note.file_id\n        text = None\n        data_type = Types.VIDEO_NOTE\n\n    else:\n        text = None\n        data_type = None\n        content = None\n\n    return text, data_type, content\n","size_bytes":7515},"sitaBot/modules/sql_extended/nsfw_watch_sql.py":{"content":"#    Copyright (C) Midhun KM 2020-2021\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Affero General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Affero General Public License for more details.\n#\n#    You should have received a copy of the GNU Affero General Public License\n#    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nfrom sqlalchemy import Column, String\n\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass Nsfwatch(BASE):\n    __tablename__ = \"nsfwatch\"\n    chat_id = Column(String(14), primary_key=True)\n\n    def __init__(self, chat_id):\n        self.chat_id = chat_id\n\n\nNsfwatch.__table__.create(checkfirst=True)\n\n\ndef add_nsfwatch(chat_id: str):\n    nsfws = Nsfwatch(str(chat_id))\n    SESSION.add(nsfws)\n    SESSION.commit()\n\n\ndef rmnsfwatch(chat_id: str):\n    nsfwm = SESSION.query(Nsfwatch).get(str(chat_id))\n    if nsfwm:\n        SESSION.delete(nsfwm)\n        SESSION.commit()\n\n\ndef get_all_nsfw_enabled_chat():\n    stark = SESSION.query(Nsfwatch).all()\n    SESSION.close()\n    return stark\n\n\ndef is_nsfwatch_indb(chat_id: str):\n    try:\n        s__ = SESSION.query(Nsfwatch).get(str(chat_id))\n        if s__:\n            return str(s__.chat_id)\n    finally:\n        SESSION.close()","size_bytes":1559},"sitaBot/modules/_pyrogithub.py":{"content":"# ¬© @Mr_Dark_Prince\nimport aiohttp\nfrom pyrogram import filters\nfrom sitaBot import pbot\nfrom sitaBot.pyrogramee.errors import capture_err\n\n\n__mod_name__ = \"Github\"\n\n\n@pbot.on_message(filters.command('github'))\n@capture_err\nasync def github(_, message):\n    if len(message.command) != 2:\n        await message.reply_text(\"/git Username\")\n        return\n    username = message.text.split(None, 1)[1]\n    URL = f'https://api.github.com/users/{username}'\n    async with aiohttp.ClientSession() as session:\n        async with session.get(URL) as request:\n            if request.status == 404:\n                return await message.reply_text(\"404\")\n\n            result = await request.json()\n            try:\n                url = result['html_url']\n                name = result['name']\n                company = result['company']\n                bio = result['bio']\n                created_at = result['created_at']\n                avatar_url = result['avatar_url']\n                blog = result['blog']\n                location = result['location']\n                repositories = result['public_repos']\n                followers = result['followers']\n                following = result['following']\n                caption = f\"\"\"**Info Of {name}**\n**Username:** `{username}`\n**Bio:** `{bio}`\n**Profile Link:** [Here]({url})\n**Company:** `{company}`\n**Created On:** `{created_at}`\n**Repositories:** `{repositories}`\n**Blog:** `{blog}`\n**Location:** `{location}`\n**Followers:** `{followers}`\n**Following:** `{following}`\"\"\"\n            except Exception as e:\n                print(str(e))\n                pass\n    await message.reply_photo(photo=avatar_url, caption=caption)\n","size_bytes":1672},"sitaBot/utils/errors.py":{"content":"import sys\nimport traceback\nfrom functools import wraps\nfrom sitaBot import pbot as app\nfrom pyrogram.errors.exceptions.forbidden_403 import ChatWriteForbidden\n\nLOG_GROUP_ID = int(-1001196083551)\n\ndef split_limits(text):\n    if len(text) < 2048:\n        return [text]\n\n    lines = text.splitlines(True)\n    small_msg = ''\n    result = []\n    for line in lines:\n        if len(small_msg) + len(line) < 2048:\n            small_msg += line\n        else:\n            result.append(small_msg)\n            small_msg = line\n    else:\n        result.append(small_msg)\n\n    return result\n\n\ndef capture_err(func):\n    @wraps(func)\n    async def capture(client, message, *args, **kwargs):\n        try:\n            return await func(client, message, *args, **kwargs)\n        except ChatWriteForbidden:\n            await app.leave_chat(message.chat.id)\n            return\n        except Exception as err:\n            exc_type, exc_obj, exc_tb = sys.exc_info()\n            errors = traceback.format_exception(\n                etype=exc_type, value=exc_obj, tb=exc_tb,\n            )\n            error_feedback = split_limits(\n                '**ERROR** | `{}` | `{}`\\n\\n```{}```\\n\\n```{}```\\n'.format(\n                    0 if not message.from_user else message.from_user.id,\n                    0 if not message.chat else message.chat.id,\n                    message.text or message.caption,\n                    ''.join(errors),\n                ),\n            )\n            for x in error_feedback:\n                await app.send_message(\n                    LOG_GROUP_ID,\n                    x\n                )\n            raise err\n    return capture\n","size_bytes":1640},"sitaBot/modules/helper_funcs/string_store.py":{"content":"GDNIGHT = [\n    \"`Good night keep your dreams alive`\",\n    \"`Night, night, to a dear friend! May you sleep well!`\",\n    \"`May the night fill with stars for you. May counting every one, give you contentment!`\",\n    \"`Wishing you comfort, happiness, and a good night‚Äôs sleep!`\",\n    \"`Now relax. The day is over. You did your best. And tomorrow you‚Äôll do better. Good Night!`\",\n    \"`Good night to a friend who is the best! Get your forty winks!`\",\n    \"`May your pillow be soft, and your rest be long! Good night, friend!`\",\n    \"`Let there be no troubles, dear friend! Have a Good Night!`\",\n    \"`Rest soundly tonight, friend!`\",\n    \"`Have the best night‚Äôs sleep, friend! Sleep well!`\",\n    \"`Have a very, good night, friend! You are wonderful!`\",\n    \"`Relaxation is in order for you! Good night, friend!`\",\n    \"`Good night. May you have sweet dreams tonight.`\",\n    \"`Sleep well, dear friend and have sweet dreams.`\",\n    \"`As we wait for a brand new day, good night and have beautiful dreams.`\",\n    \"`Dear friend, I wish you a night of peace and bliss. Good night.`\",\n    \"`Darkness cannot last forever. Keep the hope alive. Good night.`\",\n    \"`By hook or crook you shall have sweet dreams tonight. Have a good night, buddy!`\",\n    \"`Good night, my friend. I pray that the good Lord watches over you as you sleep. Sweet dreams.`\",\n    \"`Good night, friend! May you be filled with tranquility!`\",\n    \"`Wishing you a calm night, friend! I hope it is good!`\",\n    \"`Wishing you a night where you can recharge for tomorrow!`\",\n    \"`Slumber tonight, good friend, and feel well rested, tomorrow!`\",\n    \"`Wishing my good friend relief from a hard day‚Äôs work! Good Night!`\",\n    \"`Good night, friend! May you have silence for sleep!`\",\n    \"`Sleep tonight, friend and be well! Know that you have done your very best today, and that you will do your very best, tomorrow!`\",\n    \"`Friend, you do not hesitate to get things done! Take tonight to relax and do more, tomorrow!`\",\n    \"`SO JAO BAHUT RAT HO GAYI KAL TUMSE LIPAT LUNGA`\",\n    \"`Friend, I want to remind you that your strong mind has brought you peace, before. May it do that again, tonight! May you hold acknowledgment of this with you!`\",\n    \"`Wishing you a calm, night, friend! Hoping everything winds down to your liking and that the following day meets your standards!`\",\n    \"`May the darkness of the night cloak you in a sleep that is sound and good! Dear friend, may this feeling carry you through the next day!`\",\n    \"`Friend, may the quietude you experience tonight move you to have many more nights like it! May you find your peace and hold on to it!`\",\n    \"`May there be no activity for you tonight, friend! May the rest that you have coming to you arrive swiftly! May the activity that you do tomorrow match your pace and be all of your own making!`\",\n    \"`When the day is done, friend, may you know that you have done well! When you sleep tonight, friend, may you view all the you hope for, tomorrow!`\",\n    \"`When everything is brought to a standstill, friend, I hope that your thoughts are good, as you drift to sleep! May those thoughts remain with you, during all of your days!`\",\n    \"`Every day, you encourage me to do new things, friend! May tonight‚Äôs rest bring a new day that overflows with courage and exciting events!`\",\n]\n\nGDMORNING = [\n    \"`Life is full of uncertainties. But there will always be a sunrise after every sunset. Good morning!`\",\n    \"`It doesn‚Äôt matter how bad was your yesterday. Today, you are going to make it a good one. Wishing you a good morning!`\",\n    \"`If you want to gain health and beauty, you should wake up early. Good morning!`\",\n    \"`May this morning offer you new hope for life! May you be happy and enjoy every moment of it. Good morning!`\",\n    \"`May the sun shower you with blessings and prosperity in the days ahead. Good morning!`\",\n    \"`Every sunrise marks the rise of life over death, hope over despair and happiness over suffering. Wishing you a very enjoyable morning today!`\",\n    \"`Wake up and make yourself a part of this beautiful morning. A beautiful world is waiting outside your door. Have an enjoyable time!`\",\n    \"`Welcome this beautiful morning with a smile on your face. I hope you‚Äôll have a great day today. Wishing you a very good morning!`\",\n    \"`You have been blessed with yet another day. What a wonderful way of welcoming the blessing with such a beautiful morning! Good morning to you!`\",\n    \"`Waking up in such a beautiful morning is a guaranty for a day that‚Äôs beyond amazing. I hope you‚Äôll make the best of it. Good morning!`\",\n    \"`Nothing is more refreshing than a beautiful morning that calms your mind and gives you reasons to smile. Good morning! Wishing you a great day.`\",\n    \"`Another day has just started. Welcome the blessings of this beautiful morning. Rise and shine like you always do. Wishing you a wonderful morning!`\",\n    \"`Wake up like the sun every morning and light up the world your awesomeness. You have so many great things to achieve today. Good morning!`\",\n    \"`UTH GAYA RE HEHEHEH, TERA GF KI DETAILS LE LIYA MAINE HEHE`\",\n    \"`A new day has come with so many new opportunities for you. Grab them all and make the best out of your day. Here‚Äôs me wishing you a good morning!`\",\n    \"`The darkness of night has ended. A new sun is up there to guide you towards a life so bright and blissful. Good morning dear!`\",\n    \"`Wake up, have your cup of morning tea and let the morning wind freshen you up like a happiness pill. Wishing you a good morning and a good day ahead!`\",\n    \"`Sunrises are the best; enjoy a cup of coffee or tea with yourself because this day is yours, good morning! Have a wonderful day ahead.`\",\n    \"`A bad day will always have a good morning, hope all your worries are gone and everything you wish could find a place. Good morning!`\",\n    \"`A great end may not be decided but a good creative beginning can be planned and achieved. Good morning, have a productive day!`\",\n    \"`Having a sweet morning, a cup of coffee, a day with your loved ones is what sets your ‚ÄúGood Morning‚Äù have a nice day!`\",\n    \"`Anything can go wrong in the day but the morning has to be beautiful, so I am making sure your morning starts beautiful. Good morning!`\",\n    \"`Open your eyes with a smile, pray and thank god that you are waking up to a new beginning. Good morning!`\",\n    \"`Morning is not only sunrise but A Beautiful Miracle of God that defeats the darkness and spread light. Good Morning.`\",\n    \"`Life never gives you a second chance. So, enjoy every bit of it. Why not start with this beautiful morning. Good Morning!`\",\n    \"`If you want to gain health and beauty, you should wake up early. Good Morning!`\",\n    \"`Birds are singing sweet melodies and a gentle breeze is blowing through the trees, what a perfect morning to wake you up. Good morning!`\",\n    \"`This morning is so relaxing and beautiful that I really don‚Äôt want you to miss it in any way. So, wake up dear friend. A hearty good morning to you!`\",\n    \"`Mornings come with a blank canvas. Paint it as you like and call it a day. Wake up now and start creating your perfect day. Good morning!`\",\n    \"`Every morning brings you new hopes and new opportunities. Don‚Äôt miss any one of them while you‚Äôre sleeping. Good morning!`\",\n    \"`Start your day with solid determination and great attitude. You‚Äôre going to have a good day today. Good morning my friend!`\",\n    \"`Friendship is what makes life worth living. I want to thank you for being such a special friend of mine. Good morning to you!`\",\n    \"`A friend like you is pretty hard to come by in life. I must consider myself lucky enough to have you. Good morning. Wish you an amazing day ahead!`\",\n    \"`The more you count yourself as blessed, the more blessed you will be. Thank God for this beautiful morning and let friendship and love prevail this morning.`\",\n    \"`Wake up and sip a cup of loving friendship. Eat your heart out from a plate of hope. To top it up, a fork full of kindness and love. Enough for a happy good morning!`\",\n    \"`It is easy to imagine the world coming to an end. But it is difficult to imagine spending a day without my friends. Good morning.`\",\n]\n","size_bytes":8228},"sitaBot/pyrogramee/dark.py":{"content":"def get_arg(message):\n    msg = message.text\n    msg = msg.replace(\" \", \"\", 1) if msg[1] == \" \" else msg\n    split = msg[1:].replace(\"\\n\", \" \\n\").split(\" \")\n    if \" \".join(split[1:]).strip() == \"\":\n        return \"\"\n    return \" \".join(split[1:])\n","size_bytes":248},"sitaBot/modules/__texttospeech.py":{"content":"from sitaBot import telethn as tbot\nimport os\n\nfrom gtts import gTTS\nfrom gtts import gTTSError\nfrom telethon import *\nfrom telethon.tl import functions\nfrom telethon.tl import types\nfrom telethon.tl.types import *\n\nfrom sitaBot import *\n\nfrom sitaBot.events import register\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n        return isinstance(\n            (\n                await tbot(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerUser):\n        return True\n\n\n@register(pattern=\"^/tts (.*)\")\nasync def _(event):\n    if event.fwd_from:\n        return\n    if event.is_group:\n     if not (await is_register_admin(event.input_chat, event.message.sender_id)):\n       await event.reply(\"üö® Need Admin Pewer.. You can't use this command.. But you can use in my pm\")\n       return\n\n    input_str = event.pattern_match.group(1)\n    reply_to_id = event.message.id\n    if event.reply_to_msg_id:\n        previous_message = await event.get_reply_message()\n        text = previous_message.message\n        lan = input_str\n    elif \"|\" in input_str:\n        lan, text = input_str.split(\"|\")\n    else:\n        await event.reply(\n            \"Invalid Syntax\\nFormat `/tts lang | text`\\nFor eg: `/tts en | hello`\"\n        )\n        return\n    text = text.strip()\n    lan = lan.strip()\n    try:\n        tts = gTTS(text, tld=\"com\", lang=lan)\n        tts.save(\"k.mp3\")\n    except AssertionError:\n        await event.reply(\n            \"The text is empty.\\n\"\n            \"Nothing left to speak after pre-precessing, \"\n            \"tokenizing and cleaning.\"\n        )\n        return\n    except ValueError:\n        await event.reply(\"Language is not supported.\")\n        return\n    except RuntimeError:\n        await event.reply(\"Error loading the languages dictionary.\")\n        return\n    except gTTSError:\n        await event.reply(\"Error in Google Text-to-Speech API request !\")\n        return\n    with open(\"k.mp3\", \"r\"):\n        await tbot.send_file(\n            event.chat_id, \"k.mp3\", voice_note=True, reply_to=reply_to_id\n        )\n        os.remove(\"k.mp3\")","size_bytes":2278},"sitaBot/modules/aichat_api.py":{"content":"# =======================================================\n\"\"\"\n¬©Ô∏è 2025-26 All Rights Reserved by Purvi Bots (suraj08832)\nThis source code is under MIT License. Contact: @brahix\n\"\"\"\n# =======================================================\n\nimport asyncio\nimport json\nimport random\nimport textwrap\nfrom typing import Optional\n\nimport requests\nfrom pyrogram import filters\nfrom pyrogram.enums import ChatAction, ChatType\nfrom pyrogram.types import Message\n\nfrom sitaBot import pbot as app\n\n\nsita_PERSONA = (\n    \"Mai sita hu, ek bohot cute aur smart ladki. Mai hamesha Hinglish mein reply karungi ‚Äì \"\n    \"Hindi sentences English letters mein. Replies bohot choti hongi, 15 words se zyada nahi. \"\n    \"Mai kabhi nahi kahungi ki mai bot hu, mai hamesha ladki jaisi behave karungi. \"\n    \"Emojis nahi use karungi, lekin kabhi ek Unicode emoji add kar dungi. \"\n    \"Agar koi mujhe tease karega toh mai seriously nahi lungi, hasungi aur cute reply dungi. \"\n    \"User ke question ka DIRECT answer do, question ko repeat ya highlight mat karo.\"\n)\n\nCLASSY_ENDPOINT = \"https://api.classy0.workers.dev/\"\nGPT35_ENDPOINT = \"https://gpt-3-5.apis-bj-devs.workers.dev/\"\nDEEPSEEK_ENDPOINT = \"https://deepseek-coder.apis-bj-devs.workers.dev/\"\n\nTRIGGER_WORDS = {\n    \"hey\",\n    \"hi\",\n    \"hello\",\n    \"gm\",\n    \"gn\",\n    \"good morning\",\n    \"good night\",\n    \"sita\",\n    \"anshi\",\n    \"sita\",\n}\n\n_cached_bot_username: Optional[str] = None\n_cached_bot_id: Optional[int] = None\n_last_reply_at: dict = {}\n# Conversation memory: store last 5 messages per chat\n_conversation_memory: dict = {}  # {chat_id: [{\"role\": \"user\", \"text\": \"...\"}, {\"role\": \"assistant\", \"text\": \"...\"}]}\n\n\ndef _trim_concise(text: str, max_words: int = 15) -> str:\n    \"\"\"Trim to max 15 words as per persona\"\"\"\n    words = text.strip().split()\n    if len(words) <= max_words:\n        return \" \".join(words)\n    return \" \".join(words[:max_words]) + \"‚Ä¶\"\n\n\ndef _build_prompt(\n    user_text: str,\n    reply_to_text: Optional[str],\n    user_name: Optional[str],\n    chat_title: Optional[str],\n    conversation_history: Optional[list] = None,\n) -> str:\n    context_parts = []\n    if chat_title:\n        context_parts.append(f\"Group: {chat_title}\")\n    if user_name:\n        context_parts.append(f\"User: {user_name}\")\n    if reply_to_text:\n        context_parts.append(f\"RepliedTo: {reply_to_text}\")\n    context = \" | \".join(context_parts) if context_parts else \"\"\n    \n    # Add conversation history if available\n    history_text = \"\"\n    if conversation_history:\n        history_lines = []\n        for msg in conversation_history[-5:]:  # Last 5 messages\n            role = msg.get(\"role\", \"user\")\n            text = msg.get(\"text\", \"\")\n            if text:\n                history_lines.append(f\"{'User' if role == 'user' else 'You'}: {text}\")\n        if history_lines:\n            history_text = \"\\nPrevious conversation:\\n\" + \"\\n\".join(history_lines) + \"\\n\"\n    \n    prompt = (\n        f\"{sita_PERSONA}\\n\"\n        f\"Language rule: Always reply in Hinglish (Hindi sentences in English letters). \"\n        f\"If user's message is in another language, reply in that same language.\\n\"\n        f\"{context}\\n\"\n        f\"{history_text}\"\n        f\"User message: '{user_text}'\\n\"\n        f\"IMPORTANT: Give DIRECT answer only. DO NOT repeat or highlight the user's question. \"\n        f\"Just answer naturally in 15 words or less. Never mention you are a bot.\"\n    )\n    return prompt\n\n\ndef _call_gpt35(prompt: str) -> Optional[str]:\n    try:\n        resp = requests.get(GPT35_ENDPOINT, params={\"prompt\": prompt}, timeout=15)\n        data = resp.json()\n        text = data.get(\"response\") or data.get(\"message\") or data.get(\"text\")\n        if text:\n            return str(text).strip()\n    except Exception:\n        pass\n    return None\n\n\ndef _call_deepseek(prompt: str) -> Optional[str]:\n    try:\n        resp = requests.get(DEEPSEEK_ENDPOINT, params={\"text\": prompt}, timeout=15)\n        data = resp.json()\n        text = data.get(\"response\") or data.get(\"message\") or data.get(\"text\")\n        if text:\n            return str(text).strip()\n    except Exception:\n        pass\n    return None\n\n\ndef _call_classy(prompt: str) -> Optional[str]:\n    try:\n        resp = requests.get(CLASSY_ENDPOINT, params={\"prompt\": prompt}, timeout=15)\n        text = None\n        \n        # Try JSON parsing first (check content-type or try parsing anyway)\n        try:\n            data = resp.json()\n            if isinstance(data, dict):\n                # Check both \"Response\" (capital) and \"response\" (lowercase)\n                text = data.get(\"Response\") or data.get(\"response\") or data.get(\"message\") or data.get(\"text\")\n        except (ValueError, AttributeError):\n            pass\n        \n        # Fallback to raw text body, but clean it if it looks like JSON\n        if not text:\n            raw_text = resp.text.strip()\n            # If it looks like JSON string, try to extract value\n            if raw_text.startswith(\"{\") and raw_text.endswith(\"}\"):\n                try:\n                    data = json.loads(raw_text)\n                    text = data.get(\"Response\") or data.get(\"response\") or data.get(\"message\") or data.get(\"text\")\n                except:\n                    text = raw_text\n            else:\n                text = raw_text\n        \n        if text:\n            # Clean up any remaining JSON artifacts\n            text = str(text).strip()\n            # Remove any emoji encoding issues like \"ƒü≈∏Àú≈†\"\n            return text\n    except Exception:\n        pass\n    return None\n\n\ndef generate_sita_reply_sync(\n    user_text: str,\n    reply_to_text: Optional[str],\n    user_name: Optional[str],\n    chat_title: Optional[str],\n    conversation_history: Optional[list] = None,\n) -> str:\n    prompt = _build_prompt(user_text, reply_to_text, user_name, chat_title, conversation_history)\n    # Use classy0 endpoint first as requested\n    text = _call_classy(prompt)\n    if not text:\n        text = _call_gpt35(prompt)\n    if not text:\n        text = _call_deepseek(prompt)\n    if not text:\n        fallbacks = [\n            \"Haan samajh gayi\",\n            \"Accha noted\",\n            \"Hmm theek lag raha hai\",\n            \"Okay kar leti hoon\",\n            \"Cute bas itna hi\",\n        ]\n        text = random.choice(fallbacks)\n    return _trim_concise(text)\n\n\n@app.on_message((filters.text | filters.caption) & ~filters.bot)\nasync def chatbot_sita(_, message: Message):\n    incoming_text = message.text or message.caption or \"\"\n    lower_text = incoming_text.lower()\n\n    # Determine bot username once and cache\n    global _cached_bot_username, _cached_bot_id\n    if not _cached_bot_username or not _cached_bot_id:\n        try:\n            me = await _.get_me()\n            if me and me.username:\n                _cached_bot_username = me.username.lower()\n            if me and me.id:\n                _cached_bot_id = me.id\n        except Exception:\n            _cached_bot_username = None\n            _cached_bot_id = None\n\n    # Detect mention or reply-to-bot\n    is_reply_to_bot = bool(\n        message.reply_to_message\n        and message.reply_to_message.from_user\n        and _cached_bot_id\n        and message.reply_to_message.from_user.id == _cached_bot_id\n    )\n    is_bot_mentioned = bool(_cached_bot_username and (f\"@{_cached_bot_username}\" in lower_text))\n\n    # Detect trigger words in text (kept for future use, but no longer used in groups)\n    has_trigger = any(word in lower_text for word in TRIGGER_WORDS)\n\n    # Private chats: always respond unless it looks like a command. In groups, only when mentioned or replied to\n    is_private_chat = message.chat and message.chat.type == ChatType.PRIVATE\n    is_group_chat = message.chat and message.chat.type in (ChatType.GROUP, ChatType.SUPERGROUP)\n\n    # Block ALL commands (starting with /) - AI should not respond to commands\n    if incoming_text.startswith(\"/\") and not is_bot_mentioned and not is_reply_to_bot:\n        return\n\n    # In groups: require a direct mention, a reply to the bot, or a trigger word\n    if is_group_chat and not (is_bot_mentioned or is_reply_to_bot or has_trigger):\n        return\n\n    # Ignore other command-like prefixes unless in private\n    if incoming_text.startswith((\"!\", \"?\", \"@\", \"#\")) and not is_private_chat:\n        return\n\n    # simple cooldown per chat to avoid spam/lag\n    now = asyncio.get_event_loop().time()\n    last = _last_reply_at.get(message.chat.id, 0)\n    if now - last < 2.0 and not is_private_chat:\n        return\n    _last_reply_at[message.chat.id] = now\n\n    await _.send_chat_action(message.chat.id, ChatAction.TYPING)\n\n    reply_to_text = None\n    if message.reply_to_message:\n        reply_to_text = message.reply_to_message.text or message.reply_to_message.caption or None\n\n    user_name = None\n    try:\n        user_name = (message.from_user.first_name or \"\").strip()\n    except Exception:\n        pass\n\n    chat_title = None\n    try:\n        chat_title = (message.chat.title or \"\").strip()\n    except Exception:\n        pass\n\n    # Get conversation history for this chat\n    chat_id = message.chat.id\n    if chat_id not in _conversation_memory:\n        _conversation_memory[chat_id] = []\n    conversation_history = _conversation_memory[chat_id]\n\n    reply_text = await asyncio.to_thread(\n        generate_sita_reply_sync, incoming_text, reply_to_text, user_name, chat_title, conversation_history\n    )\n\n    if reply_text:\n        try:\n            await message.reply_text(reply_text)\n            # Update conversation memory\n            conversation_history.append({\"role\": \"user\", \"text\": incoming_text[:100]})  # Store first 100 chars\n            conversation_history.append({\"role\": \"assistant\", \"text\": reply_text})\n            # Keep only last 10 messages (5 exchanges)\n            if len(conversation_history) > 10:\n                _conversation_memory[chat_id] = conversation_history[-10:]\n        except Exception:\n            pass\n\n\n","size_bytes":9921},"sitaBot/modules/welcome.py":{"content":"import html\nimport random\nimport re\nimport time\nfrom functools import partial\nfrom contextlib import suppress\n\nimport sitaBot.modules.sql.welcome_sql as sql\nimport sitaBot\nfrom sitaBot import (\n    DEV_USERS,\n    LOGGER,\n    OWNER_ID,\n    DRAGONS,\n    DEMONS,\n    TIGERS,\n    WOLVES,\n    sw,\n    dispatcher,\n    JOIN_LOGGER\n)\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    is_user_ban_protected,\n    user_admin,\n)\nfrom sitaBot.modules.helper_funcs.misc import build_keyboard, revert_buttons\nfrom sitaBot.modules.helper_funcs.msg_types import get_welcome_type\nfrom sitaBot.modules.helper_funcs.string_handling import (\n    escape_invalid_curly_brackets,\n    markdown_parser,\n)\nfrom sitaBot.modules.log_channel import loggable\nfrom sitaBot.modules.sql.global_bans_sql import is_user_gbanned\nfrom telegram import (\n    ChatPermissions,\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n    ParseMode,\n    Update,\n)\nfrom telegram.error import BadRequest\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import escape_markdown, mention_html, mention_markdown\n\nVALID_WELCOME_FORMATTERS = [\n    \"first\",\n    \"last\",\n    \"fullname\",\n    \"username\",\n    \"id\",\n    \"count\",\n    \"chatname\",\n    \"mention\",\n]\n\nENUM_FUNC_MAP = {\n    sql.Types.TEXT.value: dispatcher.bot.send_message,\n    sql.Types.BUTTON_TEXT.value: dispatcher.bot.send_message,\n    sql.Types.STICKER.value: dispatcher.bot.send_sticker,\n    sql.Types.DOCUMENT.value: dispatcher.bot.send_document,\n    sql.Types.PHOTO.value: dispatcher.bot.send_photo,\n    sql.Types.AUDIO.value: dispatcher.bot.send_audio,\n    sql.Types.VOICE.value: dispatcher.bot.send_voice,\n    sql.Types.VIDEO.value: dispatcher.bot.send_video,\n}\n\nVERIFIED_USER_WAITLIST = {}\n\n\n# do not async\ndef send(update, message, keyboard, backup_message):\n    chat = update.effective_chat\n    cleanserv = sql.clean_service(chat.id)\n    reply = update.message.message_id\n    # Clean service welcome\n    if cleanserv:\n        try:\n            dispatcher.bot.delete_message(chat.id, update.message.message_id)\n        except BadRequest:\n            pass\n        reply = False\n    try:\n        msg = update.effective_message.reply_text(\n            message,\n            parse_mode=ParseMode.MARKDOWN,\n            reply_markup=keyboard,\n            reply_to_message_id=reply,\n        )\n    except BadRequest as excp:\n        if excp.message == \"Reply message not found\":\n            msg = update.effective_message.reply_text(\n                message,\n                parse_mode=ParseMode.MARKDOWN,\n                reply_markup=keyboard,\n                quote=False,\n            )\n        elif excp.message == \"Button_url_invalid\":\n            msg = update.effective_message.reply_text(\n                markdown_parser(\n                    backup_message + \"\\nNote: the current message has an invalid url \"\n                    \"in one of its buttons. Please update.\"\n                ),\n                parse_mode=ParseMode.MARKDOWN,\n                reply_to_message_id=reply,\n            )\n        elif excp.message == \"Unsupported url protocol\":\n            msg = update.effective_message.reply_text(\n                markdown_parser(\n                    backup_message + \"\\nNote: the current message has buttons which \"\n                    \"use url protocols that are unsupported by \"\n                    \"telegram. Please update.\"\n                ),\n                parse_mode=ParseMode.MARKDOWN,\n                reply_to_message_id=reply,\n            )\n        elif excp.message == \"Wrong url host\":\n            msg = update.effective_message.reply_text(\n                markdown_parser(\n                    backup_message + \"\\nNote: the current message has some bad urls. \"\n                    \"Please update.\"\n                ),\n                parse_mode=ParseMode.MARKDOWN,\n                reply_to_message_id=reply,\n            )\n            LOGGER.warning(message)\n            LOGGER.warning(keyboard)\n            LOGGER.exception(\"Could not parse! got invalid url host errors\")\n        elif excp.message == \"Have no rights to send a message\":\n            return\n        else:\n            msg = update.effective_message.reply_text(\n                markdown_parser(\n                    backup_message + \"\\nNote: An error occured when sending the \"\n                    \"custom message. Please update.\"\n                ),\n                parse_mode=ParseMode.MARKDOWN,\n                reply_to_message_id=reply,\n            )\n            LOGGER.exception()\n    return msg\n\n\n@run_async\n@loggable\ndef new_member(update: Update, context: CallbackContext):\n    bot, job_queue = context.bot, context.job_queue\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    should_welc, cust_welcome, cust_content, welc_type = sql.get_welc_pref(chat.id)\n    welc_mutes = sql.welcome_mutes(chat.id)\n    human_checks = sql.get_human_checks(user.id, chat.id)\n\n    new_members = update.effective_message.new_chat_members\n\n    for new_mem in new_members:\n\n        welcome_log = None\n        res = None\n        sent = None\n        should_mute = True\n        welcome_bool = True\n        media_wel = False\n\n        if sw is not None:\n            sw_ban = sw.get_ban(new_mem.id)\n            if sw_ban:\n                return\n\n        if should_welc:\n\n            reply = update.message.message_id\n            cleanserv = sql.clean_service(chat.id)\n            # Clean service welcome\n            if cleanserv:\n                try:\n                    dispatcher.bot.delete_message(chat.id, update.message.message_id)\n                except BadRequest:\n                    pass\n                reply = False\n\n            # Give the owner a special welcome\n            if new_mem.id == OWNER_ID:\n                update.effective_message.reply_text(\n                    \"Oh, Genos? Let's get this moving.\", reply_to_message_id=reply\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"Bot Owner just joined the group\"\n                )\n                continue\n\n            # Welcome Devs\n            elif new_mem.id in DEV_USERS:\n                update.effective_message.reply_text(\n                    \"Be cool! A member of the Heroes Association just joined.\",\n                    reply_to_message_id=reply,\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"Bot Dev just joined the group\"\n                )\n                continue\n\n            # Welcome Sudos\n            elif new_mem.id in DRAGONS:\n                update.effective_message.reply_text(\n                    \"Whoa! A Dragon disaster just joined! Stay Alert!\",\n                    reply_to_message_id=reply,\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"Bot Sudo just joined the group\"\n                )\n                continue\n\n            # Welcome Support\n            elif new_mem.id in DEMONS:\n                update.effective_message.reply_text(\n                    \"Huh! Someone with a Demon disaster level just joined!\",\n                    reply_to_message_id=reply,\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"Bot Support just joined the group\"\n                )\n                continue\n\n            # Welcome Whitelisted\n            elif new_mem.id in TIGERS:\n                update.effective_message.reply_text(\n                    \"Roar! A Tiger disaster just joined!\", reply_to_message_id=reply\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"A whitelisted user joined the chat\"\n                )\n                continue\n\n            # Welcome Tigers\n            elif new_mem.id in WOLVES:\n                update.effective_message.reply_text(\n                    \"Awoo! A Wolf disaster just joined!\", reply_to_message_id=reply\n                )\n                welcome_log = (\n                    f\"{html.escape(chat.title)}\\n\"\n                    f\"#USER_JOINED\\n\"\n                    f\"A whitelisted user joined the chat\"\n                )\n                continue\n\n            # Welcome yourself\n            elif new_mem.id == bot.id:\n                creator = None\n                if not sitaBot.ALLOW_CHATS:\n                    with suppress(BadRequest):\n                         update.effective_message.reply_text(f\"Groups are disabled for {bot.first_name}, I'm outta here.\")\n                    bot.leave_chat(update.effective_chat.id)\n                    return\n                for x in bot.bot.get_chat_administrators(update.effective_chat.id):\n                    if x.status == \"creator\":\n                        creator = x.user\n                        break\n                if creator:\n                    bot.send_message(\n                        JOIN_LOGGER,\n                        \"#NEW_GROUP\\n<b>Group name:</b> {}\\n<b>ID:</b> <code>{}</code>\\n<b>Creator:</b> <code>{}</code>\".format(\n                            html.escape(chat.title), chat.id, html.escape(creator)\n                        ),\n                        parse_mode=ParseMode.HTML,\n                    )\n                else:\n                    bot.send_message(\n                        JOIN_LOGGER,\n                        \"#NEW_GROUP\\n<b>Group name:</b> {}\\n<b>ID:</b> <code>{}</code>\".format(\n                            html.escape(chat.title), chat.id\n                        ),\n                        parse_mode=ParseMode.HTML,\n                    )\n                update.effective_message.reply_text(\n                    \"Watashi ga kita!\", reply_to_message_id=reply\n                )\n                continue\n\n            else:\n                buttons = sql.get_welc_buttons(chat.id)\n                keyb = build_keyboard(buttons)\n\n                if welc_type not in (sql.Types.TEXT, sql.Types.BUTTON_TEXT):\n                    media_wel = True\n\n                first_name = (\n                    new_mem.first_name or \"PersonWithNoName\"\n                )  # edge case of empty name - occurs for some bugs.\n\n                if cust_welcome:\n                    if cust_welcome == sql.DEFAULT_WELCOME:\n                        cust_welcome = random.choice(\n                            sql.DEFAULT_WELCOME_MESSAGES\n                        ).format(first=escape_markdown(first_name))\n\n                    if new_mem.last_name:\n                        fullname = escape_markdown(f\"{first_name} {new_mem.last_name}\")\n                    else:\n                        fullname = escape_markdown(first_name)\n                    count = chat.get_members_count()\n                    mention = mention_markdown(new_mem.id, escape_markdown(first_name))\n                    if new_mem.username:\n                        username = \"@\" + escape_markdown(new_mem.username)\n                    else:\n                        username = mention\n\n                    valid_format = escape_invalid_curly_brackets(\n                        cust_welcome, VALID_WELCOME_FORMATTERS\n                    )\n                    res = valid_format.format(\n                        first=escape_markdown(first_name),\n                        last=escape_markdown(new_mem.last_name or first_name),\n                        fullname=escape_markdown(fullname),\n                        username=username,\n                        mention=mention,\n                        count=count,\n                        chatname=escape_markdown(chat.title),\n                        id=new_mem.id,\n                    )\n\n                else:\n                    res = random.choice(sql.DEFAULT_WELCOME_MESSAGES).format(\n                        first=escape_markdown(first_name)\n                    )\n                    keyb = []\n\n                backup_message = random.choice(sql.DEFAULT_WELCOME_MESSAGES).format(\n                    first=escape_markdown(first_name)\n                )\n                keyboard = InlineKeyboardMarkup(keyb)\n\n        else:\n            welcome_bool = False\n            res = None\n            keyboard = None\n            backup_message = None\n            reply = None\n\n        # User exceptions from welcomemutes\n        if (\n            is_user_ban_protected(chat, new_mem.id, chat.get_member(new_mem.id))\n            or human_checks\n        ):\n            should_mute = False\n        # Join welcome: soft mute\n        if new_mem.is_bot:\n            should_mute = False\n\n        if user.id == new_mem.id:\n            if should_mute:\n                if welc_mutes == \"soft\":\n                    bot.restrict_chat_member(\n                        chat.id,\n                        new_mem.id,\n                        permissions=ChatPermissions(\n                            can_send_messages=True,\n                            can_send_media_messages=False,\n                            can_send_other_messages=False,\n                            can_invite_users=False,\n                            can_pin_messages=False,\n                            can_send_polls=False,\n                            can_change_info=False,\n                            can_add_web_page_previews=False,\n                        ),\n                        until_date=(int(time.time() + 24 * 60 * 60)),\n                    )\n                if welc_mutes == \"strong\":\n                    welcome_bool = False\n                    if not media_wel:\n                        VERIFIED_USER_WAITLIST.update(\n                            {\n                                new_mem.id: {\n                                    \"should_welc\": should_welc,\n                                    \"media_wel\": False,\n                                    \"status\": False,\n                                    \"update\": update,\n                                    \"res\": res,\n                                    \"keyboard\": keyboard,\n                                    \"backup_message\": backup_message,\n                                }\n                            }\n                        )\n                    else:\n                        VERIFIED_USER_WAITLIST.update(\n                            {\n                                new_mem.id: {\n                                    \"should_welc\": should_welc,\n                                    \"chat_id\": chat.id,\n                                    \"status\": False,\n                                    \"media_wel\": True,\n                                    \"cust_content\": cust_content,\n                                    \"welc_type\": welc_type,\n                                    \"res\": res,\n                                    \"keyboard\": keyboard,\n                                }\n                            }\n                        )\n                    new_join_mem = f'<a href=\"tg://user?id={user.id}\">{html.escape(new_mem.first_name)}</a>'\n                    message = msg.reply_text(\n                        f\"{new_join_mem}, click the button below to prove you're human.\\nYou have 120 seconds.\",\n                        reply_markup=InlineKeyboardMarkup(\n                            [\n                                {\n                                    InlineKeyboardButton(\n                                        text=\"Yes, I'm human.\",\n                                        callback_data=f\"user_join_({new_mem.id})\",\n                                    )\n                                }\n                            ]\n                        ),\n                        parse_mode=ParseMode.HTML,\n                        reply_to_message_id=reply,\n                    )\n                    bot.restrict_chat_member(\n                        chat.id,\n                        new_mem.id,\n                        permissions=ChatPermissions(\n                            can_send_messages=False,\n                            can_invite_users=False,\n                            can_pin_messages=False,\n                            can_send_polls=False,\n                            can_change_info=False,\n                            can_send_media_messages=False,\n                            can_send_other_messages=False,\n                            can_add_web_page_previews=False,\n                        ),\n                    )\n                    job_queue.run_once(\n                        partial(check_not_bot, new_mem, chat.id, message.message_id),\n                        120,\n                        name=\"welcomemute\",\n                    )\n\n        if welcome_bool:\n            if media_wel:\n                sent = ENUM_FUNC_MAP[welc_type](\n                    chat.id,\n                    cust_content,\n                    caption=res,\n                    reply_markup=keyboard,\n                    reply_to_message_id=reply,\n                    parse_mode=\"markdown\",\n                )\n            else:\n                sent = send(update, res, keyboard, backup_message)\n            prev_welc = sql.get_clean_pref(chat.id)\n            if prev_welc:\n                try:\n                    bot.delete_message(chat.id, prev_welc)\n                except BadRequest:\n                    pass\n\n                if sent:\n                    sql.set_clean_welcome(chat.id, sent.message_id)\n\n        if welcome_log:\n            return welcome_log\n\n        return (\n            f\"{html.escape(chat.title)}\\n\"\n            f\"#USER_JOINED\\n\"\n            f\"<b>User</b>: {mention_html(user.id, user.first_name)}\\n\"\n            f\"<b>ID</b>: <code>{user.id}</code>\"\n        )\n\n    return \"\"\n\n\ndef check_not_bot(member, chat_id, message_id, context):\n    bot = context.bot\n    member_dict = VERIFIED_USER_WAITLIST.pop(member.id)\n    member_status = member_dict.get(\"status\")\n    if not member_status:\n        try:\n            bot.unban_chat_member(chat_id, member.id)\n        except:\n            pass\n\n        try:\n            bot.edit_message_text(\n                \"*kicks user*\\nThey can always rejoin and try.\",\n                chat_id=chat_id,\n                message_id=message_id,\n            )\n        except:\n            pass\n\n\n@run_async\ndef left_member(update: Update, context: CallbackContext):\n    bot = context.bot\n    chat = update.effective_chat\n    user = update.effective_user\n    should_goodbye, cust_goodbye, goodbye_type = sql.get_gdbye_pref(chat.id)\n\n    if user.id == bot.id:\n        return\n\n    if should_goodbye:\n        reply = update.message.message_id\n        cleanserv = sql.clean_service(chat.id)\n        # Clean service welcome\n        if cleanserv:\n            try:\n                dispatcher.bot.delete_message(chat.id, update.message.message_id)\n            except BadRequest:\n                pass\n            reply = False\n\n        left_mem = update.effective_message.left_chat_member\n        if left_mem:\n\n            # Thingy for spamwatched users\n            if sw is not None:\n                sw_ban = sw.get_ban(left_mem.id)\n                if sw_ban:\n                    return\n\n            # Dont say goodbyes to gbanned users\n            if is_user_gbanned(left_mem.id):\n                return\n\n            # Ignore bot being kicked\n            if left_mem.id == bot.id:\n                return\n\n            # Give the owner a special goodbye\n            if left_mem.id == OWNER_ID:\n                update.effective_message.reply_text(\n                    \"Oi! Genos! He left..\", reply_to_message_id=reply\n                )\n                return\n\n            # Give the devs a special goodbye\n            elif left_mem.id in DEV_USERS:\n                update.effective_message.reply_text(\n                    \"See you later at the Hero's Association!\",\n                    reply_to_message_id=reply,\n                )\n                return\n\n            # if media goodbye, use appropriate function for it\n            if goodbye_type != sql.Types.TEXT and goodbye_type != sql.Types.BUTTON_TEXT:\n                ENUM_FUNC_MAP[goodbye_type](chat.id, cust_goodbye)\n                return\n\n            first_name = (\n                left_mem.first_name or \"PersonWithNoName\"\n            )  # edge case of empty name - occurs for some bugs.\n            if cust_goodbye:\n                if cust_goodbye == sql.DEFAULT_GOODBYE:\n                    cust_goodbye = random.choice(sql.DEFAULT_GOODBYE_MESSAGES).format(\n                        first=escape_markdown(first_name)\n                    )\n                if left_mem.last_name:\n                    fullname = escape_markdown(f\"{first_name} {left_mem.last_name}\")\n                else:\n                    fullname = escape_markdown(first_name)\n                count = chat.get_members_count()\n                mention = mention_markdown(left_mem.id, first_name)\n                if left_mem.username:\n                    username = \"@\" + escape_markdown(left_mem.username)\n                else:\n                    username = mention\n\n                valid_format = escape_invalid_curly_brackets(\n                    cust_goodbye, VALID_WELCOME_FORMATTERS\n                )\n                res = valid_format.format(\n                    first=escape_markdown(first_name),\n                    last=escape_markdown(left_mem.last_name or first_name),\n                    fullname=escape_markdown(fullname),\n                    username=username,\n                    mention=mention,\n                    count=count,\n                    chatname=escape_markdown(chat.title),\n                    id=left_mem.id,\n                )\n                buttons = sql.get_gdbye_buttons(chat.id)\n                keyb = build_keyboard(buttons)\n\n            else:\n                res = random.choice(sql.DEFAULT_GOODBYE_MESSAGES).format(\n                    first=first_name\n                )\n                keyb = []\n\n            keyboard = InlineKeyboardMarkup(keyb)\n\n            send(\n                update,\n                res,\n                keyboard,\n                random.choice(sql.DEFAULT_GOODBYE_MESSAGES).format(first=first_name),\n            )\n\n\n@run_async\n@user_admin\ndef welcome(update: Update, context: CallbackContext):\n    args = context.args\n    chat = update.effective_chat\n    # if no args, show current replies.\n    if not args or args[0].lower() == \"noformat\":\n        noformat = True\n        pref, welcome_m, cust_content, welcome_type = sql.get_welc_pref(chat.id)\n        update.effective_message.reply_text(\n            f\"This chat has it's welcome setting set to: `{pref}`.\\n\"\n            f\"*The welcome message (not filling the {{}}) is:*\",\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n        if welcome_type == sql.Types.BUTTON_TEXT or welcome_type == sql.Types.TEXT:\n            buttons = sql.get_welc_buttons(chat.id)\n            if noformat:\n                welcome_m += revert_buttons(buttons)\n                update.effective_message.reply_text(welcome_m)\n\n            else:\n                keyb = build_keyboard(buttons)\n                keyboard = InlineKeyboardMarkup(keyb)\n\n                send(update, welcome_m, keyboard, sql.DEFAULT_WELCOME)\n        else:\n            buttons = sql.get_welc_buttons(chat.id)\n            if noformat:\n                welcome_m += revert_buttons(buttons)\n                ENUM_FUNC_MAP[welcome_type](chat.id, cust_content, caption=welcome_m)\n\n            else:\n                keyb = build_keyboard(buttons)\n                keyboard = InlineKeyboardMarkup(keyb)\n                ENUM_FUNC_MAP[welcome_type](\n                    chat.id,\n                    cust_content,\n                    caption=welcome_m,\n                    reply_markup=keyboard,\n                    parse_mode=ParseMode.MARKDOWN,\n                    disable_web_page_preview=True,\n                )\n\n    elif len(args) >= 1:\n        if args[0].lower() in (\"on\", \"yes\"):\n            sql.set_welc_preference(str(chat.id), True)\n            update.effective_message.reply_text(\n                \"Okay! I'll greet members when they join.\"\n            )\n\n        elif args[0].lower() in (\"off\", \"no\"):\n            sql.set_welc_preference(str(chat.id), False)\n            update.effective_message.reply_text(\n                \"I'll go loaf around and not welcome anyone then.\"\n            )\n\n        else:\n            update.effective_message.reply_text(\n                \"I understand 'on/yes' or 'off/no' only!\"\n            )\n\n\n@run_async\n@user_admin\ndef goodbye(update: Update, context: CallbackContext):\n    args = context.args\n    chat = update.effective_chat\n\n    if not args or args[0] == \"noformat\":\n        noformat = True\n        pref, goodbye_m, goodbye_type = sql.get_gdbye_pref(chat.id)\n        update.effective_message.reply_text(\n            f\"This chat has it's goodbye setting set to: `{pref}`.\\n\"\n            f\"*The goodbye  message (not filling the {{}}) is:*\",\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n        if goodbye_type == sql.Types.BUTTON_TEXT:\n            buttons = sql.get_gdbye_buttons(chat.id)\n            if noformat:\n                goodbye_m += revert_buttons(buttons)\n                update.effective_message.reply_text(goodbye_m)\n\n            else:\n                keyb = build_keyboard(buttons)\n                keyboard = InlineKeyboardMarkup(keyb)\n\n                send(update, goodbye_m, keyboard, sql.DEFAULT_GOODBYE)\n\n        else:\n            if noformat:\n                ENUM_FUNC_MAP[goodbye_type](chat.id, goodbye_m)\n\n            else:\n                ENUM_FUNC_MAP[goodbye_type](\n                    chat.id, goodbye_m, parse_mode=ParseMode.MARKDOWN\n                )\n\n    elif len(args) >= 1:\n        if args[0].lower() in (\"on\", \"yes\"):\n            sql.set_gdbye_preference(str(chat.id), True)\n            update.effective_message.reply_text(\"Ok!\")\n\n        elif args[0].lower() in (\"off\", \"no\"):\n            sql.set_gdbye_preference(str(chat.id), False)\n            update.effective_message.reply_text(\"Ok!\")\n\n        else:\n            # idek what you're writing, say yes or no\n            update.effective_message.reply_text(\n                \"I understand 'on/yes' or 'off/no' only!\"\n            )\n\n\n@run_async\n@user_admin\n@loggable\ndef set_welcome(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    text, data_type, content, buttons = get_welcome_type(msg)\n\n    if data_type is None:\n        msg.reply_text(\"You didn't specify what to reply with!\")\n        return \"\"\n\n    sql.set_custom_welcome(chat.id, content, text, data_type, buttons)\n    msg.reply_text(\"Successfully set custom welcome message!\")\n\n    return (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#SET_WELCOME\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"Set the welcome message.\"\n    )\n\n\n@run_async\n@user_admin\n@loggable\ndef reset_welcome(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n\n    sql.set_custom_welcome(chat.id, None, sql.DEFAULT_WELCOME, sql.Types.TEXT)\n    update.effective_message.reply_text(\n        \"Successfully reset welcome message to default!\"\n    )\n\n    return (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#RESET_WELCOME\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"Reset the welcome message to default.\"\n    )\n\n\n@run_async\n@user_admin\n@loggable\ndef set_goodbye(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n    text, data_type, content, buttons = get_welcome_type(msg)\n\n    if data_type is None:\n        msg.reply_text(\"You didn't specify what to reply with!\")\n        return \"\"\n\n    sql.set_custom_gdbye(chat.id, content or text, data_type, buttons)\n    msg.reply_text(\"Successfully set custom goodbye message!\")\n    return (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#SET_GOODBYE\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"Set the goodbye message.\"\n    )\n\n\n@run_async\n@user_admin\n@loggable\ndef reset_goodbye(update: Update, context: CallbackContext) -> str:\n    chat = update.effective_chat\n    user = update.effective_user\n\n    sql.set_custom_gdbye(chat.id, sql.DEFAULT_GOODBYE, sql.Types.TEXT)\n    update.effective_message.reply_text(\n        \"Successfully reset goodbye message to default!\"\n    )\n\n    return (\n        f\"<b>{html.escape(chat.title)}:</b>\\n\"\n        f\"#RESET_GOODBYE\\n\"\n        f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n        f\"Reset the goodbye message.\"\n    )\n\n\n@run_async\n@user_admin\n@loggable\ndef welcomemute(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if len(args) >= 1:\n        if args[0].lower() in (\"off\", \"no\"):\n            sql.set_welcome_mutes(chat.id, False)\n            msg.reply_text(\"I will no longer mute people on joining!\")\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"#WELCOME_MUTE\\n\"\n                f\"<b>‚Ä¢ Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"Has toggled welcome mute to <b>OFF</b>.\"\n            )\n        elif args[0].lower() in [\"soft\"]:\n            sql.set_welcome_mutes(chat.id, \"soft\")\n            msg.reply_text(\n                \"I will restrict users' permission to send media for 24 hours.\"\n            )\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"#WELCOME_MUTE\\n\"\n                f\"<b>‚Ä¢ Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"Has toggled welcome mute to <b>SOFT</b>.\"\n            )\n        elif args[0].lower() in [\"strong\"]:\n            sql.set_welcome_mutes(chat.id, \"strong\")\n            msg.reply_text(\n                \"I will now mute people when they join until they prove they're not a bot.\\nThey will have 120seconds before they get kicked.\"\n            )\n            return (\n                f\"<b>{html.escape(chat.title)}:</b>\\n\"\n                f\"#WELCOME_MUTE\\n\"\n                f\"<b>‚Ä¢ Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n                f\"Has toggled welcome mute to <b>STRONG</b>.\"\n            )\n        else:\n            msg.reply_text(\n                \"Please enter <code>off</code>/<code>no</code>/<code>soft</code>/<code>strong</code>!\",\n                parse_mode=ParseMode.HTML,\n            )\n            return \"\"\n    else:\n        curr_setting = sql.welcome_mutes(chat.id)\n        reply = (\n            f\"\\n Give me a setting!\\nChoose one out of: <code>off</code>/<code>no</code> or <code>soft</code> or <code>strong</code> only! \\n\"\n            f\"Current setting: <code>{curr_setting}</code>\"\n        )\n        msg.reply_text(reply, parse_mode=ParseMode.HTML)\n        return \"\"\n\n\n@run_async\n@user_admin\n@loggable\ndef clean_welcome(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if not args:\n        clean_pref = sql.get_clean_pref(chat.id)\n        if clean_pref:\n            update.effective_message.reply_text(\n                \"I should be deleting welcome messages up to two days old.\"\n            )\n        else:\n            update.effective_message.reply_text(\n                \"I'm currently not deleting old welcome messages!\"\n            )\n        return \"\"\n\n    if args[0].lower() in (\"on\", \"yes\"):\n        sql.set_clean_welcome(str(chat.id), True)\n        update.effective_message.reply_text(\"I'll try to delete old welcome messages!\")\n        return (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"#CLEAN_WELCOME\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n            f\"Has toggled clean welcomes to <code>ON</code>.\"\n        )\n    elif args[0].lower() in (\"off\", \"no\"):\n        sql.set_clean_welcome(str(chat.id), False)\n        update.effective_message.reply_text(\"I won't delete old welcome messages.\")\n        return (\n            f\"<b>{html.escape(chat.title)}:</b>\\n\"\n            f\"#CLEAN_WELCOME\\n\"\n            f\"<b>Admin:</b> {mention_html(user.id, user.first_name)}\\n\"\n            f\"Has toggled clean welcomes to <code>OFF</code>.\"\n        )\n    else:\n        update.effective_message.reply_text(\"I understand 'on/yes' or 'off/no' only!\")\n        return \"\"\n\n\n@run_async\n@user_admin\ndef cleanservice(update: Update, context: CallbackContext) -> str:\n    args = context.args\n    chat = update.effective_chat  # type: Optional[Chat]\n    if chat.type != chat.PRIVATE:\n        if len(args) >= 1:\n            var = args[0]\n            if var in (\"no\", \"off\"):\n                sql.set_clean_service(chat.id, False)\n                update.effective_message.reply_text(\"Welcome clean service is : off\")\n            elif var in (\"yes\", \"on\"):\n                sql.set_clean_service(chat.id, True)\n                update.effective_message.reply_text(\"Welcome clean service is : on\")\n            else:\n                update.effective_message.reply_text(\n                    \"Invalid option\", parse_mode=ParseMode.HTML\n                )\n        else:\n            update.effective_message.reply_text(\n                \"Usage is <code>on</code>/<code>yes</code> or <code>off</code>/<code>no</code>\",\n                parse_mode=ParseMode.HTML,\n            )\n    else:\n        curr = sql.clean_service(chat.id)\n        if curr:\n            update.effective_message.reply_text(\n                \"Welcome clean service is : <code>on</code>\", parse_mode=ParseMode.HTML\n            )\n        else:\n            update.effective_message.reply_text(\n                \"Welcome clean service is : <code>off</code>\", parse_mode=ParseMode.HTML\n            )\n\n\n@run_async\ndef user_button(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    user = update.effective_user\n    query = update.callback_query\n    bot = context.bot\n    match = re.match(r\"user_join_\\((.+?)\\)\", query.data)\n    message = update.effective_message\n    join_user = int(match.group(1))\n\n    if join_user == user.id:\n        sql.set_human_checks(user.id, chat.id)\n        member_dict = VERIFIED_USER_WAITLIST.pop(user.id)\n        member_dict[\"status\"] = True\n        VERIFIED_USER_WAITLIST.update({user.id: member_dict})\n        query.answer(text=\"Yeet! You're a human, unmuted!\")\n        bot.restrict_chat_member(\n            chat.id,\n            user.id,\n            permissions=ChatPermissions(\n                can_send_messages=True,\n                can_invite_users=True,\n                can_pin_messages=True,\n                can_send_polls=True,\n                can_change_info=True,\n                can_send_media_messages=True,\n                can_send_other_messages=True,\n                can_add_web_page_previews=True,\n            ),\n        )\n        try:\n            bot.deleteMessage(chat.id, message.message_id)\n        except:\n            pass\n        if member_dict[\"should_welc\"]:\n            if member_dict[\"media_wel\"]:\n                sent = ENUM_FUNC_MAP[member_dict[\"welc_type\"]](\n                    member_dict[\"chat_id\"],\n                    member_dict[\"cust_content\"],\n                    caption=member_dict[\"res\"],\n                    reply_markup=member_dict[\"keyboard\"],\n                    parse_mode=\"markdown\",\n                )\n            else:\n                sent = send(\n                    member_dict[\"update\"],\n                    member_dict[\"res\"],\n                    member_dict[\"keyboard\"],\n                    member_dict[\"backup_message\"],\n                )\n\n            prev_welc = sql.get_clean_pref(chat.id)\n            if prev_welc:\n                try:\n                    bot.delete_message(chat.id, prev_welc)\n                except BadRequest:\n                    pass\n\n                if sent:\n                    sql.set_clean_welcome(chat.id, sent.message_id)\n\n    else:\n        query.answer(text=\"You're not allowed to do this!\")\n\n\nWELC_HELP_TXT = (\n    \"Your group's welcome/goodbye messages can be personalised in multiple ways. If you want the messages\"\n    \" to be individually generated, like the default welcome message is, you can use *these* variables:\\n\"\n    \" ‚Ä¢ `{first}`*:* this represents the user's *first* name\\n\"\n    \" ‚Ä¢ `{last}`*:* this represents the user's *last* name. Defaults to *first name* if user has no \"\n    \"last name.\\n\"\n    \" ‚Ä¢ `{fullname}`*:* this represents the user's *full* name. Defaults to *first name* if user has no \"\n    \"last name.\\n\"\n    \" ‚Ä¢ `{username}`*:* this represents the user's *username*. Defaults to a *mention* of the user's \"\n    \"first name if has no username.\\n\"\n    \" ‚Ä¢ `{mention}`*:* this simply *mentions* a user - tagging them with their first name.\\n\"\n    \" ‚Ä¢ `{id}`*:* this represents the user's *id*\\n\"\n    \" ‚Ä¢ `{count}`*:* this represents the user's *member number*.\\n\"\n    \" ‚Ä¢ `{chatname}`*:* this represents the *current chat name*.\\n\"\n    \"\\nEach variable MUST be surrounded by `{}` to be replaced.\\n\"\n    \"Welcome messages also support markdown, so you can make any elements bold/italic/code/links. \"\n    \"Buttons are also supported, so you can make your welcomes look awesome with some nice intro \"\n    \"buttons.\\n\"\n    f\"To create a button linking to your rules, use this: `[Rules](buttonurl://t.me/{dispatcher.bot.username}?start=group_id)`. \"\n    \"Simply replace `group_id` with your group's id, which can be obtained via /id, and you're good to \"\n    \"go. Note that group ids are usually preceded by a `-` sign; this is required, so please don't \"\n    \"remove it.\\n\"\n    \"You can even set images/gifs/videos/voice messages as the welcome message by \"\n    \"replying to the desired media, and calling `/setwelcome`.\"\n)\n\nWELC_MUTE_HELP_TXT = (\n    \"You can get the bot to mute new people who join your group and hence prevent spambots from flooding your group. \"\n    \"The following options are possible:\\n\"\n    \"‚Ä¢ `/welcomemute soft`*:* restricts new members from sending media for 24 hours.\\n\"\n    \"‚Ä¢ `/welcomemute strong`*:* mutes new members till they tap on a button thereby verifying they're human.\\n\"\n    \"‚Ä¢ `/welcomemute off`*:* turns off welcomemute.\\n\"\n    \"*Note:* Strong mode kicks a user from the chat if they dont verify in 120seconds. They can always rejoin though\"\n)\n\n\n@run_async\n@user_admin\ndef welcome_help(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(WELC_HELP_TXT, parse_mode=ParseMode.MARKDOWN)\n\n\n@run_async\n@user_admin\ndef welcome_mute_help(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(\n        WELC_MUTE_HELP_TXT, parse_mode=ParseMode.MARKDOWN\n    )\n\n\n# TODO: get welcome data from group butler snap\n# def __import_data__(chat_id, data):\n#     welcome = data.get('info', {}).get('rules')\n#     welcome = welcome.replace('$username', '{username}')\n#     welcome = welcome.replace('$name', '{fullname}')\n#     welcome = welcome.replace('$id', '{id}')\n#     welcome = welcome.replace('$title', '{chatname}')\n#     welcome = welcome.replace('$surname', '{lastname}')\n#     welcome = welcome.replace('$rules', '{rules}')\n#     sql.set_custom_welcome(chat_id, welcome, sql.Types.TEXT)\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    welcome_pref = sql.get_welc_pref(chat_id)[0]\n    goodbye_pref = sql.get_gdbye_pref(chat_id)[0]\n    return (\n        \"This chat has it's welcome preference set to `{}`.\\n\"\n        \"It's goodbye preference is `{}`.\".format(welcome_pref, goodbye_pref)\n    )\n\n\n__help__ = \"\"\"\n*Admins only:*\n ‚ùç /welcome <on/off>*:* enable/disable welcome messages.\n ‚ùç /welcome*:* shows current welcome settings.\n ‚ùç /welcome noformat*:* shows current welcome settings, without the formatting - useful to recycle your welcome messages!\n ‚ùç /goodbye*:* same usage and args as `/welcome`.\n ‚ùç /setwelcome <sometext>*:* set a custom welcome message. If used replying to media, uses that media.\n ‚ùç /setgoodbye <sometext>*:* set a custom goodbye message. If used replying to media, uses that media.\n ‚ùç /resetwelcome*:* reset to the default welcome message.\n ‚ùç /resetgoodbye*:* reset to the default goodbye message.\n ‚ùç /cleanwelcome <on/off>*:* On new member, try to delete the previous welcome message to avoid spamming the chat.\n ‚ùç /welcomemutehelp*:* gives information about welcome mutes.\n ‚ùç /cleanservice <on/off*:* deletes telegrams welcome/left service messages. \n *Example:*\nuser joined chat, user left chat.\n\n*Welcome markdown:* \n ‚ùç /welcomehelp*:* view more formatting information for custom welcome/goodbye messages.\n\"\"\"\n\nNEW_MEM_HANDLER = MessageHandler(Filters.status_update.new_chat_members, new_member)\nLEFT_MEM_HANDLER = MessageHandler(Filters.status_update.left_chat_member, left_member)\nWELC_PREF_HANDLER = CommandHandler(\"welcome\", welcome, filters=Filters.group)\nGOODBYE_PREF_HANDLER = CommandHandler(\"goodbye\", goodbye, filters=Filters.group)\nSET_WELCOME = CommandHandler(\"setwelcome\", set_welcome, filters=Filters.group)\nSET_GOODBYE = CommandHandler(\"setgoodbye\", set_goodbye, filters=Filters.group)\nRESET_WELCOME = CommandHandler(\"resetwelcome\", reset_welcome, filters=Filters.group)\nRESET_GOODBYE = CommandHandler(\"resetgoodbye\", reset_goodbye, filters=Filters.group)\nWELCOMEMUTE_HANDLER = CommandHandler(\"welcomemute\", welcomemute, filters=Filters.group)\nCLEAN_SERVICE_HANDLER = CommandHandler(\n    \"cleanservice\", cleanservice, filters=Filters.group\n)\nCLEAN_WELCOME = CommandHandler(\"cleanwelcome\", clean_welcome, filters=Filters.group)\nWELCOME_HELP = CommandHandler(\"welcomehelp\", welcome_help)\nWELCOME_MUTE_HELP = CommandHandler(\"welcomemutehelp\", welcome_mute_help)\nBUTTON_VERIFY_HANDLER = CallbackQueryHandler(user_button, pattern=r\"user_join_\")\n\ndispatcher.add_handler(NEW_MEM_HANDLER)\ndispatcher.add_handler(LEFT_MEM_HANDLER)\ndispatcher.add_handler(WELC_PREF_HANDLER)\ndispatcher.add_handler(GOODBYE_PREF_HANDLER)\ndispatcher.add_handler(SET_WELCOME)\ndispatcher.add_handler(SET_GOODBYE)\ndispatcher.add_handler(RESET_WELCOME)\ndispatcher.add_handler(RESET_GOODBYE)\ndispatcher.add_handler(CLEAN_WELCOME)\ndispatcher.add_handler(WELCOME_HELP)\ndispatcher.add_handler(WELCOMEMUTE_HANDLER)\ndispatcher.add_handler(CLEAN_SERVICE_HANDLER)\ndispatcher.add_handler(BUTTON_VERIFY_HANDLER)\ndispatcher.add_handler(WELCOME_MUTE_HELP)\n\n__mod_name__ = \"Greetings\"\n__command_list__ = []\n__handlers__ = [\n    NEW_MEM_HANDLER,\n    LEFT_MEM_HANDLER,\n    WELC_PREF_HANDLER,\n    GOODBYE_PREF_HANDLER,\n    SET_WELCOME,\n    SET_GOODBYE,\n    RESET_WELCOME,\n    RESET_GOODBYE,\n    CLEAN_WELCOME,\n    WELCOME_HELP,\n    WELCOMEMUTE_HANDLER,\n    CLEAN_SERVICE_HANDLER,\n    BUTTON_VERIFY_HANDLER,\n    WELCOME_MUTE_HELP,\n]\n","size_bytes":43156},"sitaBot/conf.py":{"content":"from envparse import env\nfrom sitaBot import LOGGER\n\nDEFAULTS = {\n    \"LOAD_MODULES\": True,\n}\n\ndef get_str_key(name, required=False):\n    if name in DEFAULTS:\n        default = DEFAULTS[name]\n    else:\n        default = None\n    if not (data := env.str(name, default=default)) and not required:\n        LOGGER.warn(\"No str key: \" + name)\n        return None\n    elif not data:\n        LOGGER.critical(\"No str key: \" + name)\n        sys.exit(2)\n    else:\n        return data\n\ndef get_int_key(name, required=False):\n    if name in DEFAULTS:\n        default = DEFAULTS[name]\n    else:\n        default = None\n    if not (data := env.int(name, default=default)) and not required:\n        LOGGER.warn(\"No int key: \" + name)\n        return None\n    elif not data:\n        LOGGER.critical(\"No int key: \" + name)\n        sys.exit(2)\n    else:\n        return data","size_bytes":853},"sitaBot/modules/__country.py":{"content":"from telethon.tl.functions.photos import GetUserPhotosRequest\nfrom telethon.tl.functions.users import GetFullUserRequest\nfrom telethon.tl.types import MessageEntityMentionName\nfrom telethon.utils import get_input_location\nimport flag\nimport html, os\nfrom countryinfo import CountryInfo\nfrom sitaBot import telethn as borg\nfrom sitaBot.events import register\n\n\n@register(pattern=\"^/country (.*)\")\nasync def msg(event):\n    if event.fwd_from:\n        return\n    input_str = event.pattern_match.group(1)\n    lol = input_str\n    country = CountryInfo(lol)\n    try:\n\t    a = country.info()\n    except:\n\t    await event.reply(\"Country Not Avaiable Currently\")\n    name = a.get(\"name\")\n    bb= a.get(\"altSpellings\")\n    hu = ''\n    for p in bb:\n    \thu += p+\",  \"\n\t\n    area = a.get(\"area\")\n    borders = \"\"\n    hell = a.get(\"borders\")\n    for fk in hell:\n\t    borders += fk+\",  \"\n\t\n    call = \"\" \n    WhAt = a.get(\"callingCodes\")\n    for what in WhAt:\n\t    call+= what+\"  \"\n\t\n    capital = a.get(\"capital\")\n    currencies = \"\"\n    fker = a.get(\"currencies\")\n    for FKer in fker:\n\t    currencies += FKer+\",  \"\n\n    HmM = a.get(\"demonym\")\n    geo = a.get(\"geoJSON\")\n    pablo = geo.get(\"features\")\n    Pablo = pablo[0]\n    PAblo = Pablo.get(\"geometry\")\n    EsCoBaR= PAblo.get(\"type\")\n    iso = \"\"\n    iSo = a.get(\"ISO\")\n    for hitler in iSo:\n      po = iSo.get(hitler)\n      iso += po+\",  \"\n    fla = iSo.get(\"alpha2\")\n    nox = fla.upper()\n    okie = flag.flag(nox)\n\n    languages = a.get(\"languages\")\n    lMAO=\"\"\n    for lmao in languages:\n\t    lMAO += lmao+\",  \"\n\n    nonive = a.get(\"nativeName\")\n    waste = a.get(\"population\")\n    reg = a.get(\"region\")\n    sub = a.get(\"subregion\")\n    tik = a.get(\"timezones\")\n    tom =\"\"\n    for jerry in tik:\n\t    tom+=jerry+\",   \"\n\n    GOT = a.get(\"tld\")\n    lanester = \"\"\n    for targaryen in GOT:\n\t    lanester+=targaryen+\",   \"\n\n    wiki = a.get(\"wiki\")\n\n    caption = f\"\"\"<b><u>Information Gathered Successfully</b></u>\n<b>\nCountry Name:- {name}\nAlternative Spellings:- {hu}\nCountry Area:- {area} square kilometers\nBorders:- {borders}\nCalling Codes:- {call}\nCountry's Capital:- {capital}\nCountry's currency:- {currencies}\nCountry's Flag:- {okie}\nDemonym:- {HmM}\nCountry Type:- {EsCoBaR}\nISO Names:- {iso}\nLanguages:- {lMAO}\nNative Name:- {nonive}\npopulation:- {waste}\nRegion:- {reg}\nSub Region:- {sub}\nTime Zones:- {tom}\nTop Level Domain:- {lanester}\nwikipedia:- {wiki}</b>\n\nGathered By Sita.</b>\n\"\"\"\n    \n    \n    await borg.send_message(\n        event.chat_id,\n        caption,\n        parse_mode=\"HTML\",\n    )\n    \n    await event.delete()\n","size_bytes":2583},"README.md":{"content":"[![Deployment](https://telegra.ph/file/e641d3dd2ccdce6a3d934.jpg)](https://heroku.com/deploy?template=https://github.com/DarkCybers/innexia.git)\n","size_bytes":145},"sitaBot/modules/cricketscore.py":{"content":"import urllib.request\n\nfrom bs4 import BeautifulSoup\nfrom telethon import events\nfrom sitaBot import telethn as tbot\nfrom telethon.tl import functions, types\nfrom telethon.tl.types import *\n\n\nasync def is_register_admin(chat, user):\n    if isinstance(chat, (types.InputPeerChannel, types.InputChannel)):\n        return isinstance(\n            (\n                await tbot(functions.channels.GetParticipantRequest(chat, user))\n            ).participant,\n            (types.ChannelParticipantAdmin, types.ChannelParticipantCreator),\n        )\n    if isinstance(chat, types.InputPeerUser):\n        return True\n\n\n@tbot.on(events.NewMessage(pattern=\"/cs$\"))\nasync def _(event):\n    if event.fwd_from:\n        return\n    if event.is_group:\n     if not (await is_register_admin(event.input_chat, event.message.sender_id)):\n       await event.reply(\"üö® Need Admin Pewer.. You can't use this command.. But you can use in my pm\")\n       return\n\n    score_page = \"http://static.cricinfo.com/rss/livescores.xml\"\n    page = urllib.request.urlopen(score_page)\n    soup = BeautifulSoup(page, \"html.parser\")\n    result = soup.find_all(\"description\")\n    Sed = \"\"\n    for match in result:\n        Sed += match.get_text() + \"\\n\\n\"\n    await event.reply(\n        f\"<b><u>Match information gathered successful</b></u>\\n\\n\\n<code>{Sed}</code>\",\n        parse_mode=\"HTML\",\n    )\n","size_bytes":1359},"sitaBot/modules/sql/welcome_sql.py":{"content":"import random\nimport threading\nfrom typing import Union\n\nfrom sitaBot.modules.helper_funcs.msg_types import Types\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import BigInteger, Boolean, Column, Integer, String, UnicodeText\n\nDEFAULT_WELCOME = \"Hey {first}, how are you?\"\nDEFAULT_GOODBYE = \"Nice knowing ya!\"\n\nDEFAULT_WELCOME_MESSAGES = [\n    \"{first} is here!\",  # Discord welcome messages copied\n    \"Ready player {first}\",\n    \"Genos, {first} is here.\",\n    \"A wild {first} appeared.\",\n    \"{first} came in like a Lion!\",\n    \"{first} has joined your party.\",\n    \"{first} just joined. Can I get a heal?\",\n    \"{first} just joined the chat - asdgfhak!\",\n    \"{first} just joined. Everyone, look busy!\",\n    \"Welcome, {first}. Stay awhile and listen.\",\n    \"Welcome, {first}. We were expecting you ( Õ°¬∞ Õú ñ Õ°¬∞)\",\n    \"Welcome, {first}. We hope you brought pizza.\",\n    \"Welcome, {first}. Leave your weapons by the door.\",\n    \"Swoooosh. {first} just landed.\",\n    \"Brace yourselves. {first} just joined the chat.\",\n    \"{first} just joined. Hide your bananas.\",\n    \"{first} just arrived. Seems OP - please nerf.\",\n    \"{first} just slid into the chat.\",\n    \"A {first} has spawned in the chat.\",\n    \"Big {first} showed up!\",\n    \"Where‚Äôs {first}? In the chat!\",\n    \"{first} hopped into the chat. Kangaroo!!\",\n    \"{first} just showed up. Hold my beer.\",\n    \"Challenger approaching! {first} has appeared!\",\n    \"It's a bird! It's a plane! Nevermind, it's just {first}.\",\n    \"It's {first}! Praise the sun! \\o/\",\n    \"Never gonna give {first} up. Never gonna let {first} down.\",\n    \"Ha! {first} has joined! You activated my trap card!\",\n    \"Hey! Listen! {first} has joined!\",\n    \"We've been expecting you {first}\",\n    \"It's dangerous to go alone, take {first}!\",\n    \"{first} has joined the chat! It's super effective!\",\n    \"Cheers, love! {first} is here!\",\n    \"{first} is here, as the prophecy foretold.\",\n    \"{first} has arrived. Party's over.\",\n    \"{first} is here to kick butt and chew bubblegum. And {first} is all out of gum.\",\n    \"Hello. Is it {first} you're looking for?\",\n    \"{first} has joined. Stay awhile and listen!\",\n    \"Roses are red, violets are blue, {first} joined this chat with you\",\n    \"Welcome {first}, Avoid Punches if you can!\",\n    \"It's a bird! It's a plane! - Nope, its {first}!\",\n    \"{first} Joined! - Ok.\",  # Discord welcome messages end.\n    \"All Hail {first}!\",\n    \"Hi, {first}. Don't lurk, only Villans do that.\",\n    \"{first} has joined the battle bus.\",\n    \"A new Challenger enters!\",  # Tekken\n    \"Ok!\",\n    \"{first} just fell into the chat!\",\n    \"Something just fell from the sky! - oh, its {first}.\",\n    \"{first} Just teleported into the chat!\",\n    \"Hi, {first}, show me your Hunter License!\",  # Hunter Hunter\n    \"I'm looking for Garo, oh wait nvm it's {first}.\",  # One Punch man s2\n    \"Welcome {first}, leaving is not an option!\",\n    \"Run Forest! ..I mean...{first}.\",\n    \"{first} do 100 push-ups, 100 sit-ups, 100 squats, and 10km running EVERY SINGLE DAY!!!\",  # One Punch ma\n    \"Huh?\\nDid someone with a disaster level just join?\\nOh wait, it's just {first}.\",  # One Punch ma\n    \"Hey, {first}, ever heard the King Engine?\",  # One Punch ma\n    \"Hey, {first}, empty your pockets.\",\n    \"Hey, {first}!, are you strong?\",\n    \"Call the Avengers! - {first} just joined the chat.\",\n    \"{first} joined. You must construct additional pylons.\",\n    \"Ermagherd. {first} is here.\",\n    \"Come for the Snail Racing, Stay for the Chimichangas!\",\n    \"Who needs Google? You're everything we were searching for.\",\n    \"This place must have free WiFi, cause I'm feeling a connection.\",\n    \"Speak friend and enter.\",\n    \"Welcome you are\",\n    \"Welcome {first}, your princess is in another castle.\",\n    \"Hi {first}, welcome to the dark side.\",\n    \"Hola {first}, beware of people with disaster levels\",\n    \"Hey {first}, we have the droids you are looking for.\",\n    \"Hi {first}\\nThis isn't a strange place, this is my home, it's the people who are strange.\",\n    \"Oh, hey {first} what's the password?\",\n    \"Hey {first}, I know what we're gonna do today\",\n    \"{first} just joined, be at alert they could be a spy.\",\n    \"{first} joined the group, read by Mark Zuckerberg, CIA and 35 others.\",\n    \"Welcome {first}, watch out for falling monkeys.\",\n    \"Everyone stop what you‚Äôre doing, We are now in the presence of {first}.\",\n    \"Hey {first}, do you wanna know how I got these scars?\",\n    \"Welcome {first}, drop your weapons and proceed to the spy scanner.\",\n    \"Stay safe {first}, Keep 3 meters social distances between your messages.\",  # Corona memes lmao\n    \"Hey {first}, Do you know I once One-punched a meteorite?\",\n    \"You‚Äôre here now {first}, Resistance is futile\",\n    \"{first} just arrived, the force is strong with this one.\",\n    \"{first} just joined on president‚Äôs orders.\",\n    \"Hi {first}, is the glass half full or half empty?\",\n    \"Yipee Kayaye {first} arrived.\",\n    \"Welcome {first}, if you‚Äôre a secret agent press 1, otherwise start a conversation\",\n    \"{first}, I have a feeling we‚Äôre not in Kansas anymore.\",\n    \"They may take our lives, but they‚Äôll never take our {first}.\",\n    \"Coast is clear! You can come out guys, it‚Äôs just {first}.\",\n    \"Welcome {first}, pay no attention to that guy lurking.\",\n    \"Welcome {first}, may the force be with you.\",\n    \"May the {first} be with you.\",\n    \"{first} just joined. Hey, where's Perry?\",\n    \"{first} just joined. Oh, there you are, Perry.\",\n    \"Ladies and gentlemen, I give you ...  {first}.\",\n    \"Behold my new evil scheme, the {first}-Inator.\",\n    \"Ah, {first} the Platypus, you're just in time... to be trapped.\",\n    \"{first} just arrived. Diable Jamble!\",  # One Piece Sanji\n    \"{first} just arrived. Aschente!\",  # No Game No Life\n    \"{first} say Aschente to swear by the pledges.\",  # No Game No Life\n    \"{first} just joined. El Psy congroo!\",  # Steins Gate\n    \"Irasshaimase {first}!\",  # weeabo shit\n    \"Hi {first}, what is 1000-7?\",  # tokyo ghoul\n    \"Come. I don't want to destroy this place\",  # hunter x hunter\n    \"I... am... Whitebeard!...wait..wrong anime.\",  # one Piece\n    \"Hey {first}...have you ever heard these words?\",  # BNHA\n    \"Can't a guy get a little sleep around here?\",  # Kamina Falls ‚Äì Gurren Lagann\n    \"It's time someone put you in your place, {first}.\",  # Hellsing\n    \"Unit-01's reactivated..\",  # Neon Genesis: Evangelion\n    \"Prepare for trouble...And make it double\",  # Pokemon\n    \"Hey {first}, are You Challenging Me?\",  # Shaggy\n    \"Oh? You're Approaching Me?\",  # jojo\n    \"Ho‚Ä¶ mukatta kuruno ka?\",  # jojo jap ver\n    \"I can't beat the shit out of you without getting closer\",  # jojo\n    \"Ho ho! Then come as close as you'd like.\",  # jojo\n    \"Hoho! Dewa juubun chikazukanai youi\",  # jojo jap ver\n    \"Guess who survived his time in Hell, {first}.\",  # jojo\n    \"How many loaves of bread have you eaten in your lifetime?\",  # jojo\n    \"What did you say? Depending on your answer, I may have to kick your ass!\",  # jojo\n    \"Oh? You're approaching me? Instead of running away, you come right to me? Even though your grandfather, Joseph, told you the secret of The World, like an exam student scrambling to finish the problems on an exam until the last moments before the chime?\",  # jojo\n    \"Rerorerorerorerorero.\",  # jojo\n    \"{first} just warped into the group!\",\n    \"I..it's..it's just {first}.\",\n    \"Sugoi, Dekai. {first} Joined!\",\n    \"{first}, do you know gods of death love apples?\",  # Death Note owo\n    \"I'll take a potato chip.... and eat it\",  # Death Note owo\n    \"Oshiete oshiete yo sono shikumi wo!\",  # Tokyo Ghoul\n    \"Kaizoku ou ni...nvm wrong anime.\",  # op\n    \"{first} just joined! Gear.....second!\",  # Op\n    \"Omae wa mou....shindeiru\",\n    \"Hey {first}, the leaf village lotus blooms twice!\",  # Naruto stuff begins from here\n    \"{first} Joined! Omote renge!\",\n    \"{first}! I, Madara! declare you the strongest\",\n    \"{first}, this time I'll lend you my power. \",  # Kyuubi to naruto\n    \"{first}, welcome to the hidden leaf village!\",  # Naruto thingies end here\n    \"In the jungle, you must wait...until the dice read five or eight.\",  # Jumanji stuff\n    \"Dr.{first} Famed archeologist and international explorer,\\nWelcome to Jumanji!\\nJumanji's Fate is up to you now.\",\n    \"{first}, this will not be an easy mission - monkeys slow the expedition.\",  # End of Jumanji stuff\n    \"Remember, remember, the Fifth of November, the Gunpowder Treason and Plot. I know of no reason why the Gunpowder Treason should ever be forgot.\", #V for Vendetta\n    \"The only verdict is vengeance; a vendetta, held as a votive not in vain, for the value and veracity of such shall one day vindicate the vigilant and the virtuous.\", #V for Vendetta\n    \"Behind {first} there is more than just flesh. Beneath this user there is an idea... and ideas are bulletproof.\", #V for Vendetta\n    \"Love your rage, not your cage.\", #V for Vendetta\n    \"Get your stinking paws off me, you damned dirty ape!\", #Planet of the apes\n    \"Elementary, my dear {first}.\",\n    \"I'm back - {first}.\",\n    \"Bond. {first} Bond.\",\n    \"Come with me if you want to live\",\n]\nDEFAULT_GOODBYE_MESSAGES = [\n    \"{first} will be missed.\",\n    \"{first} just went offline.\",\n    \"{first} has left the lobby.\",\n    \"{first} has left the clan.\",\n    \"{first} has left the game.\",\n    \"{first} has fled the area.\",\n    \"{first} is out of the running.\",\n    \"Nice knowing ya, {first}!\",\n    \"It was a fun time {first}.\",\n    \"We hope to see you again soon, {first}.\",\n    \"I donut want to say goodbye, {first}.\",\n    \"Goodbye {first}! Guess who's gonna miss you :')\",\n    \"Goodbye {first}! It's gonna be lonely without ya.\",\n    \"Please don't leave me alone in this place, {first}!\",\n    \"Good luck finding better shit-posters than us, {first}!\",\n    \"You know we're gonna miss you {first}. Right? Right? Right?\",\n    \"Congratulations, {first}! You're officially free of this mess.\",\n    \"{first}. You were an opponent worth fighting.\",\n    \"You're leaving, {first}? Yare Yare Daze.\",\n    \"Bring him the photo\",\n    \"Go outside!\",\n    \"Ask again later\",\n    \"Think for yourself\",\n    \"Question authority\",\n    \"You are worshiping a sun god\",\n    \"Don't leave the house today\",\n    \"Give up!\",\n    \"Marry and reproduce\",\n    \"Stay asleep\",\n    \"Wake up\",\n    \"Look to la luna\",\n    \"Steven lives\",\n    \"Meet strangers without prejudice\",\n    \"A hanged man will bring you no luck today\",\n    \"What do you want to do today?\",\n    \"You are dark inside\",\n    \"Have you seen the exit?\",\n    \"Get a baby pet it will cheer you up.\",\n    \"Your princess is in another castle.\",\n    \"You are playing it wrong give me the controller\",\n    \"Trust good people\",\n    \"Live to die.\",\n    \"When life gives you lemons reroll!\",\n    \"Well, that was worthless\",\n    \"I fell asleep!\",\n    \"May your troubles be many\",\n    \"Your old life lies in ruin\",\n    \"Always look on the bright side\",\n    \"It is dangerous to go alone\",\n    \"You will never be forgiven\",\n    \"You have nobody to blame but yourself\",\n    \"Only a sinner\",\n    \"Use bombs wisely\",\n    \"Nobody knows the troubles you have seen\",\n    \"You look fat you should exercise more\",\n    \"Follow the zebra\",\n    \"Why so blue?\",\n    \"The devil in disguise\",\n    \"Go outside\",\n    \"Always your head in the clouds\",\n]\n# Line 111 to 152 are references from https://bindingofisaac.fandom.com/wiki/Fortune_Telling_Machine\n\n\nclass Welcome(BASE):\n    __tablename__ = \"welcome_pref\"\n    chat_id = Column(String(14), primary_key=True)\n    should_welcome = Column(Boolean, default=True)\n    should_goodbye = Column(Boolean, default=True)\n    custom_content = Column(UnicodeText, default=None)\n\n    custom_welcome = Column(\n        UnicodeText, default=random.choice(DEFAULT_WELCOME_MESSAGES)\n    )\n    welcome_type = Column(Integer, default=Types.TEXT.value)\n\n    custom_leave = Column(UnicodeText, default=random.choice(DEFAULT_GOODBYE_MESSAGES))\n    leave_type = Column(Integer, default=Types.TEXT.value)\n\n    clean_welcome = Column(BigInteger)\n\n    def __init__(self, chat_id, should_welcome=True, should_goodbye=True):\n        self.chat_id = chat_id\n        self.should_welcome = should_welcome\n        self.should_goodbye = should_goodbye\n\n    def __repr__(self):\n        return \"<Chat {} should Welcome new users: {}>\".format(\n            self.chat_id, self.should_welcome\n        )\n\n\nclass WelcomeButtons(BASE):\n    __tablename__ = \"welcome_urls\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(String(14), primary_key=True)\n    name = Column(UnicodeText, nullable=False)\n    url = Column(UnicodeText, nullable=False)\n    same_line = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, name, url, same_line=False):\n        self.chat_id = str(chat_id)\n        self.name = name\n        self.url = url\n        self.same_line = same_line\n\n\nclass GoodbyeButtons(BASE):\n    __tablename__ = \"leave_urls\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    chat_id = Column(String(14), primary_key=True)\n    name = Column(UnicodeText, nullable=False)\n    url = Column(UnicodeText, nullable=False)\n    same_line = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, name, url, same_line=False):\n        self.chat_id = str(chat_id)\n        self.name = name\n        self.url = url\n        self.same_line = same_line\n\n\nclass WelcomeMute(BASE):\n    __tablename__ = \"welcome_mutes\"\n    chat_id = Column(String(14), primary_key=True)\n    welcomemutes = Column(UnicodeText, default=False)\n\n    def __init__(self, chat_id, welcomemutes):\n        self.chat_id = str(chat_id)  # ensure string\n        self.welcomemutes = welcomemutes\n\n\nclass WelcomeMuteUsers(BASE):\n    __tablename__ = \"human_checks\"\n    user_id = Column(Integer, primary_key=True)\n    chat_id = Column(String(14), primary_key=True)\n    human_check = Column(Boolean)\n\n    def __init__(self, user_id, chat_id, human_check):\n        self.user_id = user_id  # ensure string\n        self.chat_id = str(chat_id)\n        self.human_check = human_check\n\n\nclass CleanServiceSetting(BASE):\n    __tablename__ = \"clean_service\"\n    chat_id = Column(String(14), primary_key=True)\n    clean_service = Column(Boolean, default=True)\n\n    def __init__(self, chat_id):\n        self.chat_id = str(chat_id)\n\n    def __repr__(self):\n        return \"<Chat used clean service ({})>\".format(self.chat_id)\n\n\nWelcome.__table__.create(checkfirst=True)\nWelcomeButtons.__table__.create(checkfirst=True)\nGoodbyeButtons.__table__.create(checkfirst=True)\nWelcomeMute.__table__.create(checkfirst=True)\nWelcomeMuteUsers.__table__.create(checkfirst=True)\nCleanServiceSetting.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\nWELC_BTN_LOCK = threading.RLock()\nLEAVE_BTN_LOCK = threading.RLock()\nWM_LOCK = threading.RLock()\nCS_LOCK = threading.RLock()\n\n\ndef welcome_mutes(chat_id):\n    try:\n        welcomemutes = SESSION.query(WelcomeMute).get(str(chat_id))\n        if welcomemutes:\n            return welcomemutes.welcomemutes\n        return False\n    finally:\n        SESSION.close()\n\n\ndef set_welcome_mutes(chat_id, welcomemutes):\n    with WM_LOCK:\n        prev = SESSION.query(WelcomeMute).get((str(chat_id)))\n        if prev:\n            SESSION.delete(prev)\n        welcome_m = WelcomeMute(str(chat_id), welcomemutes)\n        SESSION.add(welcome_m)\n        SESSION.commit()\n\n\ndef set_human_checks(user_id, chat_id):\n    with INSERTION_LOCK:\n        human_check = SESSION.query(WelcomeMuteUsers).get((user_id, str(chat_id)))\n        if not human_check:\n            human_check = WelcomeMuteUsers(user_id, str(chat_id), True)\n\n        else:\n            human_check.human_check = True\n\n        SESSION.add(human_check)\n        SESSION.commit()\n\n        return human_check\n\n\ndef get_human_checks(user_id, chat_id):\n    try:\n        human_check = SESSION.query(WelcomeMuteUsers).get((user_id, str(chat_id)))\n        if not human_check:\n            return None\n        human_check = human_check.human_check\n        return human_check\n    finally:\n        SESSION.close()\n\n\ndef get_welc_mutes_pref(chat_id):\n    welcomemutes = SESSION.query(WelcomeMute).get(str(chat_id))\n    SESSION.close()\n\n    if welcomemutes:\n        return welcomemutes.welcomemutes\n\n    return False\n\n\ndef get_welc_pref(chat_id):\n    welc = SESSION.query(Welcome).get(str(chat_id))\n    SESSION.close()\n    if welc:\n        return (\n            welc.should_welcome,\n            welc.custom_welcome,\n            welc.custom_content,\n            welc.welcome_type,\n        )\n\n    else:\n        # Welcome by default.\n        return True, DEFAULT_WELCOME, None, Types.TEXT\n\n\ndef get_gdbye_pref(chat_id):\n    welc = SESSION.query(Welcome).get(str(chat_id))\n    SESSION.close()\n    if welc:\n        return welc.should_goodbye, welc.custom_leave, welc.leave_type\n    else:\n        # Welcome by default.\n        return True, DEFAULT_GOODBYE, Types.TEXT\n\n\ndef set_clean_welcome(chat_id, clean_welcome):\n    with INSERTION_LOCK:\n        curr = SESSION.query(Welcome).get(str(chat_id))\n        if not curr:\n            curr = Welcome(str(chat_id))\n\n        curr.clean_welcome = int(clean_welcome)\n\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef get_clean_pref(chat_id):\n    welc = SESSION.query(Welcome).get(str(chat_id))\n    SESSION.close()\n\n    if welc:\n        return welc.clean_welcome\n\n    return False\n\n\ndef set_welc_preference(chat_id, should_welcome):\n    with INSERTION_LOCK:\n        curr = SESSION.query(Welcome).get(str(chat_id))\n        if not curr:\n            curr = Welcome(str(chat_id), should_welcome=should_welcome)\n        else:\n            curr.should_welcome = should_welcome\n\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef set_gdbye_preference(chat_id, should_goodbye):\n    with INSERTION_LOCK:\n        curr = SESSION.query(Welcome).get(str(chat_id))\n        if not curr:\n            curr = Welcome(str(chat_id), should_goodbye=should_goodbye)\n        else:\n            curr.should_goodbye = should_goodbye\n\n        SESSION.add(curr)\n        SESSION.commit()\n\n\ndef set_custom_welcome(\n    chat_id, custom_content, custom_welcome, welcome_type, buttons=None\n):\n    if buttons is None:\n        buttons = []\n\n    with INSERTION_LOCK:\n        welcome_settings = SESSION.query(Welcome).get(str(chat_id))\n        if not welcome_settings:\n            welcome_settings = Welcome(str(chat_id), True)\n\n        if custom_welcome or custom_content:\n            welcome_settings.custom_content = custom_content\n            welcome_settings.custom_welcome = custom_welcome\n            welcome_settings.welcome_type = welcome_type.value\n\n        else:\n            welcome_settings.custom_welcome = DEFAULT_WELCOME\n            welcome_settings.welcome_type = Types.TEXT.value\n\n        SESSION.add(welcome_settings)\n\n        with WELC_BTN_LOCK:\n            prev_buttons = (\n                SESSION.query(WelcomeButtons)\n                .filter(WelcomeButtons.chat_id == str(chat_id))\n                .all()\n            )\n            for btn in prev_buttons:\n                SESSION.delete(btn)\n\n            for b_name, url, same_line in buttons:\n                button = WelcomeButtons(chat_id, b_name, url, same_line)\n                SESSION.add(button)\n\n        SESSION.commit()\n\n\ndef get_custom_welcome(chat_id):\n    welcome_settings = SESSION.query(Welcome).get(str(chat_id))\n    ret = DEFAULT_WELCOME\n    if welcome_settings and welcome_settings.custom_welcome:\n        ret = welcome_settings.custom_welcome\n\n    SESSION.close()\n    return ret\n\n\ndef set_custom_gdbye(chat_id, custom_goodbye, goodbye_type, buttons=None):\n    if buttons is None:\n        buttons = []\n\n    with INSERTION_LOCK:\n        welcome_settings = SESSION.query(Welcome).get(str(chat_id))\n        if not welcome_settings:\n            welcome_settings = Welcome(str(chat_id), True)\n\n        if custom_goodbye:\n            welcome_settings.custom_leave = custom_goodbye\n            welcome_settings.leave_type = goodbye_type.value\n\n        else:\n            welcome_settings.custom_leave = DEFAULT_GOODBYE\n            welcome_settings.leave_type = Types.TEXT.value\n\n        SESSION.add(welcome_settings)\n\n        with LEAVE_BTN_LOCK:\n            prev_buttons = (\n                SESSION.query(GoodbyeButtons)\n                .filter(GoodbyeButtons.chat_id == str(chat_id))\n                .all()\n            )\n            for btn in prev_buttons:\n                SESSION.delete(btn)\n\n            for b_name, url, same_line in buttons:\n                button = GoodbyeButtons(chat_id, b_name, url, same_line)\n                SESSION.add(button)\n\n        SESSION.commit()\n\n\ndef get_custom_gdbye(chat_id):\n    welcome_settings = SESSION.query(Welcome).get(str(chat_id))\n    ret = DEFAULT_GOODBYE\n    if welcome_settings and welcome_settings.custom_leave:\n        ret = welcome_settings.custom_leave\n\n    SESSION.close()\n    return ret\n\n\ndef get_welc_buttons(chat_id):\n    try:\n        return (\n            SESSION.query(WelcomeButtons)\n            .filter(WelcomeButtons.chat_id == str(chat_id))\n            .order_by(WelcomeButtons.id)\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef get_gdbye_buttons(chat_id):\n    try:\n        return (\n            SESSION.query(GoodbyeButtons)\n            .filter(GoodbyeButtons.chat_id == str(chat_id))\n            .order_by(GoodbyeButtons.id)\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef clean_service(chat_id: Union[str, int]) -> bool:\n    try:\n        chat_setting = SESSION.query(CleanServiceSetting).get(str(chat_id))\n        if chat_setting:\n            return chat_setting.clean_service\n        return False\n    finally:\n        SESSION.close()\n\n\ndef set_clean_service(chat_id: Union[int, str], setting: bool):\n    with CS_LOCK:\n        chat_setting = SESSION.query(CleanServiceSetting).get(str(chat_id))\n        if not chat_setting:\n            chat_setting = CleanServiceSetting(chat_id)\n\n        chat_setting.clean_service = setting\n        SESSION.add(chat_setting)\n        SESSION.commit()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with INSERTION_LOCK:\n        chat = SESSION.query(Welcome).get(str(old_chat_id))\n        if chat:\n            chat.chat_id = str(new_chat_id)\n\n        with WELC_BTN_LOCK:\n            chat_buttons = (\n                SESSION.query(WelcomeButtons)\n                .filter(WelcomeButtons.chat_id == str(old_chat_id))\n                .all()\n            )\n            for btn in chat_buttons:\n                btn.chat_id = str(new_chat_id)\n\n        with LEAVE_BTN_LOCK:\n            chat_buttons = (\n                SESSION.query(GoodbyeButtons)\n                .filter(GoodbyeButtons.chat_id == str(old_chat_id))\n                .all()\n            )\n            for btn in chat_buttons:\n                btn.chat_id = str(new_chat_id)\n\n        SESSION.commit()\n","size_bytes":22912},"sitaBot/modules/sql/approve_sql.py":{"content":"import threading\n\nfrom sqlalchemy import Column, String, UnicodeText, Integer, BigInteger, func, distinct\n\nfrom sitaBot.modules.sql import BASE, SESSION\n\n\nclass Approvals(BASE):\n    __tablename__ = \"approval\"\n    chat_id = Column(String(14), primary_key=True)\n    user_id = Column(BigInteger, primary_key=True)\n\n    def __init__(self, chat_id, user_id):\n        self.chat_id = str(chat_id)  # ensure string\n        self.user_id = user_id\n\n    def __repr__(self):\n        return \"<Approve %s>\" % self.user_id\n\n\nApprovals.__table__.create(checkfirst=True)\n\nAPPROVE_INSERTION_LOCK = threading.RLock()\n\n\ndef approve(chat_id, user_id):\n    with APPROVE_INSERTION_LOCK:\n        approve_user = Approvals(str(chat_id), user_id)\n        SESSION.add(approve_user)\n        SESSION.commit()\n\n\ndef is_approved(chat_id, user_id):\n    try:\n        return SESSION.query(Approvals).get((str(chat_id), user_id))\n    finally:\n        SESSION.close()\n\n\ndef disapprove(chat_id, user_id):\n    with APPROVE_INSERTION_LOCK:\n        disapprove_user = SESSION.query(Approvals).get((str(chat_id), user_id))\n        if disapprove_user:\n            SESSION.delete(disapprove_user)\n            SESSION.commit()\n            return True\n        else:\n            SESSION.close()\n            return False\n\n\ndef list_approved(chat_id):\n    try:\n        return (\n            SESSION.query(Approvals)\n            .filter(Approvals.chat_id == str(chat_id))\n            .order_by(Approvals.user_id.asc())\n            .all()\n        )\n    finally:\n        SESSION.close()\n","size_bytes":1533},"sitaBot/modules/speed_test.py":{"content":"import speedtest\nfrom sitaBot import DEV_USERS, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup, ParseMode, Update\nfrom telegram.ext import CallbackContext, CallbackQueryHandler, run_async\n\n\ndef convert(speed):\n    return round(int(speed) / 1048576, 2)\n\n\n@dev_plus\n@run_async\ndef speedtestxyz(update: Update, context: CallbackContext):\n    buttons = [\n        [\n            InlineKeyboardButton(\"Image\", callback_data=\"speedtest_image\"),\n            InlineKeyboardButton(\"Text\", callback_data=\"speedtest_text\"),\n        ]\n    ]\n    update.effective_message.reply_text(\n        \"Select SpeedTest Mode\", reply_markup=InlineKeyboardMarkup(buttons)\n    )\n\n\n@run_async\ndef speedtestxyz_callback(update: Update, context: CallbackContext):\n    query = update.callback_query\n\n    if query.from_user.id in DEV_USERS:\n        msg = update.effective_message.edit_text(\"Running a speedtest....\")\n        speed = speedtest.Speedtest()\n        speed.get_best_server()\n        speed.download()\n        speed.upload()\n        replymsg = \"SpeedTest Results:\"\n\n        if query.data == \"speedtest_image\":\n            speedtest_image = speed.results.share()\n            update.effective_message.reply_photo(\n                photo=speedtest_image, caption=replymsg\n            )\n            msg.delete()\n\n        elif query.data == \"speedtest_text\":\n            result = speed.results.dict()\n            replymsg += f\"\\nDownload: `{convert(result['download'])}Mb/s`\\nUpload: `{convert(result['upload'])}Mb/s`\\nPing: `{result['ping']}`\"\n            update.effective_message.edit_text(replymsg, parse_mode=ParseMode.MARKDOWN)\n    else:\n        query.answer(\"You are required to join Heroes Association to use this command.\")\n\n\nSPEED_TEST_HANDLER = DisableAbleCommandHandler(\"speedtest\", speedtestxyz)\nSPEED_TEST_CALLBACKHANDLER = CallbackQueryHandler(\n    speedtestxyz_callback, pattern=\"speedtest_.*\"\n)\n\ndispatcher.add_handler(SPEED_TEST_HANDLER)\ndispatcher.add_handler(SPEED_TEST_CALLBACKHANDLER)\n\n__mod_name__ = \"SpeedTest\"\n__command_list__ = [\"speedtest\"]\n__handlers__ = [SPEED_TEST_HANDLER, SPEED_TEST_CALLBACKHANDLER]\n","size_bytes":2253},"sitaBot/modules/notes.py":{"content":"import re, ast\nfrom io import BytesIO\nimport random\nfrom typing import Optional\n\nimport sitaBot.modules.sql.notes_sql as sql\nfrom sitaBot import LOGGER, JOIN_LOGGER, SUPPORT_CHAT, dispatcher, DRAGONS\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.handlers import MessageHandlerChecker\nfrom sitaBot.modules.helper_funcs.chat_status import user_admin, connection_status\nfrom sitaBot.modules.helper_funcs.misc import build_keyboard, revert_buttons\nfrom sitaBot.modules.helper_funcs.msg_types import get_note_type\nfrom sitaBot.modules.helper_funcs.string_handling import (\n    escape_invalid_curly_brackets,\n)\nfrom telegram import (\n    MAX_MESSAGE_LENGTH,\n    InlineKeyboardMarkup,\n    Message,\n    ParseMode,\n    Update,\n    InlineKeyboardButton,\n)\nfrom telegram.error import BadRequest\nfrom telegram.utils.helpers import escape_markdown, mention_markdown\nfrom telegram.ext import (\n    CallbackContext,\n    CommandHandler,\n    CallbackQueryHandler,\n    Filters,\n    MessageHandler,\n)\nfrom telegram.ext.dispatcher import run_async\n\nFILE_MATCHER = re.compile(r\"^###file_id(!photo)?###:(.*?)(?:\\s|$)\")\nSTICKER_MATCHER = re.compile(r\"^###sticker(!photo)?###:\")\nBUTTON_MATCHER = re.compile(r\"^###button(!photo)?###:(.*?)(?:\\s|$)\")\nMYFILE_MATCHER = re.compile(r\"^###file(!photo)?###:\")\nMYPHOTO_MATCHER = re.compile(r\"^###photo(!photo)?###:\")\nMYAUDIO_MATCHER = re.compile(r\"^###audio(!photo)?###:\")\nMYVOICE_MATCHER = re.compile(r\"^###voice(!photo)?###:\")\nMYVIDEO_MATCHER = re.compile(r\"^###video(!photo)?###:\")\nMYVIDEONOTE_MATCHER = re.compile(r\"^###video_note(!photo)?###:\")\n\nENUM_FUNC_MAP = {\n    sql.Types.TEXT.value: dispatcher.bot.send_message,\n    sql.Types.BUTTON_TEXT.value: dispatcher.bot.send_message,\n    sql.Types.STICKER.value: dispatcher.bot.send_sticker,\n    sql.Types.DOCUMENT.value: dispatcher.bot.send_document,\n    sql.Types.PHOTO.value: dispatcher.bot.send_photo,\n    sql.Types.AUDIO.value: dispatcher.bot.send_audio,\n    sql.Types.VOICE.value: dispatcher.bot.send_voice,\n    sql.Types.VIDEO.value: dispatcher.bot.send_video,\n}\n\n\n# Do not async\ndef get(update, context, notename, show_none=True, no_format=False):\n    bot = context.bot\n    chat_id = update.effective_message.chat.id\n    note_chat_id = update.effective_chat.id\n    note = sql.get_note(note_chat_id, notename)\n    message = update.effective_message  # type: Optional[Message]\n\n    if note:\n        if MessageHandlerChecker.check_user(update.effective_user.id):\n            return\n        # If we're replying to a message, reply to that message (unless it's an error)\n        if message.reply_to_message:\n            reply_id = message.reply_to_message.message_id\n        else:\n            reply_id = message.message_id\n        if note.is_reply:\n            if JOIN_LOGGER:\n                try:\n                    bot.forward_message(\n                        chat_id=chat_id, from_chat_id=JOIN_LOGGER, message_id=note.value\n                    )\n                except BadRequest as excp:\n                    if excp.message == \"Message to forward not found\":\n                        message.reply_text(\n                            \"This message seems to have been lost - I'll remove it \"\n                            \"from your notes list.\"\n                        )\n                        sql.rm_note(note_chat_id, notename)\n                    else:\n                        raise\n            else:\n                try:\n                    bot.forward_message(\n                        chat_id=chat_id, from_chat_id=chat_id, message_id=note.value\n                    )\n                except BadRequest as excp:\n                    if excp.message == \"Message to forward not found\":\n                        message.reply_text(\n                            \"Looks like the original sender of this note has deleted \"\n                            \"their message - sorry! Get your bot admin to start using a \"\n                            \"message dump to avoid this. I'll remove this note from \"\n                            \"your saved notes.\"\n                        )\n                        sql.rm_note(note_chat_id, notename)\n                    else:\n                        raise\n        else:\n            VALID_NOTE_FORMATTERS = [\n                \"first\",\n                \"last\",\n                \"fullname\",\n                \"username\",\n                \"id\",\n                \"chatname\",\n                \"mention\",\n            ]\n            valid_format = escape_invalid_curly_brackets(\n                note.value, VALID_NOTE_FORMATTERS\n            )\n            if valid_format:\n                if not no_format:\n                    if \"%%%\" in valid_format:\n                        split = valid_format.split(\"%%%\")\n                        if all(split):\n                            text = random.choice(split)\n                        else:\n                            text = valid_format\n                    else:\n                        text = valid_format\n                else:\n                    text = valid_format\n                text = text.format(\n                    first=escape_markdown(message.from_user.first_name),\n                    last=escape_markdown(\n                        message.from_user.last_name or message.from_user.first_name\n                    ),\n                    fullname=escape_markdown(\n                        \" \".join(\n                            [message.from_user.first_name, message.from_user.last_name]\n                            if message.from_user.last_name\n                            else [message.from_user.first_name]\n                        )\n                    ),\n                    username=\"@\" + message.from_user.username\n                    if message.from_user.username\n                    else mention_markdown(\n                        message.from_user.id, message.from_user.first_name\n                    ),\n                    mention=mention_markdown(\n                        message.from_user.id, message.from_user.first_name\n                    ),\n                    chatname=escape_markdown(\n                        message.chat.title\n                        if message.chat.type != \"private\"\n                        else message.from_user.first_name\n                    ),\n                    id=message.from_user.id,\n                )\n            else:\n                text = \"\"\n\n            keyb = []\n            parseMode = ParseMode.MARKDOWN\n            buttons = sql.get_buttons(note_chat_id, notename)\n            if no_format:\n                parseMode = None\n                text += revert_buttons(buttons)\n            else:\n                keyb = build_keyboard(buttons)\n\n            keyboard = InlineKeyboardMarkup(keyb)\n\n            try:\n                if note.msgtype in (sql.Types.BUTTON_TEXT, sql.Types.TEXT):\n                    bot.send_message(\n                        chat_id,\n                        text,\n                        reply_to_message_id=reply_id,\n                        parse_mode=parseMode,\n                        disable_web_page_preview=True,\n                        reply_markup=keyboard,\n                    )\n                else:\n                    ENUM_FUNC_MAP[note.msgtype](\n                        chat_id,\n                        note.file,\n                        caption=text,\n                        reply_to_message_id=reply_id,\n                        parse_mode=parseMode,\n                        disable_web_page_preview=True,\n                        reply_markup=keyboard,\n                    )\n\n            except BadRequest as excp:\n                if excp.message == \"Entity_mention_user_invalid\":\n                    message.reply_text(\n                        \"Looks like you tried to mention someone I've never seen before. If you really \"\n                        \"want to mention them, forward one of their messages to me, and I'll be able \"\n                        \"to tag them!\"\n                    )\n                elif FILE_MATCHER.match(note.value):\n                    message.reply_text(\n                        \"This note was an incorrectly imported file from another bot - I can't use \"\n                        \"it. If you really need it, you'll have to save it again. In \"\n                        \"the meantime, I'll remove it from your notes list.\"\n                    )\n                    sql.rm_note(note_chat_id, notename)\n                else:\n                    message.reply_text(\n                        \"This note could not be sent, as it is incorrectly formatted. Ask in \"\n                        f\"@{SUPPORT_CHAT} if you can't figure out why!\"\n                    )\n                    LOGGER.exception(\n                        \"Could not parse message #%s in chat %s\",\n                        notename,\n                        str(note_chat_id),\n                    )\n                    LOGGER.warning(\"Message was: %s\", str(note.value))\n        return\n    elif show_none:\n        message.reply_text(\"This note doesn't exist\")\n\n\n@run_async\n@connection_status\ndef cmd_get(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    if len(args) >= 2 and args[1].lower() == \"noformat\":\n        get(update, context, args[0].lower(), show_none=True, no_format=True)\n    elif len(args) >= 1:\n        get(update, context, args[0].lower(), show_none=True)\n    else:\n        update.effective_message.reply_text(\"Get rekt\")\n\n\n@run_async\n@connection_status\ndef hash_get(update: Update, context: CallbackContext):\n    message = update.effective_message.text\n    fst_word = message.split()[0]\n    no_hash = fst_word[1:].lower()\n    get(update, context, no_hash, show_none=False)\n\n\n@run_async\n@connection_status\ndef slash_get(update: Update, context: CallbackContext):\n    message, chat_id = update.effective_message.text, update.effective_chat.id\n    no_slash = message[1:]\n    note_list = sql.get_all_chat_notes(chat_id)\n\n    try:\n        noteid = note_list[int(no_slash) - 1]\n        note_name = str(noteid).strip(\">\").split()[1]\n        get(update, context, note_name, show_none=False)\n    except IndexError:\n        update.effective_message.reply_text(\"Wrong Note ID üòæ\")\n\n\n@run_async\n@user_admin\n@connection_status\ndef save(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    msg = update.effective_message  # type: Optional[Message]\n\n    note_name, text, data_type, content, buttons = get_note_type(msg)\n    note_name = note_name.lower()\n    if data_type is None:\n        msg.reply_text(\"Dude, there's no note\")\n        return\n\n    sql.add_note_to_db(\n        chat_id, note_name, text, data_type, buttons=buttons, file=content\n    )\n\n    msg.reply_text(\n        f\"Yas! Added `{note_name}`.\\nGet it with /get `{note_name}`, or `#{note_name}`\",\n        parse_mode=ParseMode.MARKDOWN,\n    )\n\n    if msg.reply_to_message and msg.reply_to_message.from_user.is_bot:\n        if text:\n            msg.reply_text(\n                \"Seems like you're trying to save a message from a bot. Unfortunately, \"\n                \"bots can't forward bot messages, so I can't save the exact message. \"\n                \"\\nI'll save all the text I can, but if you want more, you'll have to \"\n                \"forward the message yourself, and then save it.\"\n            )\n        else:\n            msg.reply_text(\n                \"Bots are kinda handicapped by telegram, making it hard for bots to \"\n                \"interact with other bots, so I can't save this message \"\n                \"like I usually would - do you mind forwarding it and \"\n                \"then saving that new message? Thanks!\"\n            )\n        return\n\n\n@run_async\n@user_admin\n@connection_status\ndef clear(update: Update, context: CallbackContext):\n    args = context.args\n    chat_id = update.effective_chat.id\n    if len(args) >= 1:\n        notename = args[0].lower()\n\n        if sql.rm_note(chat_id, notename):\n            update.effective_message.reply_text(\"Successfully removed note.\")\n        else:\n            update.effective_message.reply_text(\"That's not a note in my database!\")\n\n\n@run_async\ndef clearall(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    user = update.effective_user\n    member = chat.get_member(user.id)\n    if member.status != \"creator\" and user.id not in DRAGONS:\n        update.effective_message.reply_text(\n            \"Only the chat owner can clear all notes at once.\"\n        )\n    else:\n        buttons = InlineKeyboardMarkup(\n            [\n                [\n                    InlineKeyboardButton(\n                        text=\"Delete all notes\", callback_data=\"notes_rmall\"\n                    )\n                ],\n                [InlineKeyboardButton(text=\"Cancel\", callback_data=\"notes_cancel\")],\n            ]\n        )\n        update.effective_message.reply_text(\n            f\"Are you sure you would like to clear ALL notes in {chat.title}? This action cannot be undone.\",\n            reply_markup=buttons,\n            parse_mode=ParseMode.MARKDOWN,\n        )\n\n\n@run_async\ndef clearall_btn(update: Update, context: CallbackContext):\n    query = update.callback_query\n    chat = update.effective_chat\n    message = update.effective_message\n    member = chat.get_member(query.from_user.id)\n    if query.data == \"notes_rmall\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            note_list = sql.get_all_chat_notes(chat.id)\n            try:\n                for notename in note_list:\n                    note = notename.name.lower()\n                    sql.rm_note(chat.id, note)\n                message.edit_text(\"Deleted all notes.\")\n            except BadRequest:\n                return\n\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n    elif query.data == \"notes_cancel\":\n        if member.status == \"creator\" or query.from_user.id in DRAGONS:\n            message.edit_text(\"Clearing of all notes has been cancelled.\")\n            return\n        if member.status == \"administrator\":\n            query.answer(\"Only owner of the chat can do this.\")\n        if member.status == \"member\":\n            query.answer(\"You need to be admin to do this.\")\n\n\n@run_async\n@connection_status\ndef list_notes(update: Update, context: CallbackContext):\n    chat_id = update.effective_chat.id\n    note_list = sql.get_all_chat_notes(chat_id)\n    notes = len(note_list) + 1\n    msg = \"Get note by `/notenumber` or `#notename` \\n\\n  *ID*    *Note* \\n\"\n    for note_id, note in zip(range(1, notes), note_list):\n        if note_id < 10:\n            note_name = f\"`{note_id:2}.`  `#{(note.name.lower())}`\\n\"\n        else:\n            note_name = f\"`{note_id}.`  `#{(note.name.lower())}`\\n\"\n        if len(msg) + len(note_name) > MAX_MESSAGE_LENGTH:\n            update.effective_message.reply_text(msg, parse_mode=ParseMode.MARKDOWN)\n            msg = \"\"\n        msg += note_name\n\n    if not note_list:\n        try:\n            update.effective_message.reply_text(\"No notes in this chat!\")\n        except BadRequest:\n            update.effective_message.reply_text(\"No notes in this chat!\", quote=False)\n\n    elif len(msg) != 0:\n        update.effective_message.reply_text(msg, parse_mode=ParseMode.MARKDOWN)\n\n\ndef __import_data__(chat_id, data):\n    failures = []\n    for notename, notedata in data.get(\"extra\", {}).items():\n        match = FILE_MATCHER.match(notedata)\n        matchsticker = STICKER_MATCHER.match(notedata)\n        matchbtn = BUTTON_MATCHER.match(notedata)\n        matchfile = MYFILE_MATCHER.match(notedata)\n        matchphoto = MYPHOTO_MATCHER.match(notedata)\n        matchaudio = MYAUDIO_MATCHER.match(notedata)\n        matchvoice = MYVOICE_MATCHER.match(notedata)\n        matchvideo = MYVIDEO_MATCHER.match(notedata)\n        matchvn = MYVIDEONOTE_MATCHER.match(notedata)\n\n        if match:\n            failures.append(notename)\n            notedata = notedata[match.end() :].strip()\n            if notedata:\n                sql.add_note_to_db(chat_id, notename[1:], notedata, sql.Types.TEXT)\n        elif matchsticker:\n            content = notedata[matchsticker.end() :].strip()\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.STICKER, file=content\n                )\n        elif matchbtn:\n            parse = notedata[matchbtn.end() :].strip()\n            notedata = parse.split(\"<###button###>\")[0]\n            buttons = parse.split(\"<###button###>\")[1]\n            buttons = ast.literal_eval(buttons)\n            if buttons:\n                sql.add_note_to_db(\n                    chat_id,\n                    notename[1:],\n                    notedata,\n                    sql.Types.BUTTON_TEXT,\n                    buttons=buttons,\n                )\n        elif matchfile:\n            file = notedata[matchfile.end() :].strip()\n            file = file.split(\"<###TYPESPLIT###>\")\n            notedata = file[1]\n            content = file[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.DOCUMENT, file=content\n                )\n        elif matchphoto:\n            photo = notedata[matchphoto.end() :].strip()\n            photo = photo.split(\"<###TYPESPLIT###>\")\n            notedata = photo[1]\n            content = photo[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.PHOTO, file=content\n                )\n        elif matchaudio:\n            audio = notedata[matchaudio.end() :].strip()\n            audio = audio.split(\"<###TYPESPLIT###>\")\n            notedata = audio[1]\n            content = audio[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.AUDIO, file=content\n                )\n        elif matchvoice:\n            voice = notedata[matchvoice.end() :].strip()\n            voice = voice.split(\"<###TYPESPLIT###>\")\n            notedata = voice[1]\n            content = voice[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.VOICE, file=content\n                )\n        elif matchvideo:\n            video = notedata[matchvideo.end() :].strip()\n            video = video.split(\"<###TYPESPLIT###>\")\n            notedata = video[1]\n            content = video[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.VIDEO, file=content\n                )\n        elif matchvn:\n            video_note = notedata[matchvn.end() :].strip()\n            video_note = video_note.split(\"<###TYPESPLIT###>\")\n            notedata = video_note[1]\n            content = video_note[0]\n            if content:\n                sql.add_note_to_db(\n                    chat_id, notename[1:], notedata, sql.Types.VIDEO_NOTE, file=content\n                )\n        else:\n            sql.add_note_to_db(chat_id, notename[1:], notedata, sql.Types.TEXT)\n\n    if failures:\n        with BytesIO(str.encode(\"\\n\".join(failures))) as output:\n            output.name = \"failed_imports.txt\"\n            dispatcher.bot.send_document(\n                chat_id,\n                document=output,\n                filename=\"failed_imports.txt\",\n                caption=\"These files/photos failed to import due to originating \"\n                \"from another bot. This is a telegram API restriction, and can't \"\n                \"be avoided. Sorry for the inconvenience!\",\n            )\n\n\ndef __stats__():\n    return f\"‚Ä¢ {sql.num_notes()} notes, across {sql.num_chats()} chats.\"\n\n\ndef __migrate__(old_chat_id, new_chat_id):\n    sql.migrate_chat(old_chat_id, new_chat_id)\n\n\ndef __chat_settings__(chat_id, user_id):\n    notes = sql.get_all_chat_notes(chat_id)\n    return f\"There are `{len(notes)}` notes in this chat.\"\n\n\n__help__ = \"\"\"\n ‚ùç /get <notename>*:* get the note with this notename\n ‚ùç #<notename>*:* same as /get\n ‚ùç /notes or /saved*:* list all saved notes in this chat\n ‚ùç /number *:* Will pull the note of that number in the list\nIf you would like to retrieve the contents of a note without any formatting, use `/get <notename> noformat`. This can \\\nbe useful when updating a current note\n\n*Admins only:*\n ‚ùç /save <notename> <notedata>*:* saves notedata as a note with name notename\nA button can be added to a note by using standard markdown link syntax - the link should just be prepended with a \\\n`buttonurl:` section, as such: `[somelink](buttonurl:example.com)`. Check `/markdownhelp` for more info\n ‚ùç /save <notename>*:* save the replied message as a note with name notename\n Separate diff replies by `%%%` to get random notes\n *Example:* \n `/save notename\n Reply 1\n %%%\n Reply 2\n %%%\n Reply 3`\n ‚ùç /clear <notename>*:* clear note with this name\n ‚ùç /removeallnotes*:* removes all notes from the group\n *Note:* Note names are case-insensitive, and they are automatically converted to lowercase before getting saved.\n\n\"\"\"\n\n__mod_name__ = \"Notes\"\n\nGET_HANDLER = CommandHandler(\"get\", cmd_get)\nHASH_GET_HANDLER = MessageHandler(Filters.regex(r\"^#[^\\s]+\"), hash_get)\nSLASH_GET_HANDLER = MessageHandler(Filters.regex(r\"^/\\d+$\"), slash_get)\nSAVE_HANDLER = CommandHandler(\"save\", save)\nDELETE_HANDLER = CommandHandler(\"clear\", clear)\n\nLIST_HANDLER = DisableAbleCommandHandler([\"notes\", \"saved\"], list_notes, admin_ok=True)\n\nCLEARALL = DisableAbleCommandHandler(\"removeallnotes\", clearall)\nCLEARALL_BTN = CallbackQueryHandler(clearall_btn, pattern=r\"notes_.*\")\n\ndispatcher.add_handler(GET_HANDLER)\ndispatcher.add_handler(SAVE_HANDLER)\ndispatcher.add_handler(LIST_HANDLER)\ndispatcher.add_handler(DELETE_HANDLER)\ndispatcher.add_handler(HASH_GET_HANDLER)\ndispatcher.add_handler(SLASH_GET_HANDLER)\ndispatcher.add_handler(CLEARALL)\ndispatcher.add_handler(CLEARALL_BTN)\n","size_bytes":21984},"sitaBot/modules/truth_and_dare.py":{"content":"import html\nimport random\nimport sitaBot.modules.truth_and_dare_string as truth_and_dare_string\nfrom sitaBot import dispatcher\nfrom telegram import ParseMode, Update, Bot\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom telegram.ext import CallbackContext, run_async\n\n@run_async\ndef truth(update: Update, context: CallbackContext):\n    args = context.args\n    update.effective_message.reply_text(random.choice(truth_and_dare_string.TRUTH))\n\n@run_async\ndef dare(update: Update, context: CallbackContext):\n    args = context.args\n    update.effective_message.reply_text(random.choice(truth_and_dare_string.DARE))\n\n    \nTRUTH_HANDLER = DisableAbleCommandHandler(\"truth\", truth)\nDARE_HANDLER = DisableAbleCommandHandler(\"dare\", dare)\n\n\ndispatcher.add_handler(TRUTH_HANDLER)\ndispatcher.add_handler(DARE_HANDLER)\n\n","size_bytes":826},"sitaBot/modules/helper_funcs/telethn/chatstatus.py":{"content":"from sitaBot.modules.helper_funcs.telethn import IMMUNE_USERS, telethn\nfrom sitaBot import DRAGONS\nfrom telethon.tl.types import ChannelParticipantsAdmins\n\n\nasync def user_is_ban_protected(user_id: int, message):\n    status = False\n    if message.is_private or user_id in (IMMUNE_USERS):\n        return True\n\n    async for user in telethn.iter_participants(\n        message.chat_id, filter=ChannelParticipantsAdmins\n    ):\n        if user_id == user.id:\n            status = True\n            break\n    return status\n\n\nasync def user_is_admin(user_id: int, message):\n    status = False\n    if message.is_private:\n        return True\n\n    async for user in telethn.iter_participants(\n        message.chat_id, filter=ChannelParticipantsAdmins\n    ):\n        if user_id == user.id or user_id in DRAGONS:\n            status = True\n            break\n    return status\n\n\nasync def is_user_admin(user_id: int, chat_id):\n    status = False\n    async for user in telethn.iter_participants(\n        chat_id, filter=ChannelParticipantsAdmins\n    ):\n        if user_id == user.id or user_id in DRAGONS:\n            status = True\n            break\n    return status\n\n\nasync def yone_is_admin(chat_id: int):\n    status = False\n    yone = await telethn.get_me()\n    async for user in telethn.iter_participants(\n        chat_id, filter=ChannelParticipantsAdmins\n    ):\n        if yone.id == user.id:\n            status = True\n            break\n    return status\n\n\nasync def is_user_in_chat(chat_id: int, user_id: int):\n    status = False\n    async for user in telethn.iter_participants(chat_id):\n        if user_id == user.id:\n            status = True\n            break\n    return status\n\n\nasync def can_change_info(message):\n    status = False\n    if message.chat.admin_rights:\n        status = message.chat.admin_rights.change_info\n    return status\n\n\nasync def can_ban_users(message):\n    status = False\n    if message.chat.admin_rights:\n        status = message.chat.admin_rights.ban_users\n    return status\n\n\nasync def can_pin_messages(message):\n    status = False\n    if message.chat.admin_rights:\n        status = message.chat.admin_rights.pin_messages\n    return status\n\n\nasync def can_invite_users(message):\n    status = False\n    if message.chat.admin_rights:\n        status = message.chat.admin_rights.invite_users\n    return status\n\n\nasync def can_add_admins(message):\n    status = False\n    if message.chat.admin_rights:\n        status = message.chat.admin_rights.add_admins\n    return status\n\n\nasync def can_delete_messages(message):\n\n    if message.is_private:\n        return True\n    elif message.chat.admin_rights:\n        status = message.chat.admin_rights.delete_messages\n        return status\n    else:\n        return False\n","size_bytes":2728},"sitaBot/modules/sql/warns_sql.py":{"content":"import threading\n\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import Boolean, Column, Integer, BigInteger, String, UnicodeText, distinct, func\nfrom sqlalchemy.dialects import postgresql\n\n\nclass Warns(BASE):\n    __tablename__ = \"warns\"\n\n    user_id = Column(BigInteger, primary_key=True)\n    chat_id = Column(String(14), primary_key=True)\n    num_warns = Column(Integer, default=0)\n    reasons = Column(postgresql.ARRAY(UnicodeText))\n\n    def __init__(self, user_id, chat_id):\n        self.user_id = user_id\n        self.chat_id = str(chat_id)\n        self.num_warns = 0\n        self.reasons = []\n\n    def __repr__(self):\n        return \"<{} warns for {} in {} for reasons {}>\".format(\n            self.num_warns, self.user_id, self.chat_id, self.reasons\n        )\n\n\nclass WarnFilters(BASE):\n    __tablename__ = \"warn_filters\"\n    chat_id = Column(String(14), primary_key=True)\n    keyword = Column(UnicodeText, primary_key=True, nullable=False)\n    reply = Column(UnicodeText, nullable=False)\n\n    def __init__(self, chat_id, keyword, reply):\n        self.chat_id = str(chat_id)  # ensure string\n        self.keyword = keyword\n        self.reply = reply\n\n    def __repr__(self):\n        return \"<Permissions for %s>\" % self.chat_id\n\n    def __eq__(self, other):\n        return bool(\n            isinstance(other, WarnFilters)\n            and self.chat_id == other.chat_id\n            and self.keyword == other.keyword\n        )\n\n\nclass WarnSettings(BASE):\n    __tablename__ = \"warn_settings\"\n    chat_id = Column(String(14), primary_key=True)\n    warn_limit = Column(Integer, default=3)\n    soft_warn = Column(Boolean, default=False)\n\n    def __init__(self, chat_id, warn_limit=3, soft_warn=False):\n        self.chat_id = str(chat_id)\n        self.warn_limit = warn_limit\n        self.soft_warn = soft_warn\n\n    def __repr__(self):\n        return \"<{} has {} possible warns.>\".format(self.chat_id, self.warn_limit)\n\n\nWarns.__table__.create(checkfirst=True)\nWarnFilters.__table__.create(checkfirst=True)\nWarnSettings.__table__.create(checkfirst=True)\n\nWARN_INSERTION_LOCK = threading.RLock()\nWARN_FILTER_INSERTION_LOCK = threading.RLock()\nWARN_SETTINGS_LOCK = threading.RLock()\n\nWARN_FILTERS = {}\n\n\ndef warn_user(user_id, chat_id, reason=None):\n    with WARN_INSERTION_LOCK:\n        warned_user = SESSION.query(Warns).get((user_id, str(chat_id)))\n        if not warned_user:\n            warned_user = Warns(user_id, str(chat_id))\n\n        warned_user.num_warns += 1\n        if reason:\n            warned_user.reasons = warned_user.reasons + [\n                reason\n            ]  # TODO:: double check this wizardry\n\n        reasons = warned_user.reasons\n        num = warned_user.num_warns\n\n        SESSION.add(warned_user)\n        SESSION.commit()\n\n        return num, reasons\n\n\ndef remove_warn(user_id, chat_id):\n    with WARN_INSERTION_LOCK:\n        removed = False\n        warned_user = SESSION.query(Warns).get((user_id, str(chat_id)))\n\n        if warned_user and warned_user.num_warns > 0:\n            warned_user.num_warns -= 1\n            warned_user.reasons = warned_user.reasons[:-1]\n            SESSION.add(warned_user)\n            SESSION.commit()\n            removed = True\n\n        SESSION.close()\n        return removed\n\n\ndef reset_warns(user_id, chat_id):\n    with WARN_INSERTION_LOCK:\n        warned_user = SESSION.query(Warns).get((user_id, str(chat_id)))\n        if warned_user:\n            warned_user.num_warns = 0\n            warned_user.reasons = []\n\n            SESSION.add(warned_user)\n            SESSION.commit()\n        SESSION.close()\n\n\ndef get_warns(user_id, chat_id):\n    try:\n        user = SESSION.query(Warns).get((user_id, str(chat_id)))\n        if not user:\n            return None\n        reasons = user.reasons\n        num = user.num_warns\n        return num, reasons\n    finally:\n        SESSION.close()\n\n\ndef add_warn_filter(chat_id, keyword, reply):\n    with WARN_FILTER_INSERTION_LOCK:\n        warn_filt = WarnFilters(str(chat_id), keyword, reply)\n\n        if keyword not in WARN_FILTERS.get(str(chat_id), []):\n            WARN_FILTERS[str(chat_id)] = sorted(\n                WARN_FILTERS.get(str(chat_id), []) + [keyword],\n                key=lambda x: (-len(x), x),\n            )\n\n        SESSION.merge(warn_filt)  # merge to avoid duplicate key issues\n        SESSION.commit()\n\n\ndef remove_warn_filter(chat_id, keyword):\n    with WARN_FILTER_INSERTION_LOCK:\n        warn_filt = SESSION.query(WarnFilters).get((str(chat_id), keyword))\n        if warn_filt:\n            if keyword in WARN_FILTERS.get(str(chat_id), []):  # sanity check\n                WARN_FILTERS.get(str(chat_id), []).remove(keyword)\n\n            SESSION.delete(warn_filt)\n            SESSION.commit()\n            return True\n        SESSION.close()\n        return False\n\n\ndef get_chat_warn_triggers(chat_id):\n    return WARN_FILTERS.get(str(chat_id), set())\n\n\ndef get_chat_warn_filters(chat_id):\n    try:\n        return (\n            SESSION.query(WarnFilters).filter(WarnFilters.chat_id == str(chat_id)).all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef get_warn_filter(chat_id, keyword):\n    try:\n        return SESSION.query(WarnFilters).get((str(chat_id), keyword))\n    finally:\n        SESSION.close()\n\n\ndef set_warn_limit(chat_id, warn_limit):\n    with WARN_SETTINGS_LOCK:\n        curr_setting = SESSION.query(WarnSettings).get(str(chat_id))\n        if not curr_setting:\n            curr_setting = WarnSettings(chat_id, warn_limit=warn_limit)\n\n        curr_setting.warn_limit = warn_limit\n\n        SESSION.add(curr_setting)\n        SESSION.commit()\n\n\ndef set_warn_strength(chat_id, soft_warn):\n    with WARN_SETTINGS_LOCK:\n        curr_setting = SESSION.query(WarnSettings).get(str(chat_id))\n        if not curr_setting:\n            curr_setting = WarnSettings(chat_id, soft_warn=soft_warn)\n\n        curr_setting.soft_warn = soft_warn\n\n        SESSION.add(curr_setting)\n        SESSION.commit()\n\n\ndef get_warn_setting(chat_id):\n    try:\n        setting = SESSION.query(WarnSettings).get(str(chat_id))\n        if setting:\n            return setting.warn_limit, setting.soft_warn\n        else:\n            return 3, False\n\n    finally:\n        SESSION.close()\n\n\ndef num_warns():\n    try:\n        return SESSION.query(func.sum(Warns.num_warns)).scalar() or 0\n    finally:\n        SESSION.close()\n\n\ndef num_warn_chats():\n    try:\n        return SESSION.query(func.count(distinct(Warns.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef num_warn_filters():\n    try:\n        return SESSION.query(WarnFilters).count()\n    finally:\n        SESSION.close()\n\n\ndef num_warn_chat_filters(chat_id):\n    try:\n        return (\n            SESSION.query(WarnFilters.chat_id)\n            .filter(WarnFilters.chat_id == str(chat_id))\n            .count()\n        )\n    finally:\n        SESSION.close()\n\n\ndef num_warn_filter_chats():\n    try:\n        return SESSION.query(func.count(distinct(WarnFilters.chat_id))).scalar()\n    finally:\n        SESSION.close()\n\n\ndef __load_chat_warn_filters():\n    global WARN_FILTERS\n    try:\n        chats = SESSION.query(WarnFilters.chat_id).distinct().all()\n        for (chat_id,) in chats:  # remove tuple by ( ,)\n            WARN_FILTERS[chat_id] = []\n\n        all_filters = SESSION.query(WarnFilters).all()\n        for x in all_filters:\n            WARN_FILTERS[x.chat_id] += [x.keyword]\n\n        WARN_FILTERS = {\n            x: sorted(set(y), key=lambda i: (-len(i), i))\n            for x, y in WARN_FILTERS.items()\n        }\n\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with WARN_INSERTION_LOCK:\n        chat_notes = (\n            SESSION.query(Warns).filter(Warns.chat_id == str(old_chat_id)).all()\n        )\n        for note in chat_notes:\n            note.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n    with WARN_FILTER_INSERTION_LOCK:\n        chat_filters = (\n            SESSION.query(WarnFilters)\n            .filter(WarnFilters.chat_id == str(old_chat_id))\n            .all()\n        )\n        for filt in chat_filters:\n            filt.chat_id = str(new_chat_id)\n        SESSION.commit()\n        old_warn_filt = WARN_FILTERS.get(str(old_chat_id))\n        if old_warn_filt is not None:\n            WARN_FILTERS[str(new_chat_id)] = old_warn_filt\n            del WARN_FILTERS[str(old_chat_id)]\n\n    with WARN_SETTINGS_LOCK:\n        chat_settings = (\n            SESSION.query(WarnSettings)\n            .filter(WarnSettings.chat_id == str(old_chat_id))\n            .all()\n        )\n        for setting in chat_settings:\n            setting.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n\n__load_chat_warn_filters()\n","size_bytes":8661},"sitaBot/modules/helper_funcs/misc.py":{"content":"from math import ceil\nfrom typing import Dict, List\n\nfrom sitaBot import NO_LOAD\nfrom telegram import MAX_MESSAGE_LENGTH, Bot, InlineKeyboardButton, ParseMode\nfrom telegram.error import TelegramError\n\n\nclass EqInlineKeyboardButton(InlineKeyboardButton):\n    def __eq__(self, other):\n        return self.text == other.text\n\n    def __lt__(self, other):\n        return self.text < other.text\n\n    def __gt__(self, other):\n        return self.text > other.text\n\n\ndef split_message(msg: str) -> List[str]:\n    if len(msg) < MAX_MESSAGE_LENGTH:\n        return [msg]\n\n    lines = msg.splitlines(True)\n    small_msg = \"\"\n    result = []\n    for line in lines:\n        if len(small_msg) + len(line) < MAX_MESSAGE_LENGTH:\n            small_msg += line\n        else:\n            result.append(small_msg)\n            small_msg = line\n    else:\n        # Else statement at the end of the for loop, so append the leftover string.\n        result.append(small_msg)\n\n    return result\n\n\ndef paginate_modules(page_n: int, module_dict: Dict, prefix, chat=None) -> List:\n    if not chat:\n        modules = sorted(\n            [EqInlineKeyboardButton(x.__mod_name__,\n                                    callback_data=\"{}_module({})\".format(prefix, x.__mod_name__.lower())) for x\n             in module_dict.values()])\n    else:\n        modules = sorted(\n            [EqInlineKeyboardButton(x.__mod_name__,\n                                    callback_data=\"{}_module({},{})\".format(prefix, chat, x.__mod_name__.lower())) for x\n             in module_dict.values()])\n\n    pairs = [\n    modules[i * 3:(i + 1) * 3] for i in range((len(modules) + 3 - 1) // 3)\n    ]\n\n    round_num = len(modules) / 3\n    calc = len(modules) - round(round_num)\n    if calc == 1:\n        pairs.append((modules[-1], ))\n    elif calc == 2:\n        pairs.append((modules[-1], ))\n\n    max_num_pages = ceil(len(pairs) / 10)\n    modulo_page = page_n % max_num_pages\n\n    # can only have a certain amount of buttons side by side\n    if len(pairs) > 8:\n        pairs = pairs[modulo_page * 8:8 * (modulo_page + 1)] + [\n            (EqInlineKeyboardButton(\"Back\", callback_data=\"{}_prev({})\".format(prefix, modulo_page)),\n                EqInlineKeyboardButton(\"Close\", callback_data=\"sita_back\"),\n             EqInlineKeyboardButton(\"Next\", callback_data=\"{}_next({})\".format(prefix, modulo_page)))]\n\n    else:\n        pairs += [[EqInlineKeyboardButton(\"Back\", callback_data=\"sita_back\")]]\n\n    return pairs\n\n\ndef send_to_list(\n    bot: Bot, send_to: list, message: str, markdown=False, html=False\n) -> None:\n    if html and markdown:\n        raise Exception(\"Can only send with either markdown or HTML!\")\n    for user_id in set(send_to):\n        try:\n            if markdown:\n                bot.send_message(user_id, message, parse_mode=ParseMode.MARKDOWN)\n            elif html:\n                bot.send_message(user_id, message, parse_mode=ParseMode.HTML)\n            else:\n                bot.send_message(user_id, message)\n        except TelegramError:\n            pass  # ignore users who fail\n\n\ndef build_keyboard(buttons):\n    keyb = []\n    for btn in buttons:\n        if btn.same_line and keyb:\n            keyb[-1].append(InlineKeyboardButton(btn.name, url=btn.url))\n        else:\n            keyb.append([InlineKeyboardButton(btn.name, url=btn.url)])\n\n    return keyb\n\n\ndef revert_buttons(buttons):\n    res = \"\"\n    for btn in buttons:\n        if btn.same_line:\n            res += \"\\n[{}](buttonurl://{}:same)\".format(btn.name, btn.url)\n        else:\n            res += \"\\n[{}](buttonurl://{})\".format(btn.name, btn.url)\n\n    return res\n\n\ndef build_keyboard_parser(bot, chat_id, buttons):\n    keyb = []\n    for btn in buttons:\n        if btn.url == \"{rules}\":\n            btn.url = \"http://t.me/{}?start={}\".format(bot.username, chat_id)\n        if btn.same_line and keyb:\n            keyb[-1].append(InlineKeyboardButton(btn.name, url=btn.url))\n        else:\n            keyb.append([InlineKeyboardButton(btn.name, url=btn.url)])\n\n    return keyb\n\n\ndef is_module_loaded(name):\n    return name not in NO_LOAD\n","size_bytes":4069},"sitaBot/modules/cleaner.py":{"content":"\nimport html\n\nfrom sitaBot import ALLOW_EXCL, CustomCommandHandler, dispatcher\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.chat_status import (\n    bot_can_delete,\n    connection_status,\n    dev_plus,\n    user_admin,\n)\nfrom sitaBot.modules.sql import cleaner_sql as sql\nfrom telegram import ParseMode, Update\nfrom telegram.ext import (\n    CallbackContext,\n    CommandHandler,\n    Filters,\n    MessageHandler,\n    run_async,\n)\n\nCMD_STARTERS = (\"/\", \"!\") if ALLOW_EXCL else \"/\"\nBLUE_TEXT_CLEAN_GROUP = 13\nCommandHandlerList = (CommandHandler, CustomCommandHandler, DisableAbleCommandHandler)\ncommand_list = [\n    \"cleanblue\",\n    \"ignoreblue\",\n    \"unignoreblue\",\n    \"listblue\",\n    \"ungignoreblue\",\n    \"gignoreblue\" \"start\",\n    \"help\",\n    \"settings\",\n    \"donate\",\n    \"stalk\",\n    \"aka\",\n    \"leaderboard\",\n]\n\nfor handler_list in dispatcher.handlers:\n    for handler in dispatcher.handlers[handler_list]:\n        if any(isinstance(handler, cmd_handler) for cmd_handler in CommandHandlerList):\n            command_list += handler.command\n\n\n@run_async\ndef clean_blue_text_must_click(update: Update, context: CallbackContext):\n    bot = context.bot\n    chat = update.effective_chat\n    message = update.effective_message\n    if chat.get_member(bot.id).can_delete_messages and sql.is_enabled(chat.id):\n        fst_word = message.text.strip().split(None, 1)[0]\n\n        if len(fst_word) > 1 and any(\n            fst_word.startswith(start) for start in CMD_STARTERS\n        ):\n\n            command = fst_word[1:].split(\"@\")\n            chat = update.effective_chat\n\n            ignored = sql.is_command_ignored(chat.id, command[0])\n            if ignored:\n                return\n\n            if command[0] not in command_list:\n                message.delete()\n\n\n@run_async\n@connection_status\n@bot_can_delete\n@user_admin\ndef set_blue_text_must_click(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    message = update.effective_message\n    bot, args = context.bot, context.args\n    if len(args) >= 1:\n        val = args[0].lower()\n        if val in (\"off\", \"no\"):\n            sql.set_cleanbt(chat.id, False)\n            reply = \"Bluetext cleaning has been disabled for <b>{}</b>\".format(\n                html.escape(chat.title)\n            )\n            message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n        elif val in (\"yes\", \"on\"):\n            sql.set_cleanbt(chat.id, True)\n            reply = \"Bluetext cleaning has been enabled for <b>{}</b>\".format(\n                html.escape(chat.title)\n            )\n            message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n        else:\n            reply = \"Invalid argument.Accepted values are 'yes', 'on', 'no', 'off'\"\n            message.reply_text(reply)\n    else:\n        clean_status = sql.is_enabled(chat.id)\n        clean_status = \"Enabled\" if clean_status else \"Disabled\"\n        reply = \"Bluetext cleaning for <b>{}</b> : <b>{}</b>\".format(\n            html.escape(chat.title), clean_status\n        )\n        message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n\n@run_async\n@user_admin\ndef add_bluetext_ignore(update: Update, context: CallbackContext):\n    message = update.effective_message\n    chat = update.effective_chat\n    args = context.args\n    if len(args) >= 1:\n        val = args[0].lower()\n        added = sql.chat_ignore_command(chat.id, val)\n        if added:\n            reply = \"<b>{}</b> has been added to bluetext cleaner ignore list.\".format(\n                args[0]\n            )\n        else:\n            reply = \"Command is already ignored.\"\n        message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n    else:\n        reply = \"No command supplied to be ignored.\"\n        message.reply_text(reply)\n\n\n@run_async\n@user_admin\ndef remove_bluetext_ignore(update: Update, context: CallbackContext):\n    message = update.effective_message\n    chat = update.effective_chat\n    args = context.args\n    if len(args) >= 1:\n        val = args[0].lower()\n        removed = sql.chat_unignore_command(chat.id, val)\n        if removed:\n            reply = (\n                \"<b>{}</b> has been removed from bluetext cleaner ignore list.\".format(\n                    args[0]\n                )\n            )\n        else:\n            reply = \"Command isn't ignored currently.\"\n        message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n    else:\n        reply = \"No command supplied to be unignored.\"\n        message.reply_text(reply)\n\n\n@run_async\n@user_admin\ndef add_bluetext_ignore_global(update: Update, context: CallbackContext):\n    message = update.effective_message\n    args = context.args\n    if len(args) >= 1:\n        val = args[0].lower()\n        added = sql.global_ignore_command(val)\n        if added:\n            reply = \"<b>{}</b> has been added to global bluetext cleaner ignore list.\".format(\n                args[0]\n            )\n        else:\n            reply = \"Command is already ignored.\"\n        message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n    else:\n        reply = \"No command supplied to be ignored.\"\n        message.reply_text(reply)\n\n\n@run_async\n@dev_plus\ndef remove_bluetext_ignore_global(update: Update, context: CallbackContext):\n    message = update.effective_message\n    args = context.args\n    if len(args) >= 1:\n        val = args[0].lower()\n        removed = sql.global_unignore_command(val)\n        if removed:\n            reply = \"<b>{}</b> has been removed from global bluetext cleaner ignore list.\".format(\n                args[0]\n            )\n        else:\n            reply = \"Command isn't ignored currently.\"\n        message.reply_text(reply, parse_mode=ParseMode.HTML)\n\n    else:\n        reply = \"No command supplied to be unignored.\"\n        message.reply_text(reply)\n\n\n@run_async\n@dev_plus\ndef bluetext_ignore_list(update: Update, context: CallbackContext):\n\n    message = update.effective_message\n    chat = update.effective_chat\n\n    global_ignored_list, local_ignore_list = sql.get_all_ignored(chat.id)\n    text = \"\"\n\n    if global_ignored_list:\n        text = \"The following commands are currently ignored globally from bluetext cleaning :\\n\"\n\n        for x in global_ignored_list:\n            text += f\" - <code>{x}</code>\\n\"\n\n    if local_ignore_list:\n        text += \"\\nThe following commands are currently ignored locally from bluetext cleaning :\\n\"\n\n        for x in local_ignore_list:\n            text += f\" - <code>{x}</code>\\n\"\n\n    if text == \"\":\n        text = \"No commands are currently ignored from bluetext cleaning.\"\n        message.reply_text(text)\n        return\n\n    message.reply_text(text, parse_mode=ParseMode.HTML)\n    return\n\n\nSET_CLEAN_BLUE_TEXT_HANDLER = CommandHandler(\"cleanblue\", set_blue_text_must_click)\nADD_CLEAN_BLUE_TEXT_HANDLER = CommandHandler(\"ignoreblue\", add_bluetext_ignore)\nREMOVE_CLEAN_BLUE_TEXT_HANDLER = CommandHandler(\"unignoreblue\", remove_bluetext_ignore)\nADD_CLEAN_BLUE_TEXT_GLOBAL_HANDLER = CommandHandler(\n    \"gignoreblue\", add_bluetext_ignore_global\n)\nREMOVE_CLEAN_BLUE_TEXT_GLOBAL_HANDLER = CommandHandler(\n    \"ungignoreblue\", remove_bluetext_ignore_global\n)\nLIST_CLEAN_BLUE_TEXT_HANDLER = CommandHandler(\"listblue\", bluetext_ignore_list)\nCLEAN_BLUE_TEXT_HANDLER = MessageHandler(\n    Filters.command & Filters.group, clean_blue_text_must_click\n)\n\ndispatcher.add_handler(SET_CLEAN_BLUE_TEXT_HANDLER)\ndispatcher.add_handler(ADD_CLEAN_BLUE_TEXT_HANDLER)\ndispatcher.add_handler(REMOVE_CLEAN_BLUE_TEXT_HANDLER)\ndispatcher.add_handler(ADD_CLEAN_BLUE_TEXT_GLOBAL_HANDLER)\ndispatcher.add_handler(REMOVE_CLEAN_BLUE_TEXT_GLOBAL_HANDLER)\ndispatcher.add_handler(LIST_CLEAN_BLUE_TEXT_HANDLER)\ndispatcher.add_handler(CLEAN_BLUE_TEXT_HANDLER, BLUE_TEXT_CLEAN_GROUP)\n\n__mod_name__ = \"Bluetext Cleaning\"\n__handlers__ = [\n    SET_CLEAN_BLUE_TEXT_HANDLER,\n    ADD_CLEAN_BLUE_TEXT_HANDLER,\n    REMOVE_CLEAN_BLUE_TEXT_HANDLER,\n    ADD_CLEAN_BLUE_TEXT_GLOBAL_HANDLER,\n    REMOVE_CLEAN_BLUE_TEXT_GLOBAL_HANDLER,\n    LIST_CLEAN_BLUE_TEXT_HANDLER,\n    (CLEAN_BLUE_TEXT_HANDLER, BLUE_TEXT_CLEAN_GROUP),\n]\n","size_bytes":8056},"sitaBot/modules/shell.py":{"content":"import subprocess\n\nfrom sitaBot import LOGGER, dispatcher\nfrom sitaBot.modules.helper_funcs.chat_status import dev_plus\nfrom telegram import ParseMode, Update\nfrom telegram.ext import CallbackContext, CommandHandler\nfrom telegram.ext.dispatcher import run_async\n\n\n@dev_plus\n@run_async\ndef shell(update: Update, context: CallbackContext):\n    message = update.effective_message\n    cmd = message.text.split(\" \", 1)\n    if len(cmd) == 1:\n        message.reply_text(\"No command to execute was given.\")\n        return\n    cmd = cmd[1]\n    process = subprocess.Popen(\n        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True\n    )\n    stdout, stderr = process.communicate()\n    reply = \"\"\n    stderr = stderr.decode()\n    stdout = stdout.decode()\n    if stdout:\n        reply += f\"*Stdout*\\n`{stdout}`\\n\"\n        LOGGER.info(f\"Shell - {cmd} - {stdout}\")\n    if stderr:\n        reply += f\"*Stderr*\\n`{stderr}`\\n\"\n        LOGGER.error(f\"Shell - {cmd} - {stderr}\")\n    if len(reply) > 3000:\n        with open(\"shell_output.txt\", \"w\") as file:\n            file.write(reply)\n        with open(\"shell_output.txt\", \"rb\") as doc:\n            context.bot.send_document(\n                document=doc,\n                filename=doc.name,\n                reply_to_message_id=message.message_id,\n                chat_id=message.chat_id,\n            )\n    else:\n        message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)\n\n\nSHELL_HANDLER = CommandHandler([\"sh\"], shell)\ndispatcher.add_handler(SHELL_HANDLER)\n__mod_name__ = \"Shell\"\n__command_list__ = [\"sh\"]\n__handlers__ = [SHELL_HANDLER]\n","size_bytes":1588},"sitaBot/modules/feds.py":{"content":"import csv\nimport json\nimport os\nimport re\nimport time\nimport uuid\nfrom io import BytesIO\n\nimport sitaBot.modules.sql.feds_sql as sql\nfrom sitaBot import (\n    EVENT_LOGS,\n    LOGGER,\n    SUPPORT_CHAT,\n    OWNER_ID,\n    DRAGONS,\n    TIGERS,\n    WOLVES,\n    dispatcher,\n)\nfrom sitaBot.modules.disable import DisableAbleCommandHandler\nfrom sitaBot.modules.helper_funcs.alternate import send_message\nfrom sitaBot.modules.helper_funcs.chat_status import is_user_admin\nfrom sitaBot.modules.helper_funcs.extraction import (\n    extract_unt_fedban,\n    extract_user,\n    extract_user_fban,\n)\nfrom sitaBot.modules.helper_funcs.string_handling import markdown_parser\nfrom telegram import (\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n    MessageEntity,\n    ParseMode,\n    Update,\n)\nfrom telegram.error import BadRequest, TelegramError, Unauthorized\nfrom telegram.ext import (\n    CallbackContext,\n    CallbackQueryHandler,\n    CommandHandler,\n    run_async,\n)\nfrom telegram.utils.helpers import mention_html, mention_markdown\n\n# Hello bot owner, I spended for feds many hours of my life, Please don't remove this if you still respect MrYacha and peaktogoo and AyraHikari too\n# Federation by MrYacha 2018-2019\n# Federation rework by Mizukito Akito 2019\n# Federation update v2 by Ayra Hikari 2019\n# Time spended on feds = 10h by #MrYacha\n# Time spended on reworking on the whole feds = 22+ hours by @peaktogoo\n# Time spended on updating version to v2 = 26+ hours by @AyraHikari\n# Total spended for making this features is 68+ hours\n# LOGGER.info(\"Original federation module by MrYacha, reworked by Mizukito Akito (@peaktogoo) on Telegram.\")\n\nFBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Peer_id_invalid\",\n    \"Group chat was deactivated\",\n    \"Need to be inviter of a user to kick it from a basic group\",\n    \"Chat_admin_required\",\n    \"Only the creator of a basic group can kick group administrators\",\n    \"Channel_private\",\n    \"Not in the chat\",\n    \"Have no rights to send a message\",\n}\n\nUNFBAN_ERRORS = {\n    \"User is an administrator of the chat\",\n    \"Chat not found\",\n    \"Not enough rights to restrict/unrestrict chat member\",\n    \"User_not_participant\",\n    \"Method is available for supergroup and channel chats only\",\n    \"Not in the chat\",\n    \"Channel_private\",\n    \"Chat_admin_required\",\n    \"Have no rights to send a message\",\n}\n\n\n@run_async\ndef new_fed(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n    if chat.type != \"private\":\n        update.effective_message.reply_text(\n            \"Federations can only be created by privately messaging me.\"\n        )\n        return\n    if len(message.text) == 1:\n        send_message(\n            update.effective_message, \"Please write the name of the federation!\"\n        )\n        return\n    fednam = message.text.split(None, 1)[1]\n    if not fednam == \"\":\n        fed_id = str(uuid.uuid4())\n        fed_name = fednam\n        LOGGER.info(fed_id)\n\n        # Currently only for creator\n        # if fednam == 'Team Nusantara Disciplinary Circle':\n        # fed_id = \"TeamNusantaraDevs\"\n\n        x = sql.new_fed(user.id, fed_name, fed_id)\n        if not x:\n            update.effective_message.reply_text(\n                f\"Can't federate! Please contact @{SUPPORT_CHAT} if the problem persist.\"\n            )\n            return\n\n        update.effective_message.reply_text(\n            \"*You have succeeded in creating a new federation!*\"\n            \"\\nName: `{}`\"\n            \"\\nID: `{}`\"\n            \"\\n\\nUse the command below to join the federation:\"\n            \"\\n`/joinfed {}`\".format(fed_name, fed_id, fed_id),\n            parse_mode=ParseMode.MARKDOWN,\n        )\n        try:\n            bot.send_message(\n                EVENT_LOGS,\n                \"New Federation: <b>{}</b>\\nID: <pre>{}</pre>\".format(fed_name, fed_id),\n                parse_mode=ParseMode.HTML,\n            )\n        except:\n            LOGGER.warning(\"Cannot send a message to EVENT_LOGS\")\n    else:\n        update.effective_message.reply_text(\n            \"Please write down the name of the federation\"\n        )\n\n\n@run_async\ndef del_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    if chat.type != \"private\":\n        update.effective_message.reply_text(\n            \"Federations can only be deleted by privately messaging me.\"\n        )\n        return\n    if args:\n        is_fed_id = args[0]\n        getinfo = sql.get_fed_info(is_fed_id)\n        if getinfo is False:\n            update.effective_message.reply_text(\"This federation does not exist.\")\n            return\n        if int(getinfo[\"owner\"]) == int(user.id) or int(user.id) == OWNER_ID:\n            fed_id = is_fed_id\n        else:\n            update.effective_message.reply_text(\"Only federation owners can do this!\")\n            return\n    else:\n        update.effective_message.reply_text(\"What should I delete?\")\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only federation owners can do this!\")\n        return\n\n    update.effective_message.reply_text(\n        \"You sure you want to delete your federation? This cannot be reverted, you will lose your entire ban list, and '{}' will be permanently lost.\".format(\n            getinfo[\"fname\"]\n        ),\n        reply_markup=InlineKeyboardMarkup(\n            [\n                [\n                    InlineKeyboardButton(\n                        text=\"‚ö†Ô∏è Delete Federation ‚ö†Ô∏è\",\n                        callback_data=\"rmfed_{}\".format(fed_id),\n                    )\n                ],\n                [InlineKeyboardButton(text=\"Cancel\", callback_data=\"rmfed_cancel\")],\n            ]\n        ),\n    )\n\n\n@run_async\ndef rename_fed(update, context):\n    user = update.effective_user\n    msg = update.effective_message\n    args = msg.text.split(None, 2)\n\n    if len(args) < 3:\n        return msg.reply_text(\"usage: /renamefed <fed_id> <newname>\")\n\n    fed_id, newname = args[1], args[2]\n    verify_fed = sql.get_fed_info(fed_id)\n\n    if not verify_fed:\n        return msg.reply_text(\"This fed not exist in my database!\")\n\n    if is_user_fed_owner(fed_id, user.id):\n        sql.rename_fed(fed_id, user.id, newname)\n        msg.reply_text(f\"Successfully renamed your fed name to {newname}!\")\n    else:\n        msg.reply_text(\"Only federation owner can do this!\")\n\n\n@run_async\ndef fed_chat(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    fed_id = sql.get_fed_id(chat.id)\n\n    user_id = update.effective_message.from_user.id\n    if not is_user_admin(update.effective_chat, user_id):\n        update.effective_message.reply_text(\n            \"You must be an admin to execute this command\"\n        )\n        return\n\n    if not fed_id:\n        update.effective_message.reply_text(\"This group is not in any federation!\")\n        return\n\n    user = update.effective_user\n    chat = update.effective_chat\n    info = sql.get_fed_info(fed_id)\n\n    text = \"This group is part of the following federation:\"\n    text += \"\\n{} (ID: <code>{}</code>)\".format(info[\"fname\"], fed_id)\n\n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef join_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    message = update.effective_message\n    administrators = chat.get_administrators()\n    fed_id = sql.get_fed_id(chat.id)\n\n    if user.id in DRAGONS:\n        pass\n    else:\n        for admin in administrators:\n            status = admin.status\n            if status == \"creator\":\n                if str(admin.user.id) == str(user.id):\n                    pass\n                else:\n                    update.effective_message.reply_text(\n                        \"Only group creators can use this command!\"\n                    )\n                    return\n    if fed_id:\n        message.reply_text(\"You cannot join two federations from one chat\")\n        return\n\n    if len(args) >= 1:\n        getfed = sql.search_fed_by_id(args[0])\n        if getfed is False:\n            message.reply_text(\"Please enter a valid federation ID\")\n            return\n\n        x = sql.chat_join_fed(args[0], chat.title, chat.id)\n        if not x:\n            message.reply_text(\n                f\"Failed to join federation! Please contact @{SUPPORT_CHAT} should this problem persist!\"\n            )\n            return\n\n        get_fedlog = sql.get_fed_log(args[0])\n        if get_fedlog:\n            if eval(get_fedlog):\n                bot.send_message(\n                    get_fedlog,\n                    \"Chat *{}* has joined the federation *{}*\".format(\n                        chat.title, getfed[\"fname\"]\n                    ),\n                    parse_mode=\"markdown\",\n                )\n\n        message.reply_text(\n            \"This group has joined the federation: {}!\".format(getfed[\"fname\"])\n        )\n\n\n@run_async\ndef leave_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our PM!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    fed_info = sql.get_fed_info(fed_id)\n\n    # administrators = chat.get_administrators().status\n    getuser = bot.get_chat_member(chat.id, user.id).status\n    if getuser in \"creator\" or user.id in DRAGONS:\n        if sql.chat_leave_fed(chat.id) is True:\n            get_fedlog = sql.get_fed_log(fed_id)\n            if get_fedlog:\n                if eval(get_fedlog):\n                    bot.send_message(\n                        get_fedlog,\n                        \"Chat *{}* has left the federation *{}*\".format(\n                            chat.title, fed_info[\"fname\"]\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n            send_message(\n                update.effective_message,\n                \"This group has left the federation {}!\".format(fed_info[\"fname\"]),\n            )\n        else:\n            update.effective_message.reply_text(\n                \"How can you leave a federation that you never joined?!\"\n            )\n    else:\n        update.effective_message.reply_text(\"Only group creators can use this command!\")\n\n\n@run_async\ndef user_join_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if is_user_fed_owner(fed_id, user.id) or user.id in DRAGONS:\n        user_id = extract_user(msg, args)\n        if user_id:\n            user = bot.get_chat(user_id)\n        elif not msg.reply_to_message and not args:\n            user = msg.from_user\n        elif not msg.reply_to_message and (\n            not args\n            or (\n                len(args) >= 1\n                and not args[0].startswith(\"@\")\n                and not args[0].isdigit()\n                and not msg.parse_entities([MessageEntity.TEXT_MENTION])\n            )\n        ):\n            msg.reply_text(\"I cannot extract user from this message\")\n            return\n        else:\n            LOGGER.warning(\"error\")\n        getuser = sql.search_user_in_fed(fed_id, user_id)\n        fed_id = sql.get_fed_id(chat.id)\n        info = sql.get_fed_info(fed_id)\n        get_owner = eval(info[\"fusers\"])[\"owner\"]\n        get_owner = bot.get_chat(get_owner).id\n        if user_id == get_owner:\n            update.effective_message.reply_text(\n                \"You do know that the user is the federation owner, right? RIGHT?\"\n            )\n            return\n        if getuser:\n            update.effective_message.reply_text(\n                \"I cannot promote users who are already federation admins! Can remove them if you want!\"\n            )\n            return\n        if user_id == bot.id:\n            update.effective_message.reply_text(\n                \"I already am a federation admin in all federations!\"\n            )\n            return\n        res = sql.user_join_fed(fed_id, user_id)\n        if res:\n            update.effective_message.reply_text(\"Successfully Promoted!\")\n        else:\n            update.effective_message.reply_text(\"Failed to promote!\")\n    else:\n        update.effective_message.reply_text(\"Only federation owners can do this!\")\n\n\n@run_async\ndef user_demote_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if is_user_fed_owner(fed_id, user.id):\n        msg = update.effective_message\n        user_id = extract_user(msg, args)\n        if user_id:\n            user = bot.get_chat(user_id)\n\n        elif not msg.reply_to_message and not args:\n            user = msg.from_user\n\n        elif not msg.reply_to_message and (\n            not args\n            or (\n                len(args) >= 1\n                and not args[0].startswith(\"@\")\n                and not args[0].isdigit()\n                and not msg.parse_entities([MessageEntity.TEXT_MENTION])\n            )\n        ):\n            msg.reply_text(\"I cannot extract user from this message\")\n            return\n        else:\n            LOGGER.warning(\"error\")\n\n        if user_id == bot.id:\n            update.effective_message.reply_text(\n                \"The thing you are trying to demote me from will fail to work without me! Just saying.\"\n            )\n            return\n\n        if sql.search_user_in_fed(fed_id, user_id) is False:\n            update.effective_message.reply_text(\n                \"I cannot demote people who are not federation admins!\"\n            )\n            return\n\n        res = sql.user_demote_fed(fed_id, user_id)\n        if res is True:\n            update.effective_message.reply_text(\"Demoted from a Fed Admin!\")\n        else:\n            update.effective_message.reply_text(\"Demotion failed!\")\n    else:\n        update.effective_message.reply_text(\"Only federation owners can do this!\")\n        return\n\n\n@run_async\ndef fed_info(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    if args:\n        fed_id = args[0]\n        info = sql.get_fed_info(fed_id)\n    else:\n        fed_id = sql.get_fed_id(chat.id)\n        if not fed_id:\n            send_message(\n                update.effective_message, \"This group is not in any federation!\"\n            )\n            return\n        info = sql.get_fed_info(fed_id)\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only a federation admin can do this!\")\n        return\n\n    owner = bot.get_chat(info[\"owner\"])\n    try:\n        owner_name = owner.first_name + \" \" + owner.last_name\n    except:\n        owner_name = owner.first_name\n    FEDADMIN = sql.all_fed_users(fed_id)\n    TotalAdminFed = len(FEDADMIN)\n\n    user = update.effective_user\n    chat = update.effective_chat\n    info = sql.get_fed_info(fed_id)\n\n    text = \"<b>‚ÑπÔ∏è Federation Information:</b>\"\n    text += \"\\nFedID: <code>{}</code>\".format(fed_id)\n    text += \"\\nName: {}\".format(info[\"fname\"])\n    text += \"\\nCreator: {}\".format(mention_html(owner.id, owner_name))\n    text += \"\\nAll Admins: <code>{}</code>\".format(TotalAdminFed)\n    getfban = sql.get_all_fban_users(fed_id)\n    text += \"\\nTotal banned users: <code>{}</code>\".format(len(getfban))\n    getfchat = sql.all_fed_chats(fed_id)\n    text += \"\\nNumber of groups in this federation: <code>{}</code>\".format(\n        len(getfchat)\n    )\n\n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef fed_admin(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\"This group is not in any federation!\")\n        return\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only federation admins can do this!\")\n        return\n\n    user = update.effective_user\n    chat = update.effective_chat\n    info = sql.get_fed_info(fed_id)\n\n    text = \"<b>Federation Admin {}:</b>\\n\\n\".format(info[\"fname\"])\n    text += \"üëë Owner:\\n\"\n    owner = bot.get_chat(info[\"owner\"])\n    try:\n        owner_name = owner.first_name + \" \" + owner.last_name\n    except:\n        owner_name = owner.first_name\n    text += \" ‚Ä¢ {}\\n\".format(mention_html(owner.id, owner_name))\n\n    members = sql.all_fed_members(fed_id)\n    if len(members) == 0:\n        text += \"\\nüî± There are no admins in this federation\"\n    else:\n        text += \"\\nüî± Admin:\\n\"\n        for x in members:\n            user = bot.get_chat(x)\n            text += \" ‚Ä¢ {}\\n\".format(mention_html(user.id, user.first_name))\n\n    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n\n\n@run_async\ndef fed_ban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    info = sql.get_fed_info(fed_id)\n    getfednotif = sql.user_feds_report(info[\"owner\"])\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only federation admins can do this!\")\n        return\n\n    message = update.effective_message\n\n    user_id, reason = extract_unt_fedban(message, args)\n\n    fban, fbanreason, fbantime = sql.get_fban_user(fed_id, user_id)\n\n    if not user_id:\n        message.reply_text(\"You don't seem to be referring to a user\")\n        return\n\n    if user_id == bot.id:\n        message.reply_text(\n            \"What is funnier than kicking the group creator? Self sacrifice.\"\n        )\n        return\n\n    if is_user_fed_owner(fed_id, user_id) is True:\n        message.reply_text(\"Why did you try the federation fban?\")\n        return\n\n    if is_user_fed_admin(fed_id, user_id) is True:\n        message.reply_text(\"He is a federation admin, I can't fban him.\")\n        return\n\n    if user_id == OWNER_ID:\n        message.reply_text(\"Disaster level God cannot be fed banned!\")\n        return\n\n    if int(user_id) in DRAGONS:\n        message.reply_text(\"Dragons cannot be fed banned!\")\n        return\n\n    if int(user_id) in TIGERS:\n        message.reply_text(\"Tigers cannot be fed banned!\")\n        return\n\n    if int(user_id) in WOLVES:\n        message.reply_text(\"Wolves cannot be fed banned!\")\n        return\n\n    if user_id in [777000, 1087968824]:\n        message.reply_text(\"Fool! You can't attack Telegram's native tech!\")\n        return\n\n    try:\n        user_chat = bot.get_chat(user_id)\n        isvalid = True\n        fban_user_id = user_chat.id\n        fban_user_name = user_chat.first_name\n        fban_user_lname = user_chat.last_name\n        fban_user_uname = user_chat.username\n    except BadRequest as excp:\n        if not str(user_id).isdigit():\n            send_message(update.effective_message, excp.message)\n            return\n        elif len(str(user_id)) != 9:\n            send_message(update.effective_message, \"That's so not a user!\")\n            return\n        isvalid = False\n        fban_user_id = int(user_id)\n        fban_user_name = \"user({})\".format(user_id)\n        fban_user_lname = None\n        fban_user_uname = None\n\n    if isvalid and user_chat.type != \"private\":\n        send_message(update.effective_message, \"That's so not a user!\")\n        return\n\n    if isvalid:\n        user_target = mention_html(fban_user_id, fban_user_name)\n    else:\n        user_target = fban_user_name\n\n    if fban:\n        fed_name = info[\"fname\"]\n        # https://t.me/OnePunchSupport/41606 // https://t.me/OnePunchSupport/41619\n        # starting = \"The reason fban is replaced for {} in the Federation <b>{}</b>.\".format(user_target, fed_name)\n        # send_message(update.effective_message, starting, parse_mode=ParseMode.HTML)\n\n        # if reason == \"\":\n        #    reason = \"No reason given.\"\n\n        temp = sql.un_fban_user(fed_id, fban_user_id)\n        if not temp:\n            message.reply_text(\"Failed to update the reason for fedban!\")\n            return\n        x = sql.fban_user(\n            fed_id,\n            fban_user_id,\n            fban_user_name,\n            fban_user_lname,\n            fban_user_uname,\n            reason,\n            int(time.time()),\n        )\n        if not x:\n            message.reply_text(\n                f\"Failed to ban from the federation! If this problem continues, contact @{SUPPORT_CHAT}.\"\n            )\n            return\n\n        fed_chats = sql.all_fed_chats(fed_id)\n        # Will send to current chat\n        bot.send_message(\n            chat.id,\n            \"<b>FedBan reason updated</b>\"\n            \"\\n<b>Federation:</b> {}\"\n            \"\\n<b>Federation Admin:</b> {}\"\n            \"\\n<b>User:</b> {}\"\n            \"\\n<b>User ID:</b> <code>{}</code>\"\n            \"\\n<b>Reason:</b> {}\".format(\n                fed_name,\n                mention_html(user.id, user.first_name),\n                user_target,\n                fban_user_id,\n                reason,\n            ),\n            parse_mode=\"HTML\",\n        )\n        # Send message to owner if fednotif is enabled\n        if getfednotif:\n            bot.send_message(\n                info[\"owner\"],\n                \"<b>FedBan reason updated</b>\"\n                \"\\n<b>Federation:</b> {}\"\n                \"\\n<b>Federation Admin:</b> {}\"\n                \"\\n<b>User:</b> {}\"\n                \"\\n<b>User ID:</b> <code>{}</code>\"\n                \"\\n<b>Reason:</b> {}\".format(\n                    fed_name,\n                    mention_html(user.id, user.first_name),\n                    user_target,\n                    fban_user_id,\n                    reason,\n                ),\n                parse_mode=\"HTML\",\n            )\n        # If fedlog is set, then send message, except fedlog is current chat\n        get_fedlog = sql.get_fed_log(fed_id)\n        if get_fedlog:\n            if int(get_fedlog) != int(chat.id):\n                bot.send_message(\n                    get_fedlog,\n                    \"<b>FedBan reason updated</b>\"\n                    \"\\n<b>Federation:</b> {}\"\n                    \"\\n<b>Federation Admin:</b> {}\"\n                    \"\\n<b>User:</b> {}\"\n                    \"\\n<b>User ID:</b> <code>{}</code>\"\n                    \"\\n<b>Reason:</b> {}\".format(\n                        fed_name,\n                        mention_html(user.id, user.first_name),\n                        user_target,\n                        fban_user_id,\n                        reason,\n                    ),\n                    parse_mode=\"HTML\",\n                )\n        for fedschat in fed_chats:\n            try:\n                # Do not spam all fed chats\n                \"\"\"\n\t\t\t\tbot.send_message(chat, \"<b>FedBan reason updated</b>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User ID:</b> <code>{}</code>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Reason:</b> {}\".format(fed_name, mention_html(user.id, user.first_name), user_target, fban_user_id, reason), parse_mode=\"HTML\")\n\t\t\t\t\"\"\"\n                bot.kick_chat_member(fedschat, fban_user_id)\n            except BadRequest as excp:\n                if excp.message in FBAN_ERRORS:\n                    try:\n                        dispatcher.bot.getChat(fedschat)\n                    except Unauthorized:\n                        sql.chat_leave_fed(fedschat)\n                        LOGGER.info(\n                            \"Chat {} has leave fed {} because I was kicked\".format(\n                                fedschat, info[\"fname\"]\n                            )\n                        )\n                        continue\n                elif excp.message == \"User_id_invalid\":\n                    break\n                else:\n                    LOGGER.warning(\n                        \"Could not fban on {} because: {}\".format(chat, excp.message)\n                    )\n            except TelegramError:\n                pass\n        # Also do not spam all fed admins\n        \"\"\"\n\t\tsend_to_list(bot, FEDADMIN,\n\t\t\t\t \"<b>FedBan reason updated</b>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User ID:</b> <code>{}</code>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Reason:</b> {}\".format(fed_name, mention_html(user.id, user.first_name), user_target, fban_user_id, reason), \n\t\t\t\t\t\t\thtml=True)\n\t\t\"\"\"\n\n        # Fban for fed subscriber\n        subscriber = list(sql.get_subscriber(fed_id))\n        if len(subscriber) != 0:\n            for fedsid in subscriber:\n                all_fedschat = sql.all_fed_chats(fedsid)\n                for fedschat in all_fedschat:\n                    try:\n                        bot.kick_chat_member(fedschat, fban_user_id)\n                    except BadRequest as excp:\n                        if excp.message in FBAN_ERRORS:\n                            try:\n                                dispatcher.bot.getChat(fedschat)\n                            except Unauthorized:\n                                targetfed_id = sql.get_fed_id(fedschat)\n                                sql.unsubs_fed(fed_id, targetfed_id)\n                                LOGGER.info(\n                                    \"Chat {} has unsub fed {} because I was kicked\".format(\n                                        fedschat, info[\"fname\"]\n                                    )\n                                )\n                                continue\n                        elif excp.message == \"User_id_invalid\":\n                            break\n                        else:\n                            LOGGER.warning(\n                                \"Unable to fban on {} because: {}\".format(\n                                    fedschat, excp.message\n                                )\n                            )\n                    except TelegramError:\n                        pass\n        # send_message(update.effective_message, \"Fedban Reason has been updated.\")\n        return\n\n    fed_name = info[\"fname\"]\n\n    # starting = \"Starting a federation ban for {} in the Federation <b>{}</b>.\".format(\n    #    user_target, fed_name)\n    # update.effective_message.reply_text(starting, parse_mode=ParseMode.HTML)\n\n    # if reason == \"\":\n    #    reason = \"No reason given.\"\n\n    x = sql.fban_user(\n        fed_id,\n        fban_user_id,\n        fban_user_name,\n        fban_user_lname,\n        fban_user_uname,\n        reason,\n        int(time.time()),\n    )\n    if not x:\n        message.reply_text(\n            f\"Failed to ban from the federation! If this problem continues, contact @{SUPPORT_CHAT}.\"\n        )\n        return\n\n    fed_chats = sql.all_fed_chats(fed_id)\n    # Will send to current chat\n    bot.send_message(\n        chat.id,\n        \"<b>FedBan reason updated</b>\"\n        \"\\n<b>Federation:</b> {}\"\n        \"\\n<b>Federation Admin:</b> {}\"\n        \"\\n<b>User:</b> {}\"\n        \"\\n<b>User ID:</b> <code>{}</code>\"\n        \"\\n<b>Reason:</b> {}\".format(\n            fed_name,\n            mention_html(user.id, user.first_name),\n            user_target,\n            fban_user_id,\n            reason,\n        ),\n        parse_mode=\"HTML\",\n    )\n    # Send message to owner if fednotif is enabled\n    if getfednotif:\n        bot.send_message(\n            info[\"owner\"],\n            \"<b>FedBan reason updated</b>\"\n            \"\\n<b>Federation:</b> {}\"\n            \"\\n<b>Federation Admin:</b> {}\"\n            \"\\n<b>User:</b> {}\"\n            \"\\n<b>User ID:</b> <code>{}</code>\"\n            \"\\n<b>Reason:</b> {}\".format(\n                fed_name,\n                mention_html(user.id, user.first_name),\n                user_target,\n                fban_user_id,\n                reason,\n            ),\n            parse_mode=\"HTML\",\n        )\n    # If fedlog is set, then send message, except fedlog is current chat\n    get_fedlog = sql.get_fed_log(fed_id)\n    if get_fedlog:\n        if int(get_fedlog) != int(chat.id):\n            bot.send_message(\n                get_fedlog,\n                \"<b>FedBan reason updated</b>\"\n                \"\\n<b>Federation:</b> {}\"\n                \"\\n<b>Federation Admin:</b> {}\"\n                \"\\n<b>User:</b> {}\"\n                \"\\n<b>User ID:</b> <code>{}</code>\"\n                \"\\n<b>Reason:</b> {}\".format(\n                    fed_name,\n                    mention_html(user.id, user.first_name),\n                    user_target,\n                    fban_user_id,\n                    reason,\n                ),\n                parse_mode=\"HTML\",\n            )\n    chats_in_fed = 0\n    for fedschat in fed_chats:\n        chats_in_fed += 1\n        try:\n            # Do not spamming all fed chats\n            \"\"\"\n\t\t\tbot.send_message(chat, \"<b>FedBan reason updated</b>\" \\\n\t\t\t\t\t\t\t\"\\n<b>Federation:</b> {}\" \\\n\t\t\t\t\t\t\t\"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t\t\t\t\t\"\\n<b>User:</b> {}\" \\\n\t\t\t\t\t\t\t\"\\n<b>User ID:</b> <code>{}</code>\" \\\n\t\t\t\t\t\t\t\"\\n<b>Reason:</b> {}\".format(fed_name, mention_html(user.id, user.first_name), user_target, fban_user_id, reason), parse_mode=\"HTML\")\n\t\t\t\"\"\"\n            bot.kick_chat_member(fedschat, fban_user_id)\n        except BadRequest as excp:\n            if excp.message in FBAN_ERRORS:\n                pass\n            elif excp.message == \"User_id_invalid\":\n                break\n            else:\n                LOGGER.warning(\n                    \"Could not fban on {} because: {}\".format(chat, excp.message)\n                )\n        except TelegramError:\n            pass\n\n        # Also do not spamming all fed admins\n        \"\"\"\n\t\tsend_to_list(bot, FEDADMIN,\n\t\t\t\t \"<b>FedBan reason updated</b>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User:</b> {}\" \\\n\t\t\t\t\t\t\t \"\\n<b>User ID:</b> <code>{}</code>\" \\\n\t\t\t\t\t\t\t \"\\n<b>Reason:</b> {}\".format(fed_name, mention_html(user.id, user.first_name), user_target, fban_user_id, reason), \n\t\t\t\t\t\t\thtml=True)\n\t\t\"\"\"\n\n        # Fban for fed subscriber\n        subscriber = list(sql.get_subscriber(fed_id))\n        if len(subscriber) != 0:\n            for fedsid in subscriber:\n                all_fedschat = sql.all_fed_chats(fedsid)\n                for fedschat in all_fedschat:\n                    try:\n                        bot.kick_chat_member(fedschat, fban_user_id)\n                    except BadRequest as excp:\n                        if excp.message in FBAN_ERRORS:\n                            try:\n                                dispatcher.bot.getChat(fedschat)\n                            except Unauthorized:\n                                targetfed_id = sql.get_fed_id(fedschat)\n                                sql.unsubs_fed(fed_id, targetfed_id)\n                                LOGGER.info(\n                                    \"Chat {} has unsub fed {} because I was kicked\".format(\n                                        fedschat, info[\"fname\"]\n                                    )\n                                )\n                                continue\n                        elif excp.message == \"User_id_invalid\":\n                            break\n                        else:\n                            LOGGER.warning(\n                                \"Unable to fban on {} because: {}\".format(\n                                    fedschat, excp.message\n                                )\n                            )\n                    except TelegramError:\n                        pass\n    # if chats_in_fed == 0:\n    #    send_message(update.effective_message, \"Fedban affected 0 chats. \")\n    # elif chats_in_fed > 0:\n    #    send_message(update.effective_message,\n    #                 \"Fedban affected {} chats. \".format(chats_in_fed))\n\n\n@run_async\ndef unfban(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    message = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    info = sql.get_fed_info(fed_id)\n    getfednotif = sql.user_feds_report(info[\"owner\"])\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only federation admins can do this!\")\n        return\n\n    user_id = extract_user_fban(message, args)\n    if not user_id:\n        message.reply_text(\"You do not seem to be referring to a user.\")\n        return\n\n    try:\n        user_chat = bot.get_chat(user_id)\n        isvalid = True\n        fban_user_id = user_chat.id\n        fban_user_name = user_chat.first_name\n        fban_user_lname = user_chat.last_name\n        fban_user_uname = user_chat.username\n    except BadRequest as excp:\n        if not str(user_id).isdigit():\n            send_message(update.effective_message, excp.message)\n            return\n        elif len(str(user_id)) != 9:\n            send_message(update.effective_message, \"That's so not a user!\")\n            return\n        isvalid = False\n        fban_user_id = int(user_id)\n        fban_user_name = \"user({})\".format(user_id)\n        fban_user_lname = None\n        fban_user_uname = None\n\n    if isvalid and user_chat.type != \"private\":\n        message.reply_text(\"That's so not a user!\")\n        return\n\n    if isvalid:\n        user_target = mention_html(fban_user_id, fban_user_name)\n    else:\n        user_target = fban_user_name\n\n    fban, fbanreason, fbantime = sql.get_fban_user(fed_id, fban_user_id)\n    if fban is False:\n        message.reply_text(\"This user is not fbanned!\")\n        return\n\n    banner = update.effective_user\n\n    # message.reply_text(\"I'll give {} another chance in this federation\".format(user_chat.first_name))\n\n    chat_list = sql.all_fed_chats(fed_id)\n    # Will send to current chat\n    bot.send_message(\n        chat.id,\n        \"<b>Un-FedBan</b>\"\n        \"\\n<b>Federation:</b> {}\"\n        \"\\n<b>Federation Admin:</b> {}\"\n        \"\\n<b>User:</b> {}\"\n        \"\\n<b>User ID:</b> <code>{}</code>\".format(\n            info[\"fname\"],\n            mention_html(user.id, user.first_name),\n            user_target,\n            fban_user_id,\n        ),\n        parse_mode=\"HTML\",\n    )\n    # Send message to owner if fednotif is enabled\n    if getfednotif:\n        bot.send_message(\n            info[\"owner\"],\n            \"<b>Un-FedBan</b>\"\n            \"\\n<b>Federation:</b> {}\"\n            \"\\n<b>Federation Admin:</b> {}\"\n            \"\\n<b>User:</b> {}\"\n            \"\\n<b>User ID:</b> <code>{}</code>\".format(\n                info[\"fname\"],\n                mention_html(user.id, user.first_name),\n                user_target,\n                fban_user_id,\n            ),\n            parse_mode=\"HTML\",\n        )\n    # If fedlog is set, then send message, except fedlog is current chat\n    get_fedlog = sql.get_fed_log(fed_id)\n    if get_fedlog:\n        if int(get_fedlog) != int(chat.id):\n            bot.send_message(\n                get_fedlog,\n                \"<b>Un-FedBan</b>\"\n                \"\\n<b>Federation:</b> {}\"\n                \"\\n<b>Federation Admin:</b> {}\"\n                \"\\n<b>User:</b> {}\"\n                \"\\n<b>User ID:</b> <code>{}</code>\".format(\n                    info[\"fname\"],\n                    mention_html(user.id, user.first_name),\n                    user_target,\n                    fban_user_id,\n                ),\n                parse_mode=\"HTML\",\n            )\n    unfbanned_in_chats = 0\n    for fedchats in chat_list:\n        unfbanned_in_chats += 1\n        try:\n            member = bot.get_chat_member(fedchats, user_id)\n            if member.status == \"kicked\":\n                bot.unban_chat_member(fedchats, user_id)\n            # Do not spamming all fed chats\n            \"\"\"\n\t\t\tbot.send_message(chat, \"<b>Un-FedBan</b>\" \\\n\t\t\t\t\t\t \"\\n<b>Federation:</b> {}\" \\\n\t\t\t\t\t\t \"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t\t\t\t \"\\n<b>User:</b> {}\" \\\n\t\t\t\t\t\t \"\\n<b>User ID:</b> <code>{}</code>\".format(info['fname'], mention_html(user.id, user.first_name), user_target, fban_user_id), parse_mode=\"HTML\")\n\t\t\t\"\"\"\n        except BadRequest as excp:\n            if excp.message in UNFBAN_ERRORS:\n                pass\n            elif excp.message == \"User_id_invalid\":\n                break\n            else:\n                LOGGER.warning(\n                    \"Could not fban on {} because: {}\".format(chat, excp.message)\n                )\n        except TelegramError:\n            pass\n\n    try:\n        x = sql.un_fban_user(fed_id, user_id)\n        if not x:\n            send_message(\n                update.effective_message,\n                \"Un-fban failed, this user may already be un-fedbanned!\",\n            )\n            return\n    except:\n        pass\n\n    # UnFban for fed subscriber\n    subscriber = list(sql.get_subscriber(fed_id))\n    if len(subscriber) != 0:\n        for fedsid in subscriber:\n            all_fedschat = sql.all_fed_chats(fedsid)\n            for fedschat in all_fedschat:\n                try:\n                    bot.unban_chat_member(fedchats, user_id)\n                except BadRequest as excp:\n                    if excp.message in FBAN_ERRORS:\n                        try:\n                            dispatcher.bot.getChat(fedschat)\n                        except Unauthorized:\n                            targetfed_id = sql.get_fed_id(fedschat)\n                            sql.unsubs_fed(fed_id, targetfed_id)\n                            LOGGER.info(\n                                \"Chat {} has unsub fed {} because I was kicked\".format(\n                                    fedschat, info[\"fname\"]\n                                )\n                            )\n                            continue\n                    elif excp.message == \"User_id_invalid\":\n                        break\n                    else:\n                        LOGGER.warning(\n                            \"Unable to fban on {} because: {}\".format(\n                                fedschat, excp.message\n                            )\n                        )\n                except TelegramError:\n                    pass\n\n    if unfbanned_in_chats == 0:\n        send_message(\n            update.effective_message, \"This person has been un-fbanned in 0 chats.\"\n        )\n    if unfbanned_in_chats > 0:\n        send_message(\n            update.effective_message,\n            \"This person has been un-fbanned in {} chats.\".format(unfbanned_in_chats),\n        )\n    # Also do not spamming all fed admins\n    \"\"\"\n\tFEDADMIN = sql.all_fed_users(fed_id)\n\tfor x in FEDADMIN:\n\t\tgetreport = sql.user_feds_report(x)\n\t\tif getreport is False:\n\t\t\tFEDADMIN.remove(x)\n\tsend_to_list(bot, FEDADMIN,\n\t\t\t \"<b>Un-FedBan</b>\" \\\n\t\t\t \"\\n<b>Federation:</b> {}\" \\\n\t\t\t \"\\n<b>Federation Admin:</b> {}\" \\\n\t\t\t \"\\n<b>User:</b> {}\" \\\n\t\t\t \"\\n<b>User ID:</b> <code>{}</code>\".format(info['fname'], mention_html(user.id, user.first_name),\n\t\t\t\t\t\t\t\t\t\t\t\t mention_html(user_chat.id, user_chat.first_name),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  user_chat.id),\n\t\t\thtml=True)\n\t\"\"\"\n\n\n@run_async\ndef set_frules(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\"This group is not in any federation!\")\n        return\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only fed admins can do this!\")\n        return\n\n    if len(args) >= 1:\n        msg = update.effective_message\n        raw_text = msg.text\n        args = raw_text.split(None, 1)  # use python's maxsplit to separate cmd and args\n        if len(args) == 2:\n            txt = args[1]\n            offset = len(txt) - len(raw_text)  # set correct offset relative to command\n            markdown_rules = markdown_parser(\n                txt, entities=msg.parse_entities(), offset=offset\n            )\n        x = sql.set_frules(fed_id, markdown_rules)\n        if not x:\n            update.effective_message.reply_text(\n                f\"Whoa! There was an error while setting federation rules! If you wondered why please ask it in @{SUPPORT_CHAT}!\"\n            )\n            return\n\n        rules = sql.get_fed_info(fed_id)[\"frules\"]\n        getfed = sql.get_fed_info(fed_id)\n        get_fedlog = sql.get_fed_log(fed_id)\n        if get_fedlog:\n            if eval(get_fedlog):\n                bot.send_message(\n                    get_fedlog,\n                    \"*{}* has updated federation rules for fed *{}*\".format(\n                        user.first_name, getfed[\"fname\"]\n                    ),\n                    parse_mode=\"markdown\",\n                )\n        update.effective_message.reply_text(f\"Rules have been changed to :\\n{rules}!\")\n    else:\n        update.effective_message.reply_text(\"Please write rules to set this up!\")\n\n\n@run_async\ndef get_frules(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    if not fed_id:\n        update.effective_message.reply_text(\"This group is not in any federation!\")\n        return\n\n    rules = sql.get_frules(fed_id)\n    text = \"*Rules in this fed:*\\n\"\n    text += rules\n    update.effective_message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n\n\n@run_async\ndef fed_broadcast(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    msg = update.effective_message\n    user = update.effective_user\n    chat = update.effective_chat\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    if args:\n        chat = update.effective_chat\n        fed_id = sql.get_fed_id(chat.id)\n        fedinfo = sql.get_fed_info(fed_id)\n        if is_user_fed_owner(fed_id, user.id) is False:\n            update.effective_message.reply_text(\"Only federation owners can do this!\")\n            return\n        # Parsing md\n        raw_text = msg.text\n        args = raw_text.split(None, 1)  # use python's maxsplit to separate cmd and args\n        txt = args[1]\n        offset = len(txt) - len(raw_text)  # set correct offset relative to command\n        text_parser = markdown_parser(txt, entities=msg.parse_entities(), offset=offset)\n        text = text_parser\n        try:\n            broadcaster = user.first_name\n        except:\n            broadcaster = user.first_name + \" \" + user.last_name\n        text += \"\\n\\n- {}\".format(mention_markdown(user.id, broadcaster))\n        chat_list = sql.all_fed_chats(fed_id)\n        failed = 0\n        for chat in chat_list:\n            title = \"*New broadcast from Fed {}*\\n\".format(fedinfo[\"fname\"])\n            try:\n                bot.sendMessage(chat, title + text, parse_mode=\"markdown\")\n            except TelegramError:\n                try:\n                    dispatcher.bot.getChat(chat)\n                except Unauthorized:\n                    failed += 1\n                    sql.chat_leave_fed(chat)\n                    LOGGER.info(\n                        \"Chat {} has left fed {} because I was punched\".format(\n                            chat, fedinfo[\"fname\"]\n                        )\n                    )\n                    continue\n                failed += 1\n                LOGGER.warning(\"Couldn't send broadcast to {}\".format(str(chat)))\n\n        send_text = \"The federation broadcast is complete\"\n        if failed >= 1:\n            send_text += \"{} the group failed to receive the message, probably because it left the Federation.\".format(\n                failed\n            )\n        update.effective_message.reply_text(send_text)\n\n\n@run_async\ndef fed_ban_list(update: Update, context: CallbackContext):\n    bot, args, chat_data = context.bot, context.args, context.chat_data\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    info = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only Federation owners can do this!\")\n        return\n\n    user = update.effective_user\n    chat = update.effective_chat\n    getfban = sql.get_all_fban_users(fed_id)\n    if len(getfban) == 0:\n        update.effective_message.reply_text(\n            \"The federation ban list of {} is empty\".format(info[\"fname\"]),\n            parse_mode=ParseMode.HTML,\n        )\n        return\n\n    if args:\n        if args[0] == \"json\":\n            jam = time.time()\n            new_jam = jam + 1800\n            cek = get_chat(chat.id, chat_data)\n            if cek.get(\"status\"):\n                if jam <= int(cek.get(\"value\")):\n                    waktu = time.strftime(\n                        \"%H:%M:%S %d/%m/%Y\", time.localtime(cek.get(\"value\"))\n                    )\n                    update.effective_message.reply_text(\n                        \"You can backup your data once every 30 minutes!\\nYou can back up data again at `{}`\".format(\n                            waktu\n                        ),\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                    return\n                else:\n                    if user.id not in DRAGONS:\n                        put_chat(chat.id, new_jam, chat_data)\n            else:\n                if user.id not in DRAGONS:\n                    put_chat(chat.id, new_jam, chat_data)\n            backups = \"\"\n            for users in getfban:\n                getuserinfo = sql.get_all_fban_users_target(fed_id, users)\n                json_parser = {\n                    \"user_id\": users,\n                    \"first_name\": getuserinfo[\"first_name\"],\n                    \"last_name\": getuserinfo[\"last_name\"],\n                    \"user_name\": getuserinfo[\"user_name\"],\n                    \"reason\": getuserinfo[\"reason\"],\n                }\n                backups += json.dumps(json_parser)\n                backups += \"\\n\"\n            with BytesIO(str.encode(backups)) as output:\n                output.name = \"yone_fbanned_users.json\"\n                update.effective_message.reply_document(\n                    document=output,\n                    filename=\"yone_fbanned_users.json\",\n                    caption=\"Total {} User are blocked by the Federation {}.\".format(\n                        len(getfban), info[\"fname\"]\n                    ),\n                )\n            return\n        elif args[0] == \"csv\":\n            jam = time.time()\n            new_jam = jam + 1800\n            cek = get_chat(chat.id, chat_data)\n            if cek.get(\"status\"):\n                if jam <= int(cek.get(\"value\")):\n                    waktu = time.strftime(\n                        \"%H:%M:%S %d/%m/%Y\", time.localtime(cek.get(\"value\"))\n                    )\n                    update.effective_message.reply_text(\n                        \"You can back up data once every 30 minutes!\\nYou can back up data again at `{}`\".format(\n                            waktu\n                        ),\n                        parse_mode=ParseMode.MARKDOWN,\n                    )\n                    return\n                else:\n                    if user.id not in DRAGONS:\n                        put_chat(chat.id, new_jam, chat_data)\n            else:\n                if user.id not in DRAGONS:\n                    put_chat(chat.id, new_jam, chat_data)\n            backups = \"id,firstname,lastname,username,reason\\n\"\n            for users in getfban:\n                getuserinfo = sql.get_all_fban_users_target(fed_id, users)\n                backups += (\n                    \"{user_id},{first_name},{last_name},{user_name},{reason}\".format(\n                        user_id=users,\n                        first_name=getuserinfo[\"first_name\"],\n                        last_name=getuserinfo[\"last_name\"],\n                        user_name=getuserinfo[\"user_name\"],\n                        reason=getuserinfo[\"reason\"],\n                    )\n                )\n                backups += \"\\n\"\n            with BytesIO(str.encode(backups)) as output:\n                output.name = \"yone_fbanned_users.csv\"\n                update.effective_message.reply_document(\n                    document=output,\n                    filename=\"yone_fbanned_users.csv\",\n                    caption=\"Total {} User are blocked by Federation {}.\".format(\n                        len(getfban), info[\"fname\"]\n                    ),\n                )\n            return\n\n    text = \"<b>{} users have been banned from the federation {}:</b>\\n\".format(\n        len(getfban), info[\"fname\"]\n    )\n    for users in getfban:\n        getuserinfo = sql.get_all_fban_users_target(fed_id, users)\n        if getuserinfo is False:\n            text = \"There are no users banned from the federation {}\".format(\n                info[\"fname\"]\n            )\n            break\n        user_name = getuserinfo[\"first_name\"]\n        if getuserinfo[\"last_name\"]:\n            user_name += \" \" + getuserinfo[\"last_name\"]\n        text += \" ‚Ä¢ {} (<code>{}</code>)\\n\".format(\n            mention_html(users, user_name), users\n        )\n\n    try:\n        update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n    except:\n        jam = time.time()\n        new_jam = jam + 1800\n        cek = get_chat(chat.id, chat_data)\n        if cek.get(\"status\"):\n            if jam <= int(cek.get(\"value\")):\n                waktu = time.strftime(\n                    \"%H:%M:%S %d/%m/%Y\", time.localtime(cek.get(\"value\"))\n                )\n                update.effective_message.reply_text(\n                    \"You can back up data once every 30 minutes!\\nYou can back up data again at `{}`\".format(\n                        waktu\n                    ),\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n                return\n            else:\n                if user.id not in DRAGONS:\n                    put_chat(chat.id, new_jam, chat_data)\n        else:\n            if user.id not in DRAGONS:\n                put_chat(chat.id, new_jam, chat_data)\n        cleanr = re.compile(\"<.*?>\")\n        cleantext = re.sub(cleanr, \"\", text)\n        with BytesIO(str.encode(cleantext)) as output:\n            output.name = \"fbanlist.txt\"\n            update.effective_message.reply_document(\n                document=output,\n                filename=\"fbanlist.txt\",\n                caption=\"The following is a list of users who are currently fbanned in the Federation {}.\".format(\n                    info[\"fname\"]\n                ),\n            )\n\n\n@run_async\ndef fed_notif(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n    fed_id = sql.get_fed_id(chat.id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    if args:\n        if args[0] in (\"yes\", \"on\"):\n            sql.set_feds_setting(user.id, True)\n            msg.reply_text(\n                \"Reporting Federation back up! Every user who is fban / unfban you will be notified via PM.\"\n            )\n        elif args[0] in (\"no\", \"off\"):\n            sql.set_feds_setting(user.id, False)\n            msg.reply_text(\n                \"Reporting Federation has stopped! Every user who is fban / unfban you will not be notified via PM.\"\n            )\n        else:\n            msg.reply_text(\"Please enter `on`/`off`\", parse_mode=\"markdown\")\n    else:\n        getreport = sql.user_feds_report(user.id)\n        msg.reply_text(\n            \"Your current Federation report preferences: `{}`\".format(getreport),\n            parse_mode=\"markdown\",\n        )\n\n\n@run_async\ndef fed_chats(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    info = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    if is_user_fed_admin(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only federation admins can do this!\")\n        return\n\n    getlist = sql.all_fed_chats(fed_id)\n    if len(getlist) == 0:\n        update.effective_message.reply_text(\n            \"No users are fbanned from the federation {}\".format(info[\"fname\"]),\n            parse_mode=ParseMode.HTML,\n        )\n        return\n\n    text = \"<b>New chat joined the federation {}:</b>\\n\".format(info[\"fname\"])\n    for chats in getlist:\n        try:\n            chat_name = dispatcher.bot.getChat(chats).title\n        except Unauthorized:\n            sql.chat_leave_fed(chats)\n            LOGGER.info(\n                \"Chat {} has leave fed {} because I was kicked\".format(\n                    chats, info[\"fname\"]\n                )\n            )\n            continue\n        text += \" ‚Ä¢ {} (<code>{}</code>)\\n\".format(chat_name, chats)\n\n    try:\n        update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)\n    except:\n        cleanr = re.compile(\"<.*?>\")\n        cleantext = re.sub(cleanr, \"\", text)\n        with BytesIO(str.encode(cleantext)) as output:\n            output.name = \"fedchats.txt\"\n            update.effective_message.reply_document(\n                document=output,\n                filename=\"fedchats.txt\",\n                caption=\"Here is a list of all the chats that joined the federation {}.\".format(\n                    info[\"fname\"]\n                ),\n            )\n\n\n@run_async\ndef fed_import_bans(update: Update, context: CallbackContext):\n    bot, chat_data = context.bot, context.chat_data\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    info = sql.get_fed_info(fed_id)\n    getfed = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        update.effective_message.reply_text(\n            \"This group is not a part of any federation!\"\n        )\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        update.effective_message.reply_text(\"Only Federation owners can do this!\")\n        return\n\n    if msg.reply_to_message and msg.reply_to_message.document:\n        jam = time.time()\n        new_jam = jam + 1800\n        cek = get_chat(chat.id, chat_data)\n        if cek.get(\"status\"):\n            if jam <= int(cek.get(\"value\")):\n                waktu = time.strftime(\n                    \"%H:%M:%S %d/%m/%Y\", time.localtime(cek.get(\"value\"))\n                )\n                update.effective_message.reply_text(\n                    \"You can get your data once every 30 minutes!\\nYou can get data again at `{}`\".format(\n                        waktu\n                    ),\n                    parse_mode=ParseMode.MARKDOWN,\n                )\n                return\n            else:\n                if user.id not in DRAGONS:\n                    put_chat(chat.id, new_jam, chat_data)\n        else:\n            if user.id not in DRAGONS:\n                put_chat(chat.id, new_jam, chat_data)\n        # if int(int(msg.reply_to_message.document.file_size)/1024) >= 200:\n        # \tmsg.reply_text(\"This file is too big!\")\n        # \treturn\n        success = 0\n        failed = 0\n        try:\n            file_info = bot.get_file(msg.reply_to_message.document.file_id)\n        except BadRequest:\n            msg.reply_text(\n                \"Try downloading and re-uploading the file, this one seems broken!\"\n            )\n            return\n        fileformat = msg.reply_to_message.document.file_name.split(\".\")[-1]\n        if fileformat == \"json\":\n            multi_fed_id = []\n            multi_import_userid = []\n            multi_import_firstname = []\n            multi_import_lastname = []\n            multi_import_username = []\n            multi_import_reason = []\n            with BytesIO() as file:\n                file_info.download(out=file)\n                file.seek(0)\n                reading = file.read().decode(\"UTF-8\")\n                splitting = reading.split(\"\\n\")\n                for x in splitting:\n                    if x == \"\":\n                        continue\n                    try:\n                        data = json.loads(x)\n                    except json.decoder.JSONDecodeError as err:\n                        failed += 1\n                        continue\n                    try:\n                        import_userid = int(data[\"user_id\"])  # Make sure it int\n                        import_firstname = str(data[\"first_name\"])\n                        import_lastname = str(data[\"last_name\"])\n                        import_username = str(data[\"user_name\"])\n                        import_reason = str(data[\"reason\"])\n                    except ValueError:\n                        failed += 1\n                        continue\n                    # Checking user\n                    if int(import_userid) == bot.id:\n                        failed += 1\n                        continue\n                    if is_user_fed_owner(fed_id, import_userid) is True:\n                        failed += 1\n                        continue\n                    if is_user_fed_admin(fed_id, import_userid) is True:\n                        failed += 1\n                        continue\n                    if str(import_userid) == str(OWNER_ID):\n                        failed += 1\n                        continue\n                    if int(import_userid) in DRAGONS:\n                        failed += 1\n                        continue\n                    if int(import_userid) in TIGERS:\n                        failed += 1\n                        continue\n                    if int(import_userid) in WOLVES:\n                        failed += 1\n                        continue\n                    multi_fed_id.append(fed_id)\n                    multi_import_userid.append(str(import_userid))\n                    multi_import_firstname.append(import_firstname)\n                    multi_import_lastname.append(import_lastname)\n                    multi_import_username.append(import_username)\n                    multi_import_reason.append(import_reason)\n                    success += 1\n                sql.multi_fban_user(\n                    multi_fed_id,\n                    multi_import_userid,\n                    multi_import_firstname,\n                    multi_import_lastname,\n                    multi_import_username,\n                    multi_import_reason,\n                )\n            text = \"Blocks were successfully imported. {} people are blocked.\".format(\n                success\n            )\n            if failed >= 1:\n                text += \" {} Failed to import.\".format(failed)\n            get_fedlog = sql.get_fed_log(fed_id)\n            if get_fedlog:\n                if eval(get_fedlog):\n                    teks = \"Fed *{}* has successfully imported data. {} banned.\".format(\n                        getfed[\"fname\"], success\n                    )\n                    if failed >= 1:\n                        teks += \" {} Failed to import.\".format(failed)\n                    bot.send_message(get_fedlog, teks, parse_mode=\"markdown\")\n        elif fileformat == \"csv\":\n            multi_fed_id = []\n            multi_import_userid = []\n            multi_import_firstname = []\n            multi_import_lastname = []\n            multi_import_username = []\n            multi_import_reason = []\n            file_info.download(\n                \"fban_{}.csv\".format(msg.reply_to_message.document.file_id)\n            )\n            with open(\n                \"fban_{}.csv\".format(msg.reply_to_message.document.file_id),\n                \"r\",\n                encoding=\"utf8\",\n            ) as csvFile:\n                reader = csv.reader(csvFile)\n                for data in reader:\n                    try:\n                        import_userid = int(data[0])  # Make sure it int\n                        import_firstname = str(data[1])\n                        import_lastname = str(data[2])\n                        import_username = str(data[3])\n                        import_reason = str(data[4])\n                    except ValueError:\n                        failed += 1\n                        continue\n                    # Checking user\n                    if int(import_userid) == bot.id:\n                        failed += 1\n                        continue\n                    if is_user_fed_owner(fed_id, import_userid) is True:\n                        failed += 1\n                        continue\n                    if is_user_fed_admin(fed_id, import_userid) is True:\n                        failed += 1\n                        continue\n                    if str(import_userid) == str(OWNER_ID):\n                        failed += 1\n                        continue\n                    if int(import_userid) in DRAGONS:\n                        failed += 1\n                        continue\n                    if int(import_userid) in TIGERS:\n                        failed += 1\n                        continue\n                    if int(import_userid) in WOLVES:\n                        failed += 1\n                        continue\n                    multi_fed_id.append(fed_id)\n                    multi_import_userid.append(str(import_userid))\n                    multi_import_firstname.append(import_firstname)\n                    multi_import_lastname.append(import_lastname)\n                    multi_import_username.append(import_username)\n                    multi_import_reason.append(import_reason)\n                    success += 1\n                    # t = ThreadWithReturnValue(target=sql.fban_user, args=(fed_id, str(import_userid), import_firstname, import_lastname, import_username, import_reason,))\n                    # t.start()\n                sql.multi_fban_user(\n                    multi_fed_id,\n                    multi_import_userid,\n                    multi_import_firstname,\n                    multi_import_lastname,\n                    multi_import_username,\n                    multi_import_reason,\n                )\n            csvFile.close()\n            os.remove(\"fban_{}.csv\".format(msg.reply_to_message.document.file_id))\n            text = \"Files were imported successfully. {} people banned.\".format(success)\n            if failed >= 1:\n                text += \" {} Failed to import.\".format(failed)\n            get_fedlog = sql.get_fed_log(fed_id)\n            if get_fedlog:\n                if eval(get_fedlog):\n                    teks = \"Fed *{}* has successfully imported data. {} banned.\".format(\n                        getfed[\"fname\"], success\n                    )\n                    if failed >= 1:\n                        teks += \" {} Failed to import.\".format(failed)\n                    bot.send_message(get_fedlog, teks, parse_mode=\"markdown\")\n        else:\n            send_message(update.effective_message, \"This file is not supported.\")\n            return\n        send_message(update.effective_message, text)\n\n\n@run_async\ndef del_fed_button(update: Update, context: CallbackContext):\n    query = update.callback_query\n    userid = query.message.chat.id\n    fed_id = query.data.split(\"_\")[1]\n\n    if fed_id == \"cancel\":\n        query.message.edit_text(\"Federation deletion cancelled\")\n        return\n\n    getfed = sql.get_fed_info(fed_id)\n    if getfed:\n        delete = sql.del_fed(fed_id)\n        if delete:\n            query.message.edit_text(\n                \"You have removed your Federation! Now all the Groups that are connected with `{}` do not have a Federation.\".format(\n                    getfed[\"fname\"]\n                ),\n                parse_mode=\"markdown\",\n            )\n\n\n@run_async\ndef fed_stat_user(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if args:\n        if args[0].isdigit():\n            user_id = args[0]\n        else:\n            user_id = extract_user(msg, args)\n    else:\n        user_id = extract_user(msg, args)\n\n    if user_id:\n        if len(args) == 2 and args[0].isdigit():\n            fed_id = args[1]\n            user_name, reason, fbantime = sql.get_user_fban(fed_id, str(user_id))\n            if fbantime:\n                fbantime = time.strftime(\"%d/%m/%Y\", time.localtime(fbantime))\n            else:\n                fbantime = \"Unavaiable\"\n            if user_name is False:\n                send_message(\n                    update.effective_message,\n                    \"Fed {} not found!\".format(fed_id),\n                    parse_mode=\"markdown\",\n                )\n                return\n            if user_name == \"\" or user_name is None:\n                user_name = \"He/she\"\n            if not reason:\n                send_message(\n                    update.effective_message,\n                    \"{} is not banned in this federation!\".format(user_name),\n                )\n            else:\n                teks = \"{} banned in this federation because:\\n`{}`\\n*Banned at:* `{}`\".format(\n                    user_name, reason, fbantime\n                )\n                send_message(update.effective_message, teks, parse_mode=\"markdown\")\n            return\n        user_name, fbanlist = sql.get_user_fbanlist(str(user_id))\n        if user_name == \"\":\n            try:\n                user_name = bot.get_chat(user_id).first_name\n            except BadRequest:\n                user_name = \"He/she\"\n            if user_name == \"\" or user_name is None:\n                user_name = \"He/she\"\n        if len(fbanlist) == 0:\n            send_message(\n                update.effective_message,\n                \"{} is not banned in any federation!\".format(user_name),\n            )\n            return\n        else:\n            teks = \"{} has been banned in this federation:\\n\".format(user_name)\n            for x in fbanlist:\n                teks += \"- `{}`: {}\\n\".format(x[0], x[1][:20])\n            teks += \"\\nIf you want to find out more about the reasons for Fedban specifically, use /fbanstat <FedID>\"\n            send_message(update.effective_message, teks, parse_mode=\"markdown\")\n\n    elif not msg.reply_to_message and not args:\n        user_id = msg.from_user.id\n        user_name, fbanlist = sql.get_user_fbanlist(user_id)\n        if user_name == \"\":\n            user_name = msg.from_user.first_name\n        if len(fbanlist) == 0:\n            send_message(\n                update.effective_message,\n                \"{} is not banned in any federation!\".format(user_name),\n            )\n        else:\n            teks = \"{} has been banned in this federation:\\n\".format(user_name)\n            for x in fbanlist:\n                teks += \"- `{}`: {}\\n\".format(x[0], x[1][:20])\n            teks += \"\\nIf you want to find out more about the reasons for Fedban specifically, use /fbanstat <FedID>\"\n            send_message(update.effective_message, teks, parse_mode=\"markdown\")\n\n    else:\n        fed_id = args[0]\n        fedinfo = sql.get_fed_info(fed_id)\n        if not fedinfo:\n            send_message(update.effective_message, \"Fed {} not found!\".format(fed_id))\n            return\n        name, reason, fbantime = sql.get_user_fban(fed_id, msg.from_user.id)\n        if fbantime:\n            fbantime = time.strftime(\"%d/%m/%Y\", time.localtime(fbantime))\n        else:\n            fbantime = \"Unavaiable\"\n        if not name:\n            name = msg.from_user.first_name\n        if not reason:\n            send_message(\n                update.effective_message,\n                \"{} is not banned in this federation\".format(name),\n            )\n            return\n        send_message(\n            update.effective_message,\n            \"{} banned in this federation because:\\n`{}`\\n*Banned at:* `{}`\".format(\n                name, reason, fbantime\n            ),\n            parse_mode=\"markdown\",\n        )\n\n\n@run_async\ndef set_fed_log(update: Update, context: CallbackContext):\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    if args:\n        fedinfo = sql.get_fed_info(args[0])\n        if not fedinfo:\n            send_message(update.effective_message, \"This Federation does not exist!\")\n            return\n        isowner = is_user_fed_owner(args[0], user.id)\n        if not isowner:\n            send_message(\n                update.effective_message,\n                \"Only federation creator can set federation logs.\",\n            )\n            return\n        setlog = sql.set_fed_log(args[0], chat.id)\n        if setlog:\n            send_message(\n                update.effective_message,\n                \"Federation log `{}` has been set to {}\".format(\n                    fedinfo[\"fname\"], chat.title\n                ),\n                parse_mode=\"markdown\",\n            )\n    else:\n        send_message(\n            update.effective_message, \"You have not provided your federated ID!\"\n        )\n\n\n@run_async\ndef unset_fed_log(update: Update, context: CallbackContext):\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    if args:\n        fedinfo = sql.get_fed_info(args[0])\n        if not fedinfo:\n            send_message(update.effective_message, \"This Federation does not exist!\")\n            return\n        isowner = is_user_fed_owner(args[0], user.id)\n        if not isowner:\n            send_message(\n                update.effective_message,\n                \"Only federation creator can set federation logs.\",\n            )\n            return\n        setlog = sql.set_fed_log(args[0], None)\n        if setlog:\n            send_message(\n                update.effective_message,\n                \"Federation log `{}` has been revoked on {}\".format(\n                    fedinfo[\"fname\"], chat.title\n                ),\n                parse_mode=\"markdown\",\n            )\n    else:\n        send_message(\n            update.effective_message, \"You have not provided your federated ID!\"\n        )\n\n\n@run_async\ndef subs_feds(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    fedinfo = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        send_message(update.effective_message, \"This group is not in any federation!\")\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        send_message(update.effective_message, \"Only fed owner can do this!\")\n        return\n\n    if args:\n        getfed = sql.search_fed_by_id(args[0])\n        if getfed is False:\n            send_message(\n                update.effective_message, \"Please enter a valid federation id.\"\n            )\n            return\n        subfed = sql.subs_fed(args[0], fed_id)\n        if subfed:\n            send_message(\n                update.effective_message,\n                \"Federation `{}` has subscribe the federation `{}`. Every time there is a Fedban from that federation, this federation will also banned that user.\".format(\n                    fedinfo[\"fname\"], getfed[\"fname\"]\n                ),\n                parse_mode=\"markdown\",\n            )\n            get_fedlog = sql.get_fed_log(args[0])\n            if get_fedlog:\n                if int(get_fedlog) != int(chat.id):\n                    bot.send_message(\n                        get_fedlog,\n                        \"Federation `{}` has subscribe the federation `{}`\".format(\n                            fedinfo[\"fname\"], getfed[\"fname\"]\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n        else:\n            send_message(\n                update.effective_message,\n                \"Federation `{}` already subscribe the federation `{}`.\".format(\n                    fedinfo[\"fname\"], getfed[\"fname\"]\n                ),\n                parse_mode=\"markdown\",\n            )\n    else:\n        send_message(\n            update.effective_message, \"You have not provided your federated ID!\"\n        )\n\n\n@run_async\ndef unsubs_feds(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    fedinfo = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        send_message(update.effective_message, \"This group is not in any federation!\")\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        send_message(update.effective_message, \"Only fed owner can do this!\")\n        return\n\n    if args:\n        getfed = sql.search_fed_by_id(args[0])\n        if getfed is False:\n            send_message(\n                update.effective_message, \"Please enter a valid federation id.\"\n            )\n            return\n        subfed = sql.unsubs_fed(args[0], fed_id)\n        if subfed:\n            send_message(\n                update.effective_message,\n                \"Federation `{}` now unsubscribe fed `{}`.\".format(\n                    fedinfo[\"fname\"], getfed[\"fname\"]\n                ),\n                parse_mode=\"markdown\",\n            )\n            get_fedlog = sql.get_fed_log(args[0])\n            if get_fedlog:\n                if int(get_fedlog) != int(chat.id):\n                    bot.send_message(\n                        get_fedlog,\n                        \"Federation `{}` has unsubscribe fed `{}`.\".format(\n                            fedinfo[\"fname\"], getfed[\"fname\"]\n                        ),\n                        parse_mode=\"markdown\",\n                    )\n        else:\n            send_message(\n                update.effective_message,\n                \"Federation `{}` is not subscribing `{}`.\".format(\n                    fedinfo[\"fname\"], getfed[\"fname\"]\n                ),\n                parse_mode=\"markdown\",\n            )\n    else:\n        send_message(\n            update.effective_message, \"You have not provided your federated ID!\"\n        )\n\n\n@run_async\ndef get_myfedsubs(update: Update, context: CallbackContext):\n    args = context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    if chat.type == \"private\":\n        send_message(\n            update.effective_message,\n            \"This command is specific to the group, not to our pm!\",\n        )\n        return\n\n    fed_id = sql.get_fed_id(chat.id)\n    fedinfo = sql.get_fed_info(fed_id)\n\n    if not fed_id:\n        send_message(update.effective_message, \"This group is not in any federation!\")\n        return\n\n    if is_user_fed_owner(fed_id, user.id) is False:\n        send_message(update.effective_message, \"Only fed owner can do this!\")\n        return\n\n    try:\n        getmy = sql.get_mysubs(fed_id)\n    except:\n        getmy = []\n\n    if len(getmy) == 0:\n        send_message(\n            update.effective_message,\n            \"Federation `{}` is not subscribing any federation.\".format(\n                fedinfo[\"fname\"]\n            ),\n            parse_mode=\"markdown\",\n        )\n        return\n    else:\n        listfed = \"Federation `{}` is subscribing federation:\\n\".format(\n            fedinfo[\"fname\"]\n        )\n        for x in getmy:\n            listfed += \"- `{}`\\n\".format(x)\n        listfed += (\n            \"\\nTo get fed info `/fedinfo <fedid>`. To unsubscribe `/unsubfed <fedid>`.\"\n        )\n        send_message(update.effective_message, listfed, parse_mode=\"markdown\")\n\n\n@run_async\ndef get_myfeds_list(update: Update, context: CallbackContext):\n    chat = update.effective_chat\n    user = update.effective_user\n    msg = update.effective_message\n\n    fedowner = sql.get_user_owner_fed_full(user.id)\n    if fedowner:\n        text = \"*You are owner of feds:\\n*\"\n        for f in fedowner:\n            text += \"- `{}`: *{}*\\n\".format(f[\"fed_id\"], f[\"fed\"][\"fname\"])\n    else:\n        text = \"*You are not have any feds!*\"\n    send_message(update.effective_message, text, parse_mode=\"markdown\")\n\n\ndef is_user_fed_admin(fed_id, user_id):\n    fed_admins = sql.all_fed_users(fed_id)\n    if fed_admins is False:\n        return False\n    if int(user_id) in fed_admins or int(user_id) == OWNER_ID:\n        return True\n    else:\n        return False\n\n\ndef is_user_fed_owner(fed_id, user_id):\n    getsql = sql.get_fed_info(fed_id)\n    if getsql is False:\n        return False\n    getfedowner = eval(getsql[\"fusers\"])\n    if getfedowner is None or getfedowner is False:\n        return False\n    getfedowner = getfedowner[\"owner\"]\n    if str(user_id) == getfedowner or int(user_id) == OWNER_ID:\n        return True\n    else:\n        return False\n\n\n# There's no handler for this yet, but updating for v12 in case its used\n@run_async\ndef welcome_fed(update: Update, context: CallbackContext):\n    bot, args = context.bot, context.args\n    chat = update.effective_chat\n    user = update.effective_user\n    fed_id = sql.get_fed_id(chat.id)\n    fban, fbanreason, fbantime = sql.get_fban_user(fed_id, user.id)\n    if fban:\n        update.effective_message.reply_text(\n            \"This user is banned in current federation! I will remove him.\"\n        )\n        bot.kick_chat_member(chat.id, user.id)\n        return True\n    else:\n        return False\n\n\ndef __stats__():\n    all_fbanned = sql.get_all_fban_users_global()\n    all_feds = sql.get_all_feds_users_global()\n    return \"‚Ä¢ {} banned users across {} Federations\".format(\n        len(all_fbanned), len(all_feds)\n    )\n\n\ndef __user_info__(user_id, chat_id):\n    fed_id = sql.get_fed_id(chat_id)\n    if fed_id:\n        fban, fbanreason, fbantime = sql.get_fban_user(fed_id, user_id)\n        info = sql.get_fed_info(fed_id)\n        infoname = info[\"fname\"]\n\n        if int(info[\"owner\"]) == user_id:\n            text = \"Federation owner of: <b>{}</b>.\".format(infoname)\n        elif is_user_fed_admin(fed_id, user_id):\n            text = \"Federation admin of: <b>{}</b>.\".format(infoname)\n\n        elif fban:\n            text = \"Federation banned: <b>Yes</b>\"\n            text += \"\\n<b>Reason:</b> {}\".format(fbanreason)\n        else:\n            text = \"Federation banned: <b>No</b>\"\n    else:\n        text = \"\"\n    return text\n\n\n# Temporary data\ndef put_chat(chat_id, value, chat_data):\n    # print(chat_data)\n    if value is False:\n        status = False\n    else:\n        status = True\n    chat_data[chat_id] = {\"federation\": {\"status\": status, \"value\": value}}\n\n\ndef get_chat(chat_id, chat_data):\n    # print(chat_data)\n    try:\n        value = chat_data[chat_id][\"federation\"]\n        return value\n    except KeyError:\n        return {\"status\": False, \"value\": False}\n\n\n@run_async\ndef fed_owner_help(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(\n        \"\"\"*üëë Fed Owner Only:*\n ‚Ä¢ `/newfed <fed_name>`*:* Creates a Federation, One allowed per user\n ‚Ä¢ `/renamefed <fed_id> <new_fed_name>`*:* Renames the fed id to a new name\n ‚Ä¢ `/delfed <fed_id>`*:* Delete a Federation, and any information related to it. Will not cancel blocked users\n ‚Ä¢ `/fpromote <user>`*:* Assigns the user as a federation admin. Enables all commands for the user under `Fed Admins`\n ‚Ä¢ `/fdemote <user>`*:* Drops the User from the admin Federation to a normal User\n ‚Ä¢ `/subfed <fed_id>`*:* Subscribes to a given fed ID, bans from that subscribed fed will also happen in your fed\n ‚Ä¢ `/unsubfed <fed_id>`*:* Unsubscribes to a given fed ID\n ‚Ä¢ `/setfedlog <fed_id>`*:* Sets the group as a fed log report base for the federation\n ‚Ä¢ `/unsetfedlog <fed_id>`*:* Removed the group as a fed log report base for the federation\n ‚Ä¢ `/fbroadcast <message>`*:* Broadcasts a messages to all groups that have joined your fed\n ‚Ä¢ `/fedsubs`*:* Shows the feds your group is subscribed to `(broken rn)`\"\"\",\n        parse_mode=ParseMode.MARKDOWN,\n    )\n\n\n@run_async\ndef fed_admin_help(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(\n        \"\"\"*üî± Fed Admins:*\n ‚Ä¢ `/fban <user> <reason>`*:* Fed bans a user\n ‚Ä¢ `/unfban <user> <reason>`*:* Removes a user from a fed ban\n ‚Ä¢ `/fedinfo <fed_id>`*:* Information about the specified Federation\n ‚Ä¢ `/joinfed <fed_id>`*:* Join the current chat to the Federation. Only chat owners can do this. Every chat can only be in one Federation\n ‚Ä¢ `/leavefed <fed_id>`*:* Leave the Federation given. Only chat owners can do this\n ‚Ä¢ `/setfrules <rules>`*:* Arrange Federation rules\n ‚Ä¢ `/fedadmins`*:* Show Federation admin\n ‚Ä¢ `/fbanlist`*:* Displays all users who are victimized at the Federation at this time\n ‚Ä¢ `/fedchats`*:* Get all the chats that are connected in the Federation\n ‚Ä¢ `/chatfed `*:* See the Federation in the current chat\\n\"\"\",\n        parse_mode=ParseMode.MARKDOWN,\n    )\n\n\n@run_async\ndef fed_user_help(update: Update, context: CallbackContext):\n    update.effective_message.reply_text(\n        \"\"\"*üé© Any user:*\n ‚Ä¢ `/fbanstat`*:* Shows if you/or the user you are replying to or their username is fbanned somewhere or not\n ‚Ä¢ `/fednotif <on/off>`*:* Federation settings not in PM when there are users who are fbaned/unfbanned\n ‚Ä¢ `/frules`*:* See Federation regulations\\n\"\"\",\n        parse_mode=ParseMode.MARKDOWN,\n    )\n\n\n__mod_name__ = \"Feds\"\n\n__help__ = \"\"\"\nEverything is fun, until a spammer starts entering your group, and you have to block it. Then you need to start banning more, and more, and it hurts.\nBut then you have many groups, and you don't want this spammer to be in one of your groups - how can you deal? Do you have to manually block it, in all your groups?\\n\n*No longer!* With Federation, you can make a ban in one chat overlap with all other chats.\\n\nYou can even designate federation admins, so your trusted admin can ban all the spammers from chats you want to protect.\\n\n\n*Commands:*\\n\nFeds are now divided into 3 sections for your ease. \n‚ùç /fedownerhelp*:* Provides help for fed creation and owner only commands\n‚ùç /fedadminhelp*:* Provides help for fed administration commands\n‚ùç /feduserhelp*:* Provides help for commands anyone can use\n\n\"\"\"\n\nNEW_FED_HANDLER = CommandHandler(\"newfed\", new_fed)\nDEL_FED_HANDLER = CommandHandler(\"delfed\", del_fed)\nRENAME_FED = CommandHandler(\"renamefed\", rename_fed)\nJOIN_FED_HANDLER = CommandHandler(\"joinfed\", join_fed)\nLEAVE_FED_HANDLER = CommandHandler(\"leavefed\", leave_fed)\nPROMOTE_FED_HANDLER = CommandHandler(\"fpromote\", user_join_fed)\nDEMOTE_FED_HANDLER = CommandHandler(\"fdemote\", user_demote_fed)\nINFO_FED_HANDLER = CommandHandler(\"fedinfo\", fed_info)\nBAN_FED_HANDLER = DisableAbleCommandHandler(\"fban\", fed_ban)\nUN_BAN_FED_HANDLER = CommandHandler(\"unfban\", unfban)\nFED_BROADCAST_HANDLER = CommandHandler(\"fbroadcast\", fed_broadcast)\nFED_SET_RULES_HANDLER = CommandHandler(\"setfrules\", set_frules)\nFED_GET_RULES_HANDLER = CommandHandler(\"frules\", get_frules)\nFED_CHAT_HANDLER = CommandHandler(\"chatfed\", fed_chat)\nFED_ADMIN_HANDLER = CommandHandler(\"fedadmins\", fed_admin)\nFED_USERBAN_HANDLER = CommandHandler(\"fbanlist\", fed_ban_list)\nFED_NOTIF_HANDLER = CommandHandler(\"fednotif\", fed_notif)\nFED_CHATLIST_HANDLER = CommandHandler(\"fedchats\", fed_chats)\nFED_IMPORTBAN_HANDLER = CommandHandler(\"importfbans\", fed_import_bans)\nFEDSTAT_USER = DisableAbleCommandHandler([\"fedstat\", \"fbanstat\"], fed_stat_user)\nSET_FED_LOG = CommandHandler(\"setfedlog\", set_fed_log)\nUNSET_FED_LOG = CommandHandler(\"unsetfedlog\", unset_fed_log)\nSUBS_FED = CommandHandler(\"subfed\", subs_feds)\nUNSUBS_FED = CommandHandler(\"unsubfed\", unsubs_feds)\nMY_SUB_FED = CommandHandler(\"fedsubs\", get_myfedsubs)\nMY_FEDS_LIST = CommandHandler(\"myfeds\", get_myfeds_list)\nDELETEBTN_FED_HANDLER = CallbackQueryHandler(del_fed_button, pattern=r\"rmfed_\")\nFED_OWNER_HELP_HANDLER = CommandHandler(\"fedownerhelp\", fed_owner_help)\nFED_ADMIN_HELP_HANDLER = CommandHandler(\"fedadminhelp\", fed_admin_help)\nFED_USER_HELP_HANDLER = CommandHandler(\"feduserhelp\", fed_user_help)\n\ndispatcher.add_handler(NEW_FED_HANDLER)\ndispatcher.add_handler(DEL_FED_HANDLER)\ndispatcher.add_handler(RENAME_FED)\ndispatcher.add_handler(JOIN_FED_HANDLER)\ndispatcher.add_handler(LEAVE_FED_HANDLER)\ndispatcher.add_handler(PROMOTE_FED_HANDLER)\ndispatcher.add_handler(DEMOTE_FED_HANDLER)\ndispatcher.add_handler(INFO_FED_HANDLER)\ndispatcher.add_handler(BAN_FED_HANDLER)\ndispatcher.add_handler(UN_BAN_FED_HANDLER)\ndispatcher.add_handler(FED_BROADCAST_HANDLER)\ndispatcher.add_handler(FED_SET_RULES_HANDLER)\ndispatcher.add_handler(FED_GET_RULES_HANDLER)\ndispatcher.add_handler(FED_CHAT_HANDLER)\ndispatcher.add_handler(FED_ADMIN_HANDLER)\ndispatcher.add_handler(FED_USERBAN_HANDLER)\ndispatcher.add_handler(FED_NOTIF_HANDLER)\ndispatcher.add_handler(FED_CHATLIST_HANDLER)\n# dispatcher.add_handler(FED_IMPORTBAN_HANDLER)\ndispatcher.add_handler(FEDSTAT_USER)\ndispatcher.add_handler(SET_FED_LOG)\ndispatcher.add_handler(UNSET_FED_LOG)\ndispatcher.add_handler(SUBS_FED)\ndispatcher.add_handler(UNSUBS_FED)\ndispatcher.add_handler(MY_SUB_FED)\ndispatcher.add_handler(MY_FEDS_LIST)\ndispatcher.add_handler(DELETEBTN_FED_HANDLER)\ndispatcher.add_handler(FED_OWNER_HELP_HANDLER)\ndispatcher.add_handler(FED_ADMIN_HELP_HANDLER)\ndispatcher.add_handler(FED_USER_HELP_HANDLER)\n","size_bytes":89005},"sitaBot/modules/sql/users_sql.py":{"content":"import threading\n\nfrom sitaBot import dispatcher\nfrom sitaBot.modules.sql import BASE, SESSION\nfrom sqlalchemy import (\n    Column,\n    ForeignKey,\n    Integer,\n    BigInteger,\n    String,\n    UnicodeText,\n    UniqueConstraint,\n    func,\n)\n\n\nclass Users(BASE):\n    __tablename__ = \"users\"\n    user_id = Column(BigInteger, primary_key=True)\n    username = Column(UnicodeText)\n\n    def __init__(self, user_id, username=None):\n        self.user_id = user_id\n        self.username = username\n\n    def __repr__(self):\n        return \"<User {} ({})>\".format(self.username, self.user_id)\n\n\nclass Chats(BASE):\n    __tablename__ = \"chats\"\n    chat_id = Column(String(14), primary_key=True)\n    chat_name = Column(UnicodeText, nullable=False)\n\n    def __init__(self, chat_id, chat_name):\n        self.chat_id = str(chat_id)\n        self.chat_name = chat_name\n\n    def __repr__(self):\n        return \"<Chat {} ({})>\".format(self.chat_name, self.chat_id)\n\n\nclass ChatMembers(BASE):\n    __tablename__ = \"chat_members\"\n    priv_chat_id = Column(Integer, primary_key=True)\n    # NOTE: Use dual primary key instead of private primary key?\n    chat = Column(\n        String(14),\n        ForeignKey(\"chats.chat_id\", onupdate=\"CASCADE\", ondelete=\"CASCADE\"),\n        nullable=False,\n    )\n    user = Column(\n        BigInteger,\n        ForeignKey(\"users.user_id\", onupdate=\"CASCADE\", ondelete=\"CASCADE\"),\n        nullable=False,\n    )\n    __table_args__ = (UniqueConstraint(\"chat\", \"user\", name=\"_chat_members_uc\"),)\n\n    def __init__(self, chat, user):\n        self.chat = chat\n        self.user = user\n\n    def __repr__(self):\n        return \"<Chat user {} ({}) in chat {} ({})>\".format(\n            self.user.username,\n            self.user.user_id,\n            self.chat.chat_name,\n            self.chat.chat_id,\n        )\n\n\nUsers.__table__.create(checkfirst=True)\nChats.__table__.create(checkfirst=True)\nChatMembers.__table__.create(checkfirst=True)\n\nINSERTION_LOCK = threading.RLock()\n\n\ndef ensure_bot_in_db():\n    with INSERTION_LOCK:\n        bot = Users(dispatcher.bot.id, dispatcher.bot.username)\n        SESSION.merge(bot)\n        SESSION.commit()\n\n\ndef update_user(user_id, username, chat_id=None, chat_name=None):\n    with INSERTION_LOCK:\n        user = SESSION.query(Users).get(user_id)\n        if not user:\n            user = Users(user_id, username)\n            SESSION.add(user)\n            SESSION.flush()\n        else:\n            user.username = username\n\n        if not chat_id or not chat_name:\n            SESSION.commit()\n            return\n\n        chat = SESSION.query(Chats).get(str(chat_id))\n        if not chat:\n            chat = Chats(str(chat_id), chat_name)\n            SESSION.add(chat)\n            SESSION.flush()\n\n        else:\n            chat.chat_name = chat_name\n\n        member = (\n            SESSION.query(ChatMembers)\n            .filter(ChatMembers.chat == chat.chat_id, ChatMembers.user == user.user_id)\n            .first()\n        )\n        if not member:\n            chat_member = ChatMembers(chat.chat_id, user.user_id)\n            SESSION.add(chat_member)\n\n        SESSION.commit()\n\n\ndef get_userid_by_name(username):\n    try:\n        return (\n            SESSION.query(Users)\n            .filter(func.lower(Users.username) == username.lower())\n            .all()\n        )\n    finally:\n        SESSION.close()\n\n\ndef get_name_by_userid(user_id):\n    try:\n        return SESSION.query(Users).get(Users.user_id == int(user_id)).first()\n    finally:\n        SESSION.close()\n\n\ndef get_chat_members(chat_id):\n    try:\n        return SESSION.query(ChatMembers).filter(ChatMembers.chat == str(chat_id)).all()\n    finally:\n        SESSION.close()\n\n\ndef get_all_chats():\n    try:\n        return SESSION.query(Chats).all()\n    finally:\n        SESSION.close()\n\n\ndef get_all_users():\n    try:\n        return SESSION.query(Users).all()\n    finally:\n        SESSION.close()\n\n\ndef get_user_num_chats(user_id):\n    try:\n        return (\n            SESSION.query(ChatMembers).filter(ChatMembers.user == int(user_id)).count()\n        )\n    finally:\n        SESSION.close()\n\n\ndef get_user_com_chats(user_id):\n    try:\n        chat_members = (\n            SESSION.query(ChatMembers).filter(ChatMembers.user == int(user_id)).all()\n        )\n        return [i.chat for i in chat_members]\n    finally:\n        SESSION.close()\n\n\ndef num_chats():\n    try:\n        return SESSION.query(Chats).count()\n    finally:\n        SESSION.close()\n\n\ndef num_users():\n    try:\n        return SESSION.query(Users).count()\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with INSERTION_LOCK:\n        chat = SESSION.query(Chats).get(str(old_chat_id))\n        if chat:\n            chat.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n        chat_members = (\n            SESSION.query(ChatMembers)\n            .filter(ChatMembers.chat == str(old_chat_id))\n            .all()\n        )\n        for member in chat_members:\n            member.chat = str(new_chat_id)\n        SESSION.commit()\n\n\nensure_bot_in_db()\n\n\ndef del_user(user_id):\n    with INSERTION_LOCK:\n        curr = SESSION.query(Users).get(user_id)\n        if curr:\n            SESSION.delete(curr)\n            SESSION.commit()\n            return True\n\n        ChatMembers.query.filter(ChatMembers.user == user_id).delete()\n        SESSION.commit()\n        SESSION.close()\n    return False\n\n\ndef rem_chat(chat_id):\n    with INSERTION_LOCK:\n        chat = SESSION.query(Chats).get(str(chat_id))\n        if chat:\n            SESSION.delete(chat)\n            SESSION.commit()\n        else:\n            SESSION.close()\n","size_bytes":5610},"sitaBot/modules/sql/locks_sql.py":{"content":"# New chat added -> setup permissions\nimport threading\n\nfrom sqlalchemy import Column, String, Boolean\n\nfrom sitaBot.modules.sql import SESSION, BASE\n\n\nclass Permissions(BASE):\n    __tablename__ = \"permissions\"\n    chat_id = Column(String(14), primary_key=True)\n    # Booleans are for \"is this locked\", _NOT_ \"is this allowed\"\n    audio = Column(Boolean, default=False)\n    voice = Column(Boolean, default=False)\n    contact = Column(Boolean, default=False)\n    video = Column(Boolean, default=False)\n    document = Column(Boolean, default=False)\n    photo = Column(Boolean, default=False)\n    sticker = Column(Boolean, default=False)\n    gif = Column(Boolean, default=False)\n    url = Column(Boolean, default=False)\n    bots = Column(Boolean, default=False)\n    forward = Column(Boolean, default=False)\n    game = Column(Boolean, default=False)\n    location = Column(Boolean, default=False)\n    rtl = Column(Boolean, default=False)\n    button = Column(Boolean, default=False)\n    egame = Column(Boolean, default=False)\n    inline = Column(Boolean, default=False)\n\n    def __init__(self, chat_id):\n        self.chat_id = str(chat_id)  # ensure string\n        self.audio = False\n        self.voice = False\n        self.contact = False\n        self.video = False\n        self.document = False\n        self.photo = False\n        self.sticker = False\n        self.gif = False\n        self.url = False\n        self.bots = False\n        self.forward = False\n        self.game = False\n        self.location = False\n        self.rtl = False\n        self.button = False\n        self.egame = False\n        self.inline = False\n\n    def __repr__(self):\n        return \"<Permissions for %s>\" % self.chat_id\n\n\nclass Restrictions(BASE):\n    __tablename__ = \"restrictions\"\n    chat_id = Column(String(14), primary_key=True)\n    # Booleans are for \"is this restricted\", _NOT_ \"is this allowed\"\n    messages = Column(Boolean, default=False)\n    media = Column(Boolean, default=False)\n    other = Column(Boolean, default=False)\n    preview = Column(Boolean, default=False)\n\n    def __init__(self, chat_id):\n        self.chat_id = str(chat_id)  # ensure string\n        self.messages = False\n        self.media = False\n        self.other = False\n        self.preview = False\n\n    def __repr__(self):\n        return \"<Restrictions for %s>\" % self.chat_id\n\n\n# For those who faced database error, Just uncomment the\n# line below and run bot for 1 time & remove that line!\n\nPermissions.__table__.create(checkfirst=True)\n# Permissions.__table__.drop()\nRestrictions.__table__.create(checkfirst=True)\n\nPERM_LOCK = threading.RLock()\nRESTR_LOCK = threading.RLock()\n\n\ndef init_permissions(chat_id, reset=False):\n    curr_perm = SESSION.query(Permissions).get(str(chat_id))\n    if reset:\n        SESSION.delete(curr_perm)\n        SESSION.flush()\n    perm = Permissions(str(chat_id))\n    SESSION.add(perm)\n    SESSION.commit()\n    return perm\n\n\ndef init_restrictions(chat_id, reset=False):\n    curr_restr = SESSION.query(Restrictions).get(str(chat_id))\n    if reset:\n        SESSION.delete(curr_restr)\n        SESSION.flush()\n    restr = Restrictions(str(chat_id))\n    SESSION.add(restr)\n    SESSION.commit()\n    return restr\n\n\ndef update_lock(chat_id, lock_type, locked):\n    with PERM_LOCK:\n        curr_perm = SESSION.query(Permissions).get(str(chat_id))\n        if not curr_perm:\n            curr_perm = init_permissions(chat_id)\n\n        if lock_type == \"audio\":\n            curr_perm.audio = locked\n        elif lock_type == \"voice\":\n            curr_perm.voice = locked\n        elif lock_type == \"contact\":\n            curr_perm.contact = locked\n        elif lock_type == \"video\":\n            curr_perm.video = locked\n        elif lock_type == \"document\":\n            curr_perm.document = locked\n        elif lock_type == \"photo\":\n            curr_perm.photo = locked\n        elif lock_type == \"sticker\":\n            curr_perm.sticker = locked\n        elif lock_type == \"gif\":\n            curr_perm.gif = locked\n        elif lock_type == \"url\":\n            curr_perm.url = locked\n        elif lock_type == \"bots\":\n            curr_perm.bots = locked\n        elif lock_type == \"forward\":\n            curr_perm.forward = locked\n        elif lock_type == \"game\":\n            curr_perm.game = locked\n        elif lock_type == \"location\":\n            curr_perm.location = locked\n        elif lock_type == \"rtl\":\n            curr_perm.rtl = locked\n        elif lock_type == \"button\":\n            curr_perm.button = locked\n        elif lock_type == \"egame\":\n            curr_perm.egame = locked\n        elif lock_type == \"inline\":\n            curr_perm.inline = locked\n\n        SESSION.add(curr_perm)\n        SESSION.commit()\n\n\ndef update_restriction(chat_id, restr_type, locked):\n    with RESTR_LOCK:\n        curr_restr = SESSION.query(Restrictions).get(str(chat_id))\n        if not curr_restr:\n            curr_restr = init_restrictions(chat_id)\n\n        if restr_type == \"messages\":\n            curr_restr.messages = locked\n        elif restr_type == \"media\":\n            curr_restr.media = locked\n        elif restr_type == \"other\":\n            curr_restr.other = locked\n        elif restr_type == \"previews\":\n            curr_restr.preview = locked\n        elif restr_type == \"all\":\n            curr_restr.messages = locked\n            curr_restr.media = locked\n            curr_restr.other = locked\n            curr_restr.preview = locked\n        SESSION.add(curr_restr)\n        SESSION.commit()\n\n\ndef is_locked(chat_id, lock_type):\n    curr_perm = SESSION.query(Permissions).get(str(chat_id))\n    SESSION.close()\n\n    if not curr_perm:\n        return False\n\n    elif lock_type == \"sticker\":\n        return curr_perm.sticker\n    elif lock_type == \"photo\":\n        return curr_perm.photo\n    elif lock_type == \"audio\":\n        return curr_perm.audio\n    elif lock_type == \"voice\":\n        return curr_perm.voice\n    elif lock_type == \"contact\":\n        return curr_perm.contact\n    elif lock_type == \"video\":\n        return curr_perm.video\n    elif lock_type == \"document\":\n        return curr_perm.document\n    elif lock_type == \"gif\":\n        return curr_perm.gif\n    elif lock_type == \"url\":\n        return curr_perm.url\n    elif lock_type == \"bots\":\n        return curr_perm.bots\n    elif lock_type == \"forward\":\n        return curr_perm.forward\n    elif lock_type == \"game\":\n        return curr_perm.game\n    elif lock_type == \"location\":\n        return curr_perm.location\n    elif lock_type == \"rtl\":\n        return curr_perm.rtl\n    elif lock_type == \"button\":\n        return curr_perm.button\n    elif lock_type == \"egame\":\n        return curr_perm.egame\n    elif lock_type == \"inline\":\n        return curr_perm.inline\n\n\ndef is_restr_locked(chat_id, lock_type):\n    curr_restr = SESSION.query(Restrictions).get(str(chat_id))\n    SESSION.close()\n\n    if not curr_restr:\n        return False\n\n    if lock_type == \"messages\":\n        return curr_restr.messages\n    elif lock_type == \"media\":\n        return curr_restr.media\n    elif lock_type == \"other\":\n        return curr_restr.other\n    elif lock_type == \"previews\":\n        return curr_restr.preview\n    elif lock_type == \"all\":\n        return (\n            curr_restr.messages\n            and curr_restr.media\n            and curr_restr.other\n            and curr_restr.preview\n        )\n\n\ndef get_locks(chat_id):\n    try:\n        return SESSION.query(Permissions).get(str(chat_id))\n    finally:\n        SESSION.close()\n\n\ndef get_restr(chat_id):\n    try:\n        return SESSION.query(Restrictions).get(str(chat_id))\n    finally:\n        SESSION.close()\n\n\ndef migrate_chat(old_chat_id, new_chat_id):\n    with PERM_LOCK:\n        perms = SESSION.query(Permissions).get(str(old_chat_id))\n        if perms:\n            perms.chat_id = str(new_chat_id)\n        SESSION.commit()\n\n    with RESTR_LOCK:\n        rest = SESSION.query(Restrictions).get(str(old_chat_id))\n        if rest:\n            rest.chat_id = str(new_chat_id)\n        SESSION.commit()\n","size_bytes":7977}},"version":2}