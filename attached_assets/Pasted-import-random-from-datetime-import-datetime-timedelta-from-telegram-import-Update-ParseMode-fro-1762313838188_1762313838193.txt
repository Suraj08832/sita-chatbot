import random
from datetime import datetime, timedelta
from telegram import Update, ParseMode
from telegram.ext import CallbackContext, CommandHandler, run_async
from sita import dispatcher
from sita.modules.helper_funcs.chat_status import user_admin
from sita.modules.sql import economy_sql as sql

# Item prices and details
ITEMS = {
    "rose": {"emoji": "ğŸŒ¹", "price": 500, "name": "Rose"},
    "chocolate": {"emoji": "ğŸ«", "price": 800, "name": "Chocolate"},
    "ring": {"emoji": "ğŸ’", "price": 2000, "name": "Ring"},
    "teddy": {"emoji": "ğŸ§¸", "price": 1500, "name": "Teddy Bear"},
    "pizza": {"emoji": "ğŸ•", "price": 600, "name": "Pizza"},
    "surprise": {"emoji": "ğŸ", "price": 2500, "name": "Surprise Box"},
    "puppy": {"emoji": "ğŸ¶", "price": 3000, "name": "Puppy"},
    "cake": {"emoji": "ğŸ‚", "price": 1000, "name": "Cake"},
    "letter": {"emoji": "ğŸ’Œ", "price": 400, "name": "Love Letter"},
    "cat": {"emoji": "ğŸ±", "price": 2500, "name": "Cat"},
}


@run_async
def balance(update: Update, context: CallbackContext):
    """Show user balance"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if message.reply_to_message:
        target_user = message.reply_to_message.from_user
        user_id = target_user.id
        name = target_user.first_name
    else:
        user_id = user.id
        name = user.first_name
    
    balance = sql.get_balance(user_id, chat.id)
    message.reply_text(f"ğŸ’° {name}'s Balance: ${balance}")


@run_async
def top_rich(update: Update, context: CallbackContext):
    """Show top 10 richest users"""
    users = sql.get_top_rich(10)
    
    if not users:
        update.effective_message.reply_text("ğŸ“Š No economy data yet!")
        return
    
    text = "ğŸŒ <b>Top 10 Richest Users</b>\n\n"
    for i, user_eco in enumerate(users, 1):
        medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰" if i == 3 else f"{i}."
        text += f"{medal} User {user_eco.user_id}: ${user_eco.balance}\n"
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


@run_async
def top_killers(update: Update, context: CallbackContext):
    """Show top 10 killers"""
    users = sql.get_top_killers(10)
    
    if not users:
        update.effective_message.reply_text("âš”ï¸ No kill data yet!")
        return
    
    text = "â˜ ï¸ <b>Top 10 Killers</b>\n\n"
    for i, user_eco in enumerate(users, 1):
        if user_eco.kills == 0:
            continue
        medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰" if i == 3 else f"{i}."
        text += f"{medal} User {user_eco.user_id}: {user_eco.kills} kills\n"
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


@run_async
def my_rank(update: Update, context: CallbackContext):
    """Show user's global rank"""
    user = update.effective_user
    chat = update.effective_chat
    
    rank = sql.get_user_rank(user.id, chat.id)
    balance = sql.get_balance(user.id, chat.id)
    
    if rank:
        update.effective_message.reply_text(f"ğŸ† Your Global Rank: #{rank}\nğŸ’° Balance: ${balance}")
    else:
        update.effective_message.reply_text("You haven't joined the economy yet!")


@run_async
def rob(update: Update, context: CallbackContext):
    """Rob another user"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if not message.reply_to_message:
        message.reply_text("âŒ Reply to a user to rob them!")
        return
    
    target = message.reply_to_message.from_user
    
    if target.id == user.id:
        message.reply_text("âŒ You can't rob yourself!")
        return
    
    if target.is_bot:
        message.reply_text("âŒ You can't rob bots!")
        return
    
    # Check if robber is dead
    if sql.is_dead(user.id, chat.id):
        message.reply_text("ğŸ’€ You're dead! Use /revive to come back.")
        return
    
    # Check if target is protected
    if sql.is_protected(target.id, chat.id):
        message.reply_text("ğŸ›¡ï¸ This user is protected!")
        return
    
    # Check if target is dead
    if sql.is_dead(target.id, chat.id):
        message.reply_text("ğŸ’€ They're already dead!")
        return
    
    # Get amount from args
    if context.args:
        try:
            amount = int(context.args[0].replace("$", "").replace(",", ""))
        except ValueError:
            message.reply_text("âŒ Invalid amount!")
            return
    else:
        message.reply_text("âŒ Usage: /rob <amount> (reply to user)")
        return
    
    if amount <= 0:
        message.reply_text("âŒ Amount must be positive!")
        return
    
    target_balance = sql.get_balance(target.id, chat.id)
    
    if target_balance < amount:
        message.reply_text(f"âŒ They don't have ${amount}!")
        return
    
    # 50% success rate
    success = random.choice([True, False])
    
    if success:
        sql.update_balance(user.id, chat.id, amount)
        sql.update_balance(target.id, chat.id, -amount)
        message.reply_text(f"ğŸ¦¹â€â™‚ï¸ Success! You robbed ${amount} from {target.first_name}!")
    else:
        # Failed rob - pay 25% of attempted amount
        penalty = amount // 4
        robber_balance = sql.get_balance(user.id, chat.id)
        
        if robber_balance >= penalty:
            sql.update_balance(user.id, chat.id, -penalty)
            sql.update_balance(target.id, chat.id, penalty)
            message.reply_text(f"âŒ Rob failed! You paid ${penalty} to {target.first_name}!")
        else:
            message.reply_text(f"âŒ Rob failed! You don't have enough for the penalty.")


@run_async
def kill(update: Update, context: CallbackContext):
    """Kill another user"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if not message.reply_to_message:
        message.reply_text("âŒ Reply to a user to kill them!")
        return
    
    target = message.reply_to_message.from_user
    
    if target.id == user.id:
        message.reply_text("âŒ You can't kill yourself!")
        return
    
    if target.is_bot:
        message.reply_text("âŒ You can't kill bots!")
        return
    
    # Check if killer is dead
    if sql.is_dead(user.id, chat.id):
        message.reply_text("ğŸ’€ You're dead! Use /revive to come back.")
        return
    
    # Check if target is protected
    if sql.is_protected(target.id, chat.id):
        message.reply_text("ğŸ›¡ï¸ This user is protected!")
        return
    
    # Check if target is already dead
    if sql.is_dead(target.id, chat.id):
        message.reply_text("ğŸ’€ They're already dead!")
        return
    
    # 60% success rate
    success = random.random() < 0.6
    
    if success:
        sql.kill_user(target.id, chat.id, user.id)
        # Steal 10% of their money
        target_balance = sql.get_balance(target.id, chat.id)
        stolen = target_balance // 10
        if stolen > 0:
            sql.update_balance(target.id, chat.id, -stolen)
            sql.update_balance(user.id, chat.id, stolen)
            message.reply_text(f"ğŸ’€ You killed {target.first_name} and stole ${stolen}!\n\nThey can /revive or wait 5 hours.")
        else:
            message.reply_text(f"ğŸ’€ You killed {target.first_name}!\n\nThey can /revive or wait 5 hours.")
    else:
        message.reply_text(f"âŒ Kill attempt failed! {target.first_name} got away.")


@run_async
def revive(update: Update, context: CallbackContext):
    """Revive yourself or another user"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if message.reply_to_message:
        target = message.reply_to_message.from_user
        user_id = target.id
        name = target.first_name
    else:
        user_id = user.id
        name = user.first_name
    
    if not sql.is_dead(user_id, chat.id):
        message.reply_text(f"â¤ï¸ {name} is not dead!")
        return
    
    # Revive costs $200
    cost = 200
    payer_balance = sql.get_balance(user.id, chat.id)
    
    if payer_balance < cost:
        message.reply_text(f"âŒ Revive costs ${cost}. You only have ${payer_balance}.")
        return
    
    sql.update_balance(user.id, chat.id, -cost)
    sql.revive_user(user_id, chat.id)
    message.reply_text(f"â¤ï¸ {name} has been revived! Cost: ${cost}")


@run_async
def protect(update: Update, context: CallbackContext):
    """Protect yourself from rob/kill"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if not context.args:
        message.reply_text("âŒ Usage: /protect <1d|2d>\n\nğŸ›¡ï¸ Protection Prices:\n1 day = $100\n2 days = $500")
        return
    
    duration = context.args[0].lower()
    
    if duration == "1d":
        cost = 100
        days = 1
    elif duration == "2d":
        cost = 500
        days = 2
    else:
        message.reply_text("âŒ Use: /protect 1d or /protect 2d")
        return
    
    balance = sql.get_balance(user.id, chat.id)
    
    if balance < cost:
        message.reply_text(f"âŒ Protection costs ${cost}. You only have ${balance}.")
        return
    
    sql.update_balance(user.id, chat.id, -cost)
    sql.protect_user(user.id, chat.id, days)
    message.reply_text(f"ğŸ›¡ï¸ You are protected for {days} day(s)! Cost: ${cost}")


@run_async
def give_money(update: Update, context: CallbackContext):
    """Give money to another user (with 10% tax)"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if not message.reply_to_message:
        message.reply_text("âŒ Reply to a user to give them money!")
        return
    
    target = message.reply_to_message.from_user
    
    if target.id == user.id:
        message.reply_text("âŒ You can't give money to yourself!")
        return
    
    if not context.args:
        message.reply_text("âŒ Usage: /give <amount> (reply to user)\n\nâš ï¸ Note: 10% tax will be deducted!")
        return
    
    try:
        amount = int(context.args[0].replace("$", "").replace(",", ""))
    except ValueError:
        message.reply_text("âŒ Invalid amount!")
        return
    
    if amount <= 0:
        message.reply_text("âŒ Amount must be positive!")
        return
    
    # Calculate tax (10%)
    tax = amount // 10
    total_cost = amount + tax
    
    balance = sql.get_balance(user.id, chat.id)
    
    if balance < total_cost:
        message.reply_text(f"âŒ You need ${total_cost} (${amount} + ${tax} tax). You only have ${balance}.")
        return
    
    sql.update_balance(user.id, chat.id, -total_cost)
    sql.update_balance(target.id, chat.id, amount)
    message.reply_text(f"ğŸ You gave ${amount} to {target.first_name}!\nğŸ’¸ Tax paid: ${tax}")


@run_async
def economy_help(update: Update, context: CallbackContext):
    """Show economy guide"""
    text = """ğŸ’° <b>Baka's Economy System</b>

Earn virtual money by robbing, killing and playing lottery game. Most commands work only in groups.

âš¡ All users will get $50 after every 12 hours!

ğŸ“Œ <b>Commands:</b>

/bal â€” Your/your friend's balance ğŸ’µ
/toprich â€” Top 10 richest globally ğŸŒ
/rob (reply) &lt;amount&gt; â€” Rob money ğŸ¦¹â€â™‚ï¸
/kill (reply) â€” Kill someone ğŸ’€
/protect &lt;1d|2d&gt; â€” Protect yourself ğŸ›¡ï¸
/revive (reply or no reply) â€” Revive yourself or a friend â¤ï¸
/give (reply) &lt;amount&gt; â€” Give money ğŸ
/myrank â€” Show global rank ğŸ†
/topkill â€” Top 10 killers â˜ ï¸

ğŸ”’ <b>Protection Rules:</b>

Protected users cannot be robbed or killed.
Dead users auto-revive after 5 hours, or use /revive to come back sooner.

1-day protection = $100 ğŸ’° | 2-day = $500 ğŸ’°ğŸ’°
Revive cost = $200 ğŸ’°

âš ï¸ Note: This is all virtual fun, no real money is involved! ğŸ‰"""
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


# Item System
@run_async
def items_list(update: Update, context: CallbackContext):
    """Show available items"""
    text = "ğŸ›ï¸ <b>Available Items</b>\n\n"
    
    for key, item in ITEMS.items():
        text += f"{item['emoji']} {item['name']} â€” ${item['price']}\n"
    
    text += "\nğŸ’¡ Use /gift &lt;item&gt; to gift items to friends!"
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


@run_async
def inventory(update: Update, context: CallbackContext):
    """Check user inventory"""
    message = update.effective_message
    user = update.effective_user
    
    if message.reply_to_message:
        target_user = message.reply_to_message.from_user
        user_id = target_user.id
        name = target_user.first_name
    else:
        user_id = user.id
        name = "Your"
    
    items = sql.get_inventory(user_id)
    
    if not items:
        message.reply_text(f"ğŸ“¦ {name} inventory is empty!")
        return
    
    text = f"ğŸ“¦ <b>{name} Inventory</b>\n\n"
    for item in items:
        # Find emoji
        for key, item_data in ITEMS.items():
            if item_data['name'].lower() == item.item_name.lower():
                text += f"{item_data['emoji']} {item.item_name} x{item.quantity}\n"
                break
        else:
            text += f"â€¢ {item.item_name} x{item.quantity}\n"
    
    message.reply_text(text, parse_mode=ParseMode.HTML)


@run_async
def gift_item(update: Update, context: CallbackContext):
    """Gift an item to another user"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    if not message.reply_to_message:
        message.reply_text("âŒ Reply to a user to gift them an item!")
        return
    
    target = message.reply_to_message.from_user
    
    if target.id == user.id:
        message.reply_text("âŒ You can't gift yourself!")
        return
    
    if not context.args:
        message.reply_text("âŒ Usage: /gift <item name> (reply to user)\n\nUse /items to see available items.")
        return
    
    item_search = " ".join(context.args).lower()
    
    # Find matching item
    item_key = None
    for key, item_data in ITEMS.items():
        if item_search in item_data['name'].lower() or item_search in key:
            item_key = key
            break
    
    if not item_key:
        message.reply_text("âŒ Item not found! Use /items to see available items.")
        return
    
    item = ITEMS[item_key]
    
    # Check balance
    balance = sql.get_balance(user.id, chat.id)
    if balance < item['price']:
        message.reply_text(f"âŒ {item['emoji']} {item['name']} costs ${item['price']}. You only have ${balance}.")
        return
    
    # Deduct money and add item to target's inventory
    sql.update_balance(user.id, chat.id, -item['price'])
    sql.add_item(target.id, item['name'], 1)
    
    message.reply_text(f"ğŸ You gifted {item['emoji']} {item['name']} to {target.first_name}!\nğŸ’° Cost: ${item['price']}")


# Lottery System
@run_async
def new_lottery(update: Update, context: CallbackContext):
    """Start a new lottery"""
    active = sql.get_active_lottery()
    
    if active:
        time_left = active.end_time - datetime.utcnow()
        hours = int(time_left.total_seconds() // 3600)
        message.reply_text(f"âŒ A lottery is already running! Time left: {hours}h")
        return
    
    lottery_id = sql.create_lottery()
    
    if lottery_id:
        update.effective_message.reply_text(
            "ğŸ° <b>New Lottery Started!</b>\n\n"
            "Duration: 2 days\n"
            "Minimum ticket: $1000\n\n"
            "Use /buy &lt;amount&gt; to join!\n"
            "Use /status to check progress",
            parse_mode=ParseMode.HTML
        )
    else:
        update.effective_message.reply_text("âŒ Failed to create lottery!")


@run_async
def buy_ticket(update: Update, context: CallbackContext):
    """Buy lottery ticket"""
    message = update.effective_message
    user = update.effective_user
    chat = update.effective_chat
    
    lottery = sql.get_active_lottery()
    
    if not lottery:
        message.reply_text("âŒ No active lottery! Use /new to start one.")
        return
    
    if not context.args:
        message.reply_text("âŒ Usage: /buy <amount>\n\nMinimum: $1000")
        return
    
    try:
        amount = int(context.args[0].replace("$", "").replace(",", ""))
    except ValueError:
        message.reply_text("âŒ Invalid amount!")
        return
    
    if amount < 1000:
        message.reply_text("âŒ Minimum ticket is $1000!")
        return
    
    balance = sql.get_balance(user.id, chat.id)
    
    if balance < amount:
        message.reply_text(f"âŒ You need ${amount}. You only have ${balance}.")
        return
    
    # Check if already joined
    if not sql.join_lottery(lottery.lottery_id, user.id, amount):
        message.reply_text("âŒ You already joined this lottery!")
        return
    
    sql.update_balance(user.id, chat.id, -amount)
    message.reply_text(f"ğŸ° You joined the lottery with ${amount}!\n\nUse /status to check progress.")


@run_async
def lottery_status(update: Update, context: CallbackContext):
    """Check lottery status"""
    lottery = sql.get_active_lottery()
    
    if not lottery:
        update.effective_message.reply_text("âŒ No active lottery!")
        return
    
    participants = sql.get_lottery_participants(lottery.lottery_id)
    
    time_left = lottery.end_time - datetime.utcnow()
    hours = int(time_left.total_seconds() // 3600)
    
    text = f"""ğŸ° <b>Lottery Status</b>

ğŸ’° Total Jackpot: ${lottery.total_pool}
ğŸ‘¥ Participants: {len(participants)}
â° Time Left: {hours} hours

ğŸ† <b>Prizes:</b>
ğŸ¥‡ 1st Place â†’ ${lottery.total_pool * 10}
ğŸ¥ˆ 2nd Place â†’ ${lottery.total_pool * 5}
ğŸ¥‰ 3rd Place â†’ ${lottery.total_pool * 3}

âš ï¸ Minimum 3 participants required!"""
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


@run_async
def lottery_game(update: Update, context: CallbackContext):
    """Show lottery game info"""
    text = """ğŸ° <b>Lottery Game Info</b>

âš™ï¸ <b>How It Works</b>

A new lottery runs for 2 days.
Use /buy &lt;amount&gt; to join the lottery (minimum ticket = $1000).
At the end, 3 winners are randomly selected.

ğŸ† <b>Prizes</b>

ğŸ¥‡ 1st Place â†’ amount Ã— 10
ğŸ¥ˆ 2nd Place â†’ amount Ã— 5
ğŸ¥‰ 3rd Place â†’ amount Ã— 3

ğŸ“Œ <b>Commands</b>

/new â†’ Start a new lottery (only if none running)
/buy &lt;amount&gt; â†’ Join the active lottery
/status â†’ Check players, jackpot & time left
/game â†’ Game info & rules

âš ï¸ <b>Rules</b>

â€¢ Minimum 3 participants required, otherwise all money is refunded
â€¢ Each player can join only once per lottery"""
    
    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML)


# Daily bonus (auto-trigger would need scheduler, for now manual)
@run_async
def daily(update: Update, context: CallbackContext):
    """Claim daily bonus"""
    user = update.effective_user
    chat = update.effective_chat
    
    # Check globally, not per-chat
    if not sql.can_claim_daily(user.id):
        update.effective_message.reply_text("âŒ You already claimed your daily bonus! Wait 12 hours.")
        return
    
    # Check if this is a new user (before giving bonus)
    balance_before = sql.get_balance(user.id, chat.id)
    is_new_user = (balance_before == 0)
    
    # Give daily bonus (and starting bonus if new)
    if is_new_user:
        sql.update_balance(user.id, chat.id, 100)  # $50 daily + $50 starting bonus
        update.effective_message.reply_text("âš¡ Daily bonus claimed! +$50\nğŸ‰ Welcome bonus! +$50\n\nğŸ’° Total received: $100")
    else:
        sql.update_balance(user.id, chat.id, 50)
        update.effective_message.reply_text("âš¡ Daily bonus claimed! +$50")
    
    sql.update_daily(user.id)


# Register handlers
dispatcher.add_handler(CommandHandler("bal", balance))
dispatcher.add_handler(CommandHandler("balance", balance))
dispatcher.add_handler(CommandHandler("toprich", top_rich))
dispatcher.add_handler(CommandHandler("topkill", top_killers))
dispatcher.add_handler(CommandHandler("myrank", my_rank))
dispatcher.add_handler(CommandHandler("rob", rob))
dispatcher.add_handler(CommandHandler("kill", kill))
dispatcher.add_handler(CommandHandler("revive", revive))
dispatcher.add_handler(CommandHandler("protect", protect))
dispatcher.add_handler(CommandHandler("give", give_money))
dispatcher.add_handler(CommandHandler("economy", economy_help))
dispatcher.add_handler(CommandHandler("items", items_list))
dispatcher.add_handler(CommandHandler("item", inventory))
dispatcher.add_handler(CommandHandler("inventory", inventory))
dispatcher.add_handler(CommandHandler("gift", gift_item))
dispatcher.add_handler(CommandHandler("new", new_lottery))
dispatcher.add_handler(CommandHandler("buy", buy_ticket))
dispatcher.add_handler(CommandHandler("status", lottery_status))
dispatcher.add_handler(CommandHandler("game", lottery_game))
dispatcher.add_handler(CommandHandler("daily", daily))

__mod_name__ = "Economy"
__help__ = """
ğŸ’° Economy System - Earn, rob, kill, and play lottery!

Commands:
 â€¢ `/bal` - Check balance
 â€¢ `/toprich` - Top 10 richest
 â€¢ `/topkill` - Top 10 killers
 â€¢ `/myrank` - Your global rank
 â€¢ `/rob` <amount> - Rob someone (reply)
 â€¢ `/kill` - Kill someone (reply)
 â€¢ `/revive` - Revive yourself or someone (reply)
 â€¢ `/protect` <1d|2d> - Buy protection
 â€¢ `/give` <amount> - Give money (reply, 10% tax)
 â€¢ `/economy` - Full economy guide
 â€¢ `/items` - See all items
 â€¢ `/item` - Check inventory
 â€¢ `/gift` <item> - Gift item (reply)
 â€¢ `/new` - Start lottery
 â€¢ `/buy` <amount> - Join lottery
 â€¢ `/status` - Lottery status
 â€¢ `/game` - Lottery info
 â€¢ `/daily` - Claim daily bonus ($50 every 12h)
"""
